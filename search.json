[{"title":"TypeScript安装","url":"/2022/07/11/TypeScript%E5%AE%89%E8%A3%85/","content":"TypeScript安装建议采用局部安装，即只安装到项目目录下，不建议全局安装，尤其是在用nvm管理nodejs版本的情况下更不建议了。\nMacOS和Linux所有操作都是在项目目录下进行的\nsudo npm install typescript -D\n\nsudo npm install ts-node -D\n\n如果要直接运行.ts文件的话，输入\nnpx ts-node 文件名.ts \n\n如果要编译为js文件的话，输入\nnpx tsc 文件名.ts  \n\nWindows所有操作都是在项目目录下进行的\n以管理员模式运行cmd，定位到项目目录\nnpm install typescript -D\n\nnpm install ts-node -D\n\n如果要直接运行.ts文件的话，输入\nnpx ts-node 文件名.ts \n\n如果要编译为js文件的话，输入\nnpx tsc 文件名.ts \n\n","categories":["编程环境安装和配置"]},{"title":"二叉搜索树的验证、查找、插入和删除","url":"/2022/06/06/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81%E3%80%81%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/","content":"二叉搜索树的查找、插入和删除二叉搜索树二叉搜索树又被称为二叉排序树，它本身也是一棵二叉树，且满足以下性质：\n\n若左子树不为空，则左子树上左右节点的值都小于根节点的值\n若它的右子树不为空，则它的右子树上所有的节点的值都大于根节点的值\n它的左右子树也要分别是二叉搜索树\n\nstruct TreeNode &#123;\t\tint val;\t\tTreeNode *left;\t\tTreeNode *right;\t\tTreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) \t\t&#123;&#125;&#125;;\n\n验证是否为二叉搜索树递归法利用有效二叉树的定义：\n\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\nbool helper(TreeNode* root, long long lower, long long upper)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn true;\t\t&#125;\t\tif (root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)&#123;\t\t\t\treturn false;\t\t&#125;\t\treturn helper(root-&gt;left, lower, root-&gt;val)       \t\t\t&amp;&amp; helper(root-&gt;right, root-&gt;val, upper);&#125;bool isValidBST(TreeNode* root) &#123;\t\treturn helper(root, LONG_MIN, LONG_MAX);&#125;\n\n中序遍历中序遍历结果应为递增序列\n二叉搜索树的查找TreeNode* searchBST(TreeNode* root, int val) &#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn nullptr;\t\t&#125;\t\tif (root-&gt;val == val)&#123;\t\t\t\treturn root;\t\t&#125;\t\treturn root-&gt;val &gt; val ? searchBST(root-&gt;left, val) : searchBST(root-&gt;right, val);&#125;\n\n二叉搜素树的插入当将 val插入到以 root为根的子树上时，根据 val与 root.val的大小关系，就可以确定要将 val插入到哪个子树中：\n\n如果该子树不为空，则问题转化成了将 val插入到对应子树上\n否则，在此处新建一个以 val为值的节点，并链接到其父节点 root上\n\nTreeNode* insertIntoBST(TreeNode* root, int val) &#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn new TreeNode(val);\t\t&#125;\t\tTreeNode* pos = root;\t\twhile (pos != nullptr)&#123;\t\t\t\tif (pos-&gt;val &lt; val)&#123;\t\t\t\t\t\tif (pos-&gt;right == nullptr)&#123;\t\t\t\t\t\t\t\tpos-&gt;right = new TreeNode(val);\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t&#125; else&#123;\t\t\t\t\t\t\t\tpos = pos-&gt;right;\t\t\t\t\t\t&#125;\t\t\t\t&#125; else&#123;\t\t\t\t\t\tif (pos-&gt;left == nullptr)&#123;\t\t\t\t\t\t\t\tpos-&gt;left = new TreeNode(val);\t\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t&#125; else&#123;\t\t\t\t\t\t\t\tpos = pos-&gt;left;\t\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t&#125;\t\treturn root;&#125;\n\n二叉搜索树的的删除删除操作比较复杂，可以分为以下三种情况：\n\n被删除节点为叶子节点：直接删除该节点\n被删除结点有一个左孩子或一个右孩子：将孩子结点设为该结点的父结点的孩子后，即可删除该结点\n被删除结点有两个孩子结点：一般的删除策略是，用被删除结点的右子树中的最小结点替代被删除结点，并递归地删除这个最小数据结点\n\n利用前继和后继节点也可以分为以下三种情况：\n\n要删除的节点为叶子节点，可以直接删除\n\n\n\n要删除的节点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点\n\n\n\n删除的节点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点\n\n\n//寻找后继节点TreeNode* successor(TreeNode* root)&#123;\t\troot = root-&gt;right;\t\twhile (root-&gt;left != nullptr)&#123;\t\t\t\troot = root-&gt;left;\t\t&#125;\t\treturn root;&#125;//寻找前继节点TreeNode* predecessor(TreeNode* root)&#123;\t\troot = root-&gt;left;\t\twhile (root-&gt;right != nullptr)&#123;\t\t\t\troot = root-&gt;right;\t\t&#125;\t\treturn root;&#125;TreeNode* deleteNode(TreeNode* root, int key) &#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn nullptr;\t\t&#125;\t\tif (root-&gt;val &gt; key)&#123; //在左子树中寻找要删除的节点\t\t\t\troot-&gt;left = deleteNode(root-&gt;left, key);\t\t&#125; else if(root-&gt;val &lt; key)&#123; //在右子树中寻找要删除的节点\t\t\t\troot-&gt;right = deleteNode(root-&gt;right, key);\t\t&#125; else&#123; //找到要删除的节点\t\t\t\tif (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)&#123;          \t//如果是叶子节点，则直接删除\t\t\t\t\t\troot = nullptr;\t\t\t\t&#125; else if (root-&gt;right != nullptr)&#123;           \t//如果有右子树，则用其后继值代替，并递归的删除这个后继节点\t\t\t\t\t\troot-&gt;val = successor(root)-&gt;val;\t\t\t\t\t\troot-&gt;right = deleteNode(root-&gt;right, root-&gt;val);\t\t\t\t&#125; else&#123;          \t//如果左右子树，则用其后继值代替，并递归的删除这个后继节点\t\t\t\t\t\troot-&gt;val = predecessor(root)-&gt;val;\t\t\t\t\t\troot-&gt;left = deleteNode(root-&gt;left, root-&gt;val);\t\t\t\t&#125;\t\t&#125;\t\treturn root;&#125;//注意：这里的前继节点和后继节点并不是严格意义上的，而是建立在左（右）子树存在的基础上的\n\n","categories":["数据结构与算法"]},{"title":"二叉树的遍历","url":"/2022/06/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/","content":"二叉树的遍历二叉树节点的定义struct TreeNode &#123;\t\tint val;\t\tTreeNode *left;\t\tTreeNode *right;\t\tTreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\t\tTreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) \t\t&#123;&#125;&#125;;\n\n前序遍历递归实现vector&lt;int&gt; preOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tpreOrder(root,res);\t\treturn res;&#125;    void preOrder(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn;\t\t&#125;\t\tres.push_back(root-&gt;val);\t\tpreOrder(root-&gt;left,res);\t\tpreOrder(root-&gt;right,res);&#125;\n\n非递归实现当栈不为空时，栈顶元素出栈，如果其右子节点不为空，则右子节点入栈，其左字节点不为空，则左字节点入栈，这样出栈时，则会先出左子节点，再出右子节点，则能够完成树的前序遍历\nvector&lt;int&gt; preOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tif (root == nullptr)&#123;\t\t\t\treturn res;\t\t&#125;\t\tstack&lt;TreeNode*&gt; s;\t\ts.push(root);\t\twhile (!s.empty())&#123;\t\t\t\tTreeNode* temp = s.top();\t\t\t\ts.pop();\t\t\t\tres.push_back(temp-&gt;val);\t\t\t\tif (temp-&gt;right)&#123;\t\t\t\t\t\ts.push(temp-&gt;right);\t\t\t\t&#125;\t\t\t\tif (temp-&gt;left)&#123;\t\t\t\t\t\ts.push(temp-&gt;left);\t\t\t\t&#125;\t\t&#125;\t\treturn res;&#125;\n\n中序遍历递归实现vector&lt;int&gt; inOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tinOrder(root,res);\t\treturn res;&#125;void inOrder(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn;\t\t&#125;\t\tinOrder(root-&gt;left,res);\t\tres.push_back(root-&gt;val);\t\tinOrder(root-&gt;right,res);&#125;\n\n非递归实现vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tif (root == nullptr)&#123;\t\t\t\treturn res;\t\t&#125;\t\tstack&lt;TreeNode*&gt; stk;\t\twhile (!stk.empty() || root != nullptr)&#123;\t\t\t\t//不断往左子树方向走，每走一次就将当前节点保存到栈中\t\t\t\twhile (root != nullptr)&#123;\t\t\t\t\t\tstk.push(root);\t\t\t\t\t\troot = root-&gt;left;\t\t\t\t&#125;\t\t\t\t//当前节点为空，说明左边走到头了，从栈中弹出节点并保存\t\t\t\t//然后转向右边节点，继续上面整个过程\t\t\t\troot = stk.top();\t\t\t\tstk.pop();\t\t\t\tres.push_back(root-&gt;val);\t\t\t\troot = root-&gt;right;\t\t&#125;\t\treturn res;&#125;\n\n后序遍历递归实现vector&lt;int&gt; postOrderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tpostOrder(root,res);\t\treturn res;&#125;void postOrder(TreeNode* root, vector&lt;int&gt; &amp;res)&#123;\t\tif (root == nullptr)&#123;\t\t\t\treturn;\t\t&#125;\t\tpostOrder(root-&gt;left,res);\t\tpostOrder(root-&gt;right,res);\t\tres.push_back(root-&gt;val);&#125;\n\n非递归实现因为后序遍历二叉树的顺序是先访问左子树，再访问右子树，最后访问根节点。当用堆栈来存储节点，必须分清返回根节点时，是从左子树返回的，还从右子树返回的。所以，使用辅助指针prev指向最近访问过的节点，来判断是否从右子树返回。也可以在节点中增加一个标志域，记录是否已被访问。\nvector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;\t\tvector&lt;int&gt; res;\t\tif (root == nullptr)&#123;\t\t\t\treturn res;\t\t&#125;\t\tstack&lt;TreeNode*&gt; stk;\t\tTreeNode* prev = nullptr;\t\twhile (root != nullptr || !stk.empty())&#123;\t\t\t\twhile (root != nullptr)&#123;//不断往左子树方向走\t\t\t\t\t\tstk.push(root);\t\t\t\t\t\troot = root-&gt;left;\t\t\t\t&#125;\t\t\t\troot = stk.top();\t\t\t\tstk.pop();\t\t\t\tif (root-&gt;right &amp;&amp; root-&gt;right != prev)&#123;//右子树存在且未被访问\t\t\t\t\t\tstk.push(root);//从左子树返回，不能弹出根节点，应再压回栈内\t\t\t\t\t\troot = root-&gt;right;\t\t\t\t&#125;else&#123;\t\t\t\t\t\tres.push_back(root-&gt;val);\t\t\t\t\t\tprev = root;\t\t\t\t\t\troot = nullptr;\t\t\t\t&#125;\t\t&#125;\t\treturn res;&#125;\n\n按层次遍历//遍历结果将一个层次存储到一个vector中vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;\t\tvector&lt;vector&lt;int&gt;&gt; result;\t\t//树为空直接返回\t\tif (root == nullptr)&#123;\t\t\t\treturn result;\t\t&#125;\t\tqueue&lt;TreeNode*&gt; q;\t\tq.push(root); //先将根节点入队\t\twhile (!q.empty())&#123;\t\t\t\tvector&lt;int&gt; temp;\t\t\t\tint n = q.size();\t\t\t\tfor (int i = 0; i &lt; n; i++)&#123;\t\t\t\t\t\tTreeNode* node = q.front();\t\t\t\t\t\tq.pop(); //出队并保存节点\t\t\t\t\t\ttemp.push_back(node-&gt;val);\t\t\t\t\t\t//将节点的左子树入队\t\t\t\t\t\tif (node-&gt;left != nullptr)&#123;\t\t\t\t\t\t\t\tq.push(node-&gt;left);\t\t\t\t\t\t&#125;            //将节点的右子树入队\t\t\t\t\t\tif (node-&gt;right != nullptr)&#123;\t\t\t\t\t\t\t\tq.push(node-&gt;right);\t\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tresult.push_back(temp);\t\t&#125;\t\treturn result;&#125;\n\n","categories":["数据结构与算法"]},{"title":"第一章 绪论","url":"/2022/06/06/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/","content":"第一章 绪论1.1 数据库系统概述1.1.1 数据库的4个基本概念1. 数据\n描述事物的符号记录称为数据\n数据的含义称为数据的语义，数据与其语义密不可分\n\n2. 数据库\n数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易拓展性，并可为各种用户共享\n概括来讲，数据库数据具有永久存储、有组织和可共享三个基本特点\n\n3. 数据库管理系统数据库管理系统（DBMS）的主要功能包括以下几个方面：\n\n数据定义功能\n数据组织、存储和管理\n数据操纵功能\n数据库的事务管理和运行管理\n数据库的建立和维护功能\n其他功能\n\n4. 数据库系统数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统\n\n\n1.1.2 数据管理技术的产生和发展\n\n\n\n人工管理阶段\n文件系统阶段\n数据库系统阶段\n\n\n\n应用背景\n科学计算\n科学计算、数据管理\n大规模数据管理\n\n\n硬件背景\n无直接存取存储设备\n磁盘、磁鼓\n大容量磁盘、磁盘阵列\n\n\n软件背景\n没有操作系统\n有文件系统\n有数据库管理系统\n\n\n处理方式\n批处理\n联机实时处理、批处理\n联机实时处理、分布处理、批处理\n\n\n数据的管理者\n用户（程序员）\n文件系统\n数据库管理系统\n\n\n数据面向的对象\n某一应用程序\n某一应用\n现实世界\n\n\n数据的共享程度\n无共享、冗余度极大\n共享性差、冗余度大\n共享性高、冗余度小\n\n\n数据的独立性\n不独立、完全依赖于程序\n独立性差\n具有高度的物理独立性和一定的逻辑独立性\n\n\n数据的结构化\n无结构\n记录内有结构、整体无结构\n整体结构化，用数据模型描述\n\n\n数据控制能力\n应用程序自己控制\n应用程序自己控制\n由数据库管理系统提供数据安全性、完整性、并发控制和恢复能力\n\n\n数据库系统的特点：\n\n数据结构化\n\n整体结构化\n不再仅仅针对某一个应用，而是面向全组织\n不仅数据内部结构化，整体是结构化的，数据之间具有联系\n数据记录可以变长\n数据的最小存取单位是数据项\n\n\n数据的用数据模型描述，无需应用程序定义\n\n\n数据的共享性高，冗余度低且易扩充\n\n数据面向整个系统，可以被多个用户、多个应用共享使用\n数据共享的好处\n减少数据冗余，节约存储空间\n避免数据之间的不相容性与不一致性 \n使系统易于扩充\n\n\n\n\n数据独立性高\n\n物理独立性\n指用户的应用程序与数据库中数据的物理存储是相互独立的。当数据的物理存储改变了，应用程序不用改变\n\n\n逻辑独立性\n指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，应用程序不用改变\n\n\n数据独立性由数据库管理系统的二级映像功能来保证\n\n\n数据由数据管理系统统一管理和控制\n\n数据库管理系统提供的数据控制功能\n数据的安全性保护：保护数据以防止不合法的使用造成的数据的泄密和破坏\n数据的完整性检查：保证数据的正确性、有效性和相容性\n并发控制：对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果\n数据库恢复：将数据库从错误状态恢复到某一已知的正确状态\n\n\n\n\n\n1.2 数据模型1.3 数据库系统的结构1.3.1 数据库系统模式的概念\n在数据库模型中有“型“和”值“的概念\n型是指对某一类数据的结构和属性的说明\n值是型的一个具体赋值\n\n\n模式是数据库中全体数据的逻辑结构和特征的描述，仅仅涉及型的描述，不涉及具体值\n模式的一个具体的值称为模式的实例，同一个模式可以有多个实例\n\n1.3.2 数据库的三级模式结构\n\n1. 模式\n模式，也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图\n一个数据库只有一个模式\n模式是数据库系统模式结构的中间层，与数据的物理存储细节和硬件环境无关，与具体的应用程序、开发工具及高级程序设计语言无关\n定义模式时不仅要定义数据的逻辑结构，而且要定义数据之间的联系，定义数据有关的安全性、完整性要求\n\n2. 外模式\n外模式也称子模式或用户模式，它是数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示\n\n模式与外模式的关系：一对多\n\n外模式通常是模式的子集\n一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求\n对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同\n\n\n外模式与应用的关系：一对多\n\n同一外模式也可以为某一用户的多个应用系统所使用\n但一个应用程序只能使用一个外模式\n\n\n外模式的用途\n\n保证数据库安全性的一个有力措施\n每个用户只能看见和访问所对应的外模式中的数据\n\n\n\n3. 内模式\n内模式也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式\n\n记录的存储方式（例如，顺序存储，堆存储，hash存储等）\n索引的组织方式\n数据是否压缩存储\n数据是否加密\n数据存储记录结构的规定\n\n\n一个数据库只有一个内模式\n\n\n1.3.3 数据库的二级映像功能与数据独立性\n数据库系统的三级模式是数据的三个抽象级别，它把数据的具体组织留给数据库管理系统，使用户能逻辑地、抽象地处理数据，而不必关心数据在计算机中的具体表示方式与存储方式\n为了能够在系统内部实现这三个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像\n\n1. 外模式/模式映像\n模式描述的是数据的全局逻辑结构\n外模式：描述的是数据的局部逻辑结构 \n同一个模式可以有任意多个外模式 \n每一个外模式，数据库系统都有一个外模式/模式映象，定义外模式与模式之间的对应关系\n映象定义通常包含在各自外模式的描述中\n保证数据的逻辑独立性\n当模式改变时，数据库管理员对外模式/模式映象作相应改变，使外模式保持不变\n应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性\n\n\n\n2. 模式/内模式映像\n模式/内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。\n数据库中模式/内模式映象是唯一的\n该映象定义通常包含在模式描述中\n保证数据的物理独立性\n当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式/内模式映象，使模式保持不变\n应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性\n\n\n\n3. 数据库的二级映像\n数据库模式\n\n即全局逻辑结构是数据库的中心与关键\n独立于数据库的其他层次 \n设计数据库模式结构时应首先确定数据库的逻辑模式\n\n\n数据库的内模式\n\n依赖于它的全局逻辑结构\n独立于数据库的用户视图，即外模式\n独立于具体的存储设备 \n将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率\n\n\n数据库的外模式\n\n面向具体的应用程序\n定义在逻辑模式之上\n独立于存储模式和存储设备\n当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动\n设计外模式时应充分考虑到应用的扩充性\n\n\n特定的应用程序\n\n在外模式描述的数据结构上编制的\n依赖于特定的外模式\n与数据库的模式和存储结构独立\n不同的应用程序有时可以共用同一个外模式\n\n\n数据库的二级映像\n\n保证了数据库外模式的稳定性\n从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改\n\n\n数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去\n\n数据的存取由数据库管理系统管理\n\n简化了应用程序的编制\n大大减少了应用程序的维护和修改\n\n\n\n1.4 数据库系统的组成1. 硬件平台及数据库数据库系统对硬件资源的要求\n\n足够大的内存\n\n足够的大的磁盘或磁盘阵列等设备\n\n较高的通道能力，提高数据传送率\n\n\n2. 软件数据库系统的软件主要包括\n\n数据库管理系统\n支持数据库管理系统运行的操作系统\n与数据库接口的高级语言及其编译系统\n以数据库管理系统为核心的应用开发工具\n为特定应用环境开发的数据库应用系统\n\n3. 人员\n\n（1）数据库管理人员\n\n决定数据库中的信息内容和结构\n\n决定数据库的存储结构和存取策略\n\n定义数据的安全性要求和完整性约束条件\n\n监控数据库的使用和运行\n\n周期性转储数据库\n数据文件\n日志文件\n系统故障恢复\n介质故障恢复\n监视审计文件\n\n\n\n\n数据库的改进和重组\n\n性能监控和调优\n定期对数据库进行重组织，以提高系统的性能 \n需求增加和改变时，数据库须需要重构造\n\n\n\n（2）系统分析员\n\n负责应用系统的需求分析和规范说明\n与用户及数据库管理员结合，确定系统的硬软件配置\n参与数据库系统的概要设计\n\n（3）数据库设计人员\n\n参加用户需求调查和系统分析\n确定数据库中的数据\n设计数据库各级模式\n\n（4）应用程序员\n\n设计和编写应用系统的程序模块\n进行调试和安装\n\n（5）最终用户：最终用户通过应用系统的用户接口使用数据库。\n\n偶然用户\n\n不经常访问数据库，但每次访问数据库时往往需要不同的数据库信息 \n企业或组织机构的高中级管理人员\n\n\n简单用户\n\n主要工作是查询和更新数据库 \n\n银行的职员、机票预定人员、旅馆总台服务员\n\n\n\n复杂用户\n\n工程师、科学家、经济学家、科技工作者等\n直接使用数据库语言访问数据库，甚至能够基于数据库管理系统的应用程序接口编制自己的应用程序\n\n\n\n","categories":["数据库"]},{"title":"第九章 无线网络和移动网络","url":"/2022/06/06/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/","content":"第九章 无线网络和移动网络9.1 无线局域网WLAN9.1.1 无线局域网的组成无线局域网可分为有固定基础设施的和无固定基础设施的两大类。“固定基础设施”是指预先建立起来的、能够覆盖一定地理范围的一批固定基站\n1. IEEE 802.11\n对于第一类有固定基础设施的无线局域网，1997 年 IEEE 制定出无线局域网的协议标准 802.11[W-IEEE802.11]系列标准\n802.11 是无线以太网的标准，它使用星形拓扑，其中心叫做接入点 AP（Access Point），在 MAC 层使用 CSMA/CA 协议\n凡使用 802.11 系列协议的局域网又称为 Wi-Fi（Wireless-Fidelity，意思是“无线保真度”）\n现在 Wi-Fi 实际上已经成为了无线局域网 WLAN 的代名词，但无线局域网和“保真度”实在没有什么关系\n802.11 标准规定无线局域网的最小构件是基本服务集 BSS（Basic Service Set）\n一个基本服务集 BSS 包括一个基站和若干个移动站，一个站无论要和本 BSS 的站进行通信，还是要和其他 BSS 的站进行通信，都必须通过本 BSS 的基站\n\n\n\n9.1.2 802.11 局域网的物理层9.1.3 802.11 局域网的MAC层1. CSMA/CA 协议\n在无线局域网中，仍然可以使用载波监听多址接入 CSMA , 即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞\n在无线局域网中，不能使用碰撞检测CD ，原因如下：\n由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD ，对硬件的要求非常高\n即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题）， 进行碰撞检测的意义也不大\n\n\n\n\n\n802.11 无线局域网使用 CSMA/CA 协议，在 CSMA 的基础上增加了一个碰撞避免 CA 功能，而不再实现碰撞检测功能\n\n由于不可能避免所有的碰撞，并且无线信道误码率较高， 802.11 标准还使用了数据链路层确认机制（停止-等待协议） 来保证数据被正确接收\n\n802.11 的 MAC 层标准定义了两种不同的媒体接入控制方式：\n\n分布式协调功能 DCF（Distributed Coordination Function）。在 DCF 方式下，没有中心控制站点，每个站点使用 CSMA/CA 协议通过争用信道来获取发送权，这是802.11 定义的默认方式\n\n点协调功能 PCF（Point Coordination Function）。PCF 方式使用集中控制的接入算法（一般在接入点AP 实现集中控制），是802.11 定义的可选方式，在实际中较少使用\n\n\n\n802.11 标准规定，所有的站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间称为帧间间隔IFS（InterFrame Space）\n\n帧间间隔的长短取决于该站点要发送的帧的类型：\n\n高优先级帧需要等待的时间较短，因此可优先获得发送权；\n优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会。\n\n\n常用的两种帧间间隔如下：\n\n短帧间间隔 SIFS（），是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用 SIFS 的帧类型有 ACK 帧、CTS 帧、由过长的 MAC 帧分片后的数据帧、以及所有回答 AP 探询的帧和在 PCF 方式中接入点 AP 发送出的任何帧\nDCF 帧间间隔 DIFS（），它比短帧间间隔 SIFS 要长得多，在 DCF 方式中用来发送数据帧和管理帧\n\n\n\nCSMA/CA 协议工作原理：\n\n\n当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法\n以下情况必须使用退避算法：\n在发送数据帧之前检测到信道处于忙状态时\n每一次重传一个数据帧时\n在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）\n\n\n在执行退避算法时，站点为退避计时器设置一个随机的退避时间：\n当退避计时器的时间减小到零时，就开始发送数据\n当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经过时间 DIFS 后，继续启动退避计时器\n\n\n在进行第次退避时，退避时间在时隙编号中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少.当时隙编号达到255时（对应于第6次退避）就不再增加了\n\n\n2. 对信道进行预约\n为了尽可能减少碰撞的概率和降低碰撞的影响， 802.11 标准允许要发送数据的站点对信道进行预约\n源站在发送数据帧之前先发送一个短的控制帧，称为请求发送 RTS（request to send），它包括源地址目的地址以及这次通信（包括相应的确认帧）所需的持续时间\n\n若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送 CTS（clear to send），它也包括这次通信所需的持续时间（从 RTS 帧中将此持续时间复制到 CTS 帧中）\n\n源站收到 CTS 帧后，再等待一段时间 SIFS 后，就可发送其数据帧\n\n若目的站正确收到了源站发来的数据帧，在等待时间 SIFS 后，就向源站发送确认帧 ACK\n\n\n\n\n\n\n\n除源站和目的站以外的其他各站，在收到 CTS 帧（或数据帧）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰\n\n如果 RTS 帧发生碰撞，源站就收不到 CTS 帧，需执行退避算法重传 RTS 帧\n\n由于RTS帧和CTS帧很短，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一般的数据帧，其发送时延往往大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往是值得的。802.11 标准规定了3种情况供用户选择：\n\n使用 RTS 帧和 CTS 帧\n不使用 RTS 帧和 CTS 帧\n只有当数据帧的长度超过某一数值时才使用 RTS 帧和 CTS 帧\n\n\n除 RTS 帧和 CTS 帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为802.11的虚拟载波监听机制\n\n由于利用虚拟载波监听机制， 站点只要监听到 RTS 帧、CTS 帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题\n\n\nCSMA/CA的基本流程图：\n\n\n\n\n9.1.4 802.11 局域网的MAC帧","categories":["计算机网络"]},{"title":"第二章 关系数据库","url":"/2022/06/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"第二章 关系数据库2.1 关系数据结构及形式化定义2.1.1 关系\n域：域是一组具有相同数据类型的值的集合\n\n笛卡尔积：给定一组域 ，允许其中某些域是相同的，​的笛卡尔积为\n\n其中，每一个元素叫作一个  元组，或简称元组\n元素中的每一个值  叫做一个分量\n一个域允许的不同取值个数称为这个域的基数\n若  为有限集，其基数为  ，则的基数 \n\n\n关系： 的子集叫做在域名 上的关系，表示为 \n\n 表示关系的名字\n 是关系的目或者度\n\n\n若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码\n\n若一个关系有多个候选码，则选定其中一个为主码\n候选码的诸属性称为主属性\n不包含在任何侯选码中的属性称为非主属性或非码属性\n在简单的情况下，候选码只包含一个属性；在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码\n\n\n关系可以有三种类型：基本关系（基本表或基表）、查询表和视图表\n\n基本关系是实际存在的表，是实际存储数据的逻辑表示\n查询表是查询结果对应的表\n视图表是由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据\n\n\n基本关系的性质：\n\n列是同质的，即每一列中的分量是同一类型的数据，来自同一个域\n不同的列可出自同一个域，称其中的每一列称为一个属性，不同的属性要给予不同的属性名\n列的顺序无所谓\n任意两个元组的候选码不能相同\n行的顺序无所谓\n分量必须取原子值\n\n\n\n2.1.2 关系模式\n关系模式是对关系的描述，关系模式是型，关系是值\n\n关系的描述称为关系模式。可以形式化地表示为 \n\n 为关系名\n\n 为组成该关系的属性名集合\n\n 为  中属性所来自的域\n\n 为属性向域的映像集合\n\n 为属性间数据的依赖关系集合\n\n\n\n\n2.1.3 关系数据库\n在一个给定的应用领域中，所有关系的集合构成一个关系数据库\n关系数据库的型，也称关系数据库模式，是对关系数据库的描述\n关系数据库的值，是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库\n\n2.2 关系的完整性\n实体完整性和参照完整性\n\n关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持\n\n\n用户定义的完整性\n\n应用领域需要遵循的约束条件，体现了具体领域中的语义约束\n\n\n2.2.1 实体完整性\n实体完整性规则：若属性  是基本关系  的主属性，则属性  不能取空值。空值就是“不知道”或“不存在”或“无意义”的值\n对于实体完整性规则的说明：\n实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集\n现实世界中的实体是可区分的，即它们具有某种唯一性标识\n关系模型中以主码作为唯一性标识\n主码中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第2点相矛盾，因此这个规则称为实体完整性\n\n\n\n2.2.2. 参照完整性\n在关系模型中实体及实体间的联系都是用关系来描述的，自然存在着关系与关系间的引用\n设  是基本关系  的一个或一组属性，但不是关系  的码， 是基本关系  的主码。如果  与  相对应，则称  是  的外码，并称基本关系  为参照关系，基本关系  为被参照关系或目标关系\n其中关系  和  不一定是不同的关系\n目标关系  的主码  和参照关系的外码  必须定义在同一个（或一组）域上\n外码并不一定要与相应的主码同名\n当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别\n\n\n\n\n\n\n\n\n参照完整性规则：若属性（或属性组） 是基本关系  的外码它与基本关系  的主码  相对应（基本关系  和  不一定是不同的关系），则对于  中每个元组在  上的值必须为：\n\n或者取空值（ 的每个属性值均为空值）\n\n或者等于  中某个元组的主码值\n\n\n\n\n2.2.3 用户定义的完整性\n用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求\n关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能\n\n2.3 关系代数2.3.1 传统的集合运算\n并：\n差：\n交：\n笛卡尔积：\n\n2.3.2 专门的关系运算首先引入几个记号：\n\n，，：\n\n设关系模式为 \n它的一个关系设为 \n表示  是  的一个元组\n 则表示元组  中相应于属性 的一个分量\n\n\n，， \n\n若，其中  是 中的一部分，则  称为属性列或属性组\n\n表示元组  在属性列 上诸分量的集合\n\n 则表示  中去掉  后剩余的属性组\n\n\n\n：\n\n 为  目关系， 为  目关系\n 称为元组的连接\n 是一个  列的元组，前  个分量为  中的一个  元组，后  个分量为  中的一个  元组\n\n\n象集\n\n给定一个关系 ， 和  为属性组\n当 时， 在  中的象集为：\n它表示  中属性组  上值为  的诸元组在  上分量的集合\n\n\n\n下例中的学生-课程数据库如下：\n\n1. 选择\n选择又称为限制\n\n选择是在关系  中选择满足给定条件的诸元组，记作真其中  表示选择条件，它是一个逻辑表达式，取逻辑值“真”或“假”\n\n逻辑表达式  的基本形式为 θ，其中 θ 表示比较运算符。在基本的选择条件上可以进一步进行逻辑运算\n\n\n选择运算是从行角度进行的运算\n\n\n\n例：查询信息系（IS系）全体学生：，结果如下：\n\n\n\n\nSno\nSame\nSex\nSage\nSlept\n\n\n\n201215125\n张立\n男\n19\nIS\n\n\n2. 投影\n投影是从  中选择出若干属性列组成新的关系，记作\n\n投影操作主要是从列的角度进行运算\n\n投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）\n\n\n\n例：查询学生关系  中都有哪些系，即查询关系  上所在系属性上的投影：，结果如下：\n\n\n\n\nSdept\n\n\n\nCS\n\n\nIS\n\n\nMA\n\n\n3. 连接\n连接也称为 θ 连接，是从两个关系的笛卡尔积中选取属性间满足一定条件的元组，记作θ\n\n连接运算从  和  的广义笛卡尔积  中选取  关系在  属性组上的值与  关系在  属性组上的值满足比较关系 θ 的元组\n\n连接运算中最为重要且最为常用的连接为等值连接和自然连接\n\nθ 为 “” 的连接运算称为等值连接\n\n是从关系  与  的广义笛卡尔积中选取 ​ 属性值相等的那些元组，即等值连接为：\n\n\n\n自然连接是一种特殊的等值连接\n\n要求两个关系中进行比较的分量必须是相同的属性组\n\n并且在结果中把重复的属性列去掉\n\n若  和  具有相同的属性组 ， 为  和 ​ 的全体属性集合，则自然连接可记作\n\n\n\n一般的连接操作是从行的角度进行运算\n\n自然连接还需要取消重复列，所以是同时从行和列的角度进行运算。\n\n\n\n\n\n例：设下图  和  分别为关系  和关系 ，图  为非等值连接  的结果，图  为等值连接 的结果，图  为自然连接  的结果\n\n\n\n两个关系  和  在做自然连接时，关系  中某些元组有可能在  中不存在公共属性上值相等的元组，从而造成  中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组\n如果把悬浮元组也保存在结果关系中，而在其他属性上填空值（Null），就叫做外连接，记作 ⟗\n如果只保留左边关系  中的悬浮元组，则称为左外连接，记作 ⟕\n如果只保留右边关系  中的悬浮元组，则称为右外连接，记作 ⟖\n\n\n\n\n例：下图  是上例中关系  和关系  的外连接，图  是左外连接，图  是右外连接\n\n\n4. 除运算设关系  除以关系  的结果为关系 ，则  包含所有在  但不在  中的属性及其值，且  的元组与  的元组的所有组合都在  中\n用象集定义除运算：\n\n给定关系  和 ，其中  为属性组\n\n 中的  与  中的  可以有不同的属性名，但必须出自相同的域集\n\n 与  的除运算得到一个新的关系 ， 是  中满足下列条件的元组在  属性列上的投影：元组在  上分量值  的象集  包含  在  上投影的集合，记作：其中  为  在  中的象集，\n\n除是同时从行和列的角度进行运算\n\n\n\n例：设关系  分别为下图中的  和  ， 的结果如图 \n\n\n","categories":["数据库"]},{"title":"第五章 数据库完整性","url":"/2022/06/06/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/","content":"第五章 数据库完整性\n数据库的完整性是指数据的正确性和相容性\n数据的正确性是指数据是符合现实世界语义，反映了当前实际状况的\n数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的\n\n\n数据的完整性和安全性是两个既有联系又不尽相同的概念\n数据的完整性\n防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据\n防范对象：不合语义的、不正确的数据\n\n\n数据的安全性\n保护数据库，防止恶意的破坏和非法的存取\n防范对象：非法用户和非法操作\n\n\n\n\n为维护数据库的完整性，数据库管理系统必须实现如下功能\n提供定义完整性约束条件的机制\n完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件\nSQL 标准使用了一系列概念来描述完整性，包括关系模型的实体完整性、参照完整性和用户定义完整性\n这些完整性一般由 SQL 的数据定义语言语句来实现\n\n\n提供完整性检查的方法\n数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。\n一般在 INSERT、UPDATE、DELETE 语句执行后开始检查，也可以在事务提交时检查\n\n\n进行违约处理\n数据库管理系统若发现用户的操作违背了完整性约束条件，就采取一定的动作，如拒绝（NO ACTION）执行该操作或级连（CASCADE）执行其他操作\n\n\n\n\n\n5.1 实体完整性5.1.1 定义实体完整性关系模型的实体完整性在 CREATE TABLE 中用 PRIMARY KEY 定义。单属性构成的码有两种说明方法，一种是定义为列级约束条件，另一种是定义为表级约束条件；对多个属性构成的码只有一种说明方法，即定义为表级约束条件 \n\n例：将SC表中的Sno，Cno属性组定义为码\n\nCREATE TABLE SC\t\t(Sno CHAR(9) NOT NULL, \t\t Cno CHAR(4) NOT NULL,  \t\t Grade SMALLINT,\t\t PRIMARY KEY (Sno,Cno)\t\t); \n\n5.1.2 实体完整性检查和违约处理插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：\n\n检查主码值是否唯一，如果不唯一则拒绝插入或修改\n检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改\n\n5.2 参照完整性5.2.1 定义参照完整性关系模型的参照完整性在 CREATE TABLE 中用 FOREIGN KEY 短语定义哪些列为外码，用 REFERENCES 短语指明这些外码参照哪些表的主码\n\n例：关系SC中一个元组表示一个学生选修的某门课程的成绩，（Sno，Cno）是主码。Sno、Cno分别参照引用Student表的主码和Course表的主码。定义SC中的参照完整性\n\nCREATE TABLE SC\t\t(Sno CHAR(9) NOT NULL, \t\t Cno CHAR(4) NOT NULL,  \t\t Grade SMALLINT,\t\t PRIMARY KEY (Sno, Cno),  \t\t FOREIGN KEY (Sno) REFERENCES Student(Sno),  \t\t FOREIGN KEY (Cno) REFERENCES Course(Cno)    \t\t);\n\n5.2.2 参照完整性检查和违约处理可能破坏参照完整性的情况及违约处理\n\n\n\n例：显式说明参照完整性的违约处理示例\n\nCREATE TABLE SC(Sno CHAR(9) NOT NULL，Cno CHAR(4) NOT NULL，Grade SMALLINT,PRIMARY KEY(Sno,Cno)， \t\t\tFOREIGN KEY (Sno) REFERENCES Student(Sno) /*在表级定义参照完整性*/\t\t\tON DELETE CASCADE       /*当删除Student表中的元组时，级联删除SC表中相应的元组*/\t\t\tON UPDATE CASCADE,      /*当更新Student表中的sno时，级联更新SC表中相应的元组*/FOREIGN KEY (Cno) REFERENCES Course(Cno)\t/*在表级定义参照完整性*/                    \t\t\tON DELETE NO ACTION /*当删除Course表中的元组造成了与SC表不一致时，拒绝删除*/\t\t\tON UPDATE CASCADE   /*当更新Course表中的cno时，级联更新SC表中相应的元组*/);\n\n5.3 用户定义的完整性5.3.1 属性上的约束条件1. 属性上约束条件的定义在 CREATE TABLE 中定义属性的同时，可以根据应用要求定义属性上的约束条件，即属性值限制，包括\n\n列值非空（NOT NULL）\n列值唯一（UNIQUE）\n检查列值是否满足一个条件表达式（CHECK 短语）\n\n\n例：Student表的Ssex只允许取“男”或“女”\n\nCREATE TABLE Student\t\t(Sno CHAR(9) PRIMARY KEY,\t\t Sname CHAR(8) NOT NULL,                     \t\t Ssex CHAR(2) CHECK (Ssex IN ('男','女'))，           \t\t Sage SMALLINT,\t\t Sdept CHAR(20));\n\n2. 属性上约束条件的检查和违规处理当往表中插入元组或修改属性的值时，关系数据库管理系统将检查属性上的约束条件是否被满足，如果不满足则操作被拒绝执行\n5.3.2 元组上的约束条件1. 元组上约束条件的定义元组级的限制可以设置不同属性之间的取值的相互约束条件\n\n例：当学生的性别是男时，其名字不能以Ms.打头\n\nCREATE TABLE Student\t\t(Sno CHAR(9), \t\t Sname CHAR(8) NOT NULL，\t\t Ssex CHAR(2),\t\t Sage SMALLINT,\t\t Sdept CHAR(20),\t\t PRIMARY KEY (Sno),\t\t CHECK (Ssex = '女' OR Sname NOT LIKE 'Ms.%'));\n\n2. 元组上约束条件的检查和违约处理当往表中插入元组或修改属性的值时，关系数据库管理系统将检查元组上的约束条件是否被满足，如果不满足则操作被拒绝执行\n5.4 完整性约束命名子句1. 完整性约束命名子句CONSTRAINT &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;\n\n&lt;完整性约束条件&gt;包括 NOT NULL、UNIQUE、PRIMARY KEY 短语、FOREIGN KEY 短语、CHECK 短语等\n2. 修改表中的完整性限制使用 ALTER TABLE 语句修改表中的完整性限制\n\n例：修改表Student中的约束条件，要求学号改为在900000~999999之间，年龄由小于30改为小于40\n\n/*可以先删除原来的约束条件，再增加新的约束条件*/ALTER TABLE Student\t\tDROP CONSTRAINT C1;ALTER TABLE Student\t\tADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999),ALTER TABLE Student\t\tDROP CONSTRAINT C3;ALTER TABLE Student\t\tADD CONSTRAINT C3 CHECK(Sage &lt; 40);\n\n5.5 断言\nSQL 中，可以使用 CREATE ASSERTION 语句，通过声明性断言来指定更具一般性的约束\n\n可以定义涉及多个表的或聚集操作的比较复杂的完整性约束\n\n断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行\n\n\n1. 创建断言的语句格式CREATE ASSERTION &lt;断言名&gt; &lt;CHECK 子句&gt;\n\n每个断言都被赋予一个名字，&lt;CHECK 子句&gt;中的约束条件与 WHERE 子句的条件表达式类似\n\n例：限制数据库课程最多60名学生选修\n\nCREATE ASSERTION ASSE_SC_DB_NUM\t\tCHECK (60 &gt;= (SELECT COUNT(*)\t\t\t\tFROM Course,SC\t\t\t\tWHERE SC.Cno = Course.Cno AND Course.Cname = '数据库')\t\t);\n\n2. 删除断言的语句格式DROP ASSERTION &lt;断言名&gt;;\n\n5.6 触发器\n触发器是用户定义在关系表上的一类由事件驱动的特殊过程\n\n触发器保存在数据库服务器中\n任何用户对表的增、删、改操作均由服务器自动激活相应的触发器\n触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力\n\n\n不同的关系数据库管理系统触发器语法各不相同\n\n\n5.6.1 定义触发器CREATE TRIGGER &lt;触发器名&gt;  {BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt;REFERENCING NEW | OLD ROW AS&lt;变量&gt;FOR EACH  {ROW | STATEMENT}[WHEN &lt;触发条件&gt;]&lt;触发动作体&gt;\n\n\n触发器又叫做事件—条件—动作规则\n\n当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段 SQL 存储过程\n\n\n表的拥有者才可以在表上创建触发器\n\n触发器名\n\n触发器名可以包含模式名，也可以不包含模式名\n\n同一模式下，触发器名必须是唯一的\n\n触发器名和表名必须在同一模式下\n\n\n\n表名\n\n触发器只能定义在基本表上，不能定义在视图上\n当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器\n\n\n触发事件\n\n触发事件可以是INSERT、DELETE或UPDATE，也可以是这几个事件的组合\n\n\n还可以UPDATE OF&lt;触发列，...&gt;，即进一步指明修改哪些列时激活触发器\n\nAFTER/BEFORE 是触发的时机\nAFTER 表示在触发事件的操作执行之后激活触发器\nBEFORE 表示在触发事件的操作执行之前激活触发器\n\n\n\n\n触发器类型\n\n行级触发器（FOR EACH ROW）\n语句级触发器（FOR EACH STATEMENT）\n\n\n触发条件\n\n触发器被激活时，只有当触发条件为真时触发动作体才执行;否则触发动作体不执行。\n如果省略 WHEN 触发条件，则触发动作体在触发器激活后立即执行\n\n\n触发动作体\n\n触发动作体可以是一个匿名 PL/SQL 过程块\n\n也可以是对已创建存储过程的调用\n\n\n如果是行级触发器，用户都可以在过程体中使用 NEW 和 OLD 引用事件之后的新值和事件之前的旧值\n\n如果是语句级触发器，则不能在触发动作体中使用 NEW 或 OLD 进行引用\n\n\n如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化\n\n\n\n例：当对表SC的Grade属性进行修改时，若分数增加了10%则将此次操作记录到下面表中：SC_U（Sno,Cno,Oldgrade,Newgrade）其中Oldgrade是修改前的分数，Newgrade是修改后的分数\n\nCREATE TRIGGER  SC_T\t\t     /*SC_T是触发器的名字*/AFTER UPDATE OF Grade ON SC  /*UPDATE OF Grade ON SC是触发事件*/\t\t\t\t\t\t\t\t\t\t\t\t\t\t /*AFTER是触发时机，表示当对SC的Grade属性修改完后再触发下面的规则*/REFERENCING\t\tOLD row  AS  OldTuple,\t\tNEW row AS  NewTupleFOR EACH ROW \t\t\t\t\t\t\t\t /*行级触发器，即每执行一次Grade的更新，下面的规则就执行一次*/WHEN (NewTuple.Grade &gt;= 1.1*OldTuple.Grade)      /*触发条件，只有该条件为真时才执行*/\t\tINSERT INTO SC_U(Sno,Cno,OldGrade,NewGrade)  /*下面的INSERT操作*/\t\tVALUES(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade)\n\n5.6.2 激活触发器\n触发器的执行，是由触发事件激活的，并由数据库服务器自动执行\n一个数据表上可能定义了多个触发器，遵循如下的执行顺序:\n执行该表上的 BEFORE 触发器\n激活触发器的 SQL 语句\n执行该表上的 AFTER 触发器\n\n\n\n5.6.3 删除触发器DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;\n\n","categories":["数据库"]},{"title":"第二章 物理层","url":"/2022/06/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/","content":"第二章 物理层2.1 物理层的基本概念\n物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体\n\n用于物理层的协议也常称为物理层规程（procedure）\n\n可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即:\n\n机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。平时常见的各种规格的接插件都有严格的标准化的规定\n\n电气特性：指明在接口电缆的各条线上出现的电压的范围\n\n功能特性：指明某条线上出现的某一电平的电压的意义\n\n过程特性：指明对于不同功能的各种可能事件的出现顺序\n\n\n\n\n2.2 数据通信的基础知识2.2.1 数据通信系统的模型一个数据通信系统可划分为三大部分，即源系统（或发送端、发送方）、传输系统（或传输网络）和目的系统（或接收端、接收方）\n\n源系统一般包括以下两个部分：\n\n源点（source）：源点设备产生要传输的数据，又称为源站或信源\n发送器：通常源点生成的数字比特流要通过发送器编码后才能够在传输系统中进行传输。典型的发送器就是调制器。现在很多计算机使用内置的调制解调器（包含调制器和解调器）\n\n\n目的系统一般也包括以下两个部分：\n\n接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器就是解调器，它把来自传输线路上的模拟信号进行解调，提取出 在发送端置入的消息，还原出发送端产生的数字比特流\n终点（destination）：终点设备从接收器获取传送来的数字比特流，然后把信息输出，又称为目的站或信宿\n\n\n在源系统和目的系统之间的传输系统可以是简单的传输线，也可以是连接在源系统和目的系统之间的复杂网络系统\n\n\n\n\n2.2.2 有关信道的几个基本概念\n信道一般用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道\n\n从通信的双方信息交互的方式来看，可以有以下三种基本方式：\n\n单向通信，又称为单工通信，即只能有一个方向的通信而没有反方向的交互\n\n双向交替通信，又称为半双工通信，即通信的双方都可以发送信息，但不能双方同时发送（接收）\n\n双向同时通信，又称为全双工通信，即通信的双方可以同时发送和接收信息\n\n\n\n来自信源的信号常称为基带信号（即基本频带信号）\n\n由于基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量，所以必须对基带信号进行调制（modulation）\n\n基带调制：仅仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。由于这种基带调制是把数字信号转换为另一种形式的数字信号，因此大家更愿意把这种过程称为编码（coding）\n带通调制：使用载波（carrier）进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输\n\n\n\n（1）常用编码方式\n\n\n\n不归零制：正电平代表 1，负电平代表 0\n归零制：正脉冲代表 1，负脉冲代表 0\n曼彻斯特编码：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。也可反过来定义。\n差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。\n\n（2）基本的带通调制方法\n\n\n为了达到更高的信息传输速率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法。例如，正交振幅调制 QAM （Quadrature Amplitude Modulation）\n2.2.3 信道的极限容量\n\n从概念上讲，限制码元在信道上的传输速率的因素有：\n\n信道能够通过的频率范围\n\n信噪比\n\n\n1.奈氏准则\n在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的\n\n用表示信号带宽（单位为Hz）， 为波特，即码元/秒，则有：\n\n\n理想低通信道的最高码元传输速率码元秒理想带通信道的最高码元传输速率码元秒\n\n码元传输速率又称为波特率、调制频率、波形频率或符号频率。它与比特率有一定关系：\n\n当1个码元只携带1比特的信息量时，则波特率（码元/秒）与比特率（比特/秒）在数值上是相等的\n当1个码元携带比特的信息量时，则波特率转换成比特率时，数值要乘以\n\n\n要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量。这需要采用多元制\n\n实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的上限数值\n\n\n2.香农公式\n香农公式描述的是带宽受限且有高斯白噪声干扰的信道的极限信息传输速率\n\n用​表示信道带宽（单位Hz），​表示信道内所传信号的平均功率，​表示信道内的高斯噪声功率，​​表示信噪比，使用分贝（dB）作为度量单位，且有信噪比则信道的极限信息传输速率​表示为（单位b/s）\n\n\n2.3 物理层下面的传输媒体\n传输媒体是数据传输系统中在发送器和接收器之间的物理通路，也称为传输介质或传输媒介\n\n传输媒体可分为两大类：导引型传输媒体和非导引型传输媒体\n\n在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播，\n\n非导引型传输媒体就是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输\n\n\n\n\n\n2.3.1 导引型传输媒体1.双绞线\n把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合起来就构成了双绞线\n绞合可减少相邻导线的电磁干扰，也可抵御部分来自外界的电磁波干扰\n为了提高双绞线抗电磁干扰的能力，可以在双绞线的外面再加上一层用金属丝编织成的屏蔽层。这就是屏蔽双绞线，简称为 STP\n\n\n\n2.同轴电缆同轴电缆由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及保护塑料外层所组成\n由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据\n\n\n3.光纤\n光纤是光纤通信的传输媒体。在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲的作用下能产生出光脉冲。在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲\n\n光纤通常由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通信圆柱体\n\n\n\n\n\n可以存在多条不同角度入射的光线在一条光纤中传输，这种光纤就称为多模光纤。光脉冲在多模光纤中传输时会逐渐展宽，造成失真。因此多模光纤只适合于近距离传输\n\n若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射，这样的光纤称为单模光纤\n\n\n\n\n\n由于光纤非常细，因此必须将光纤做成很结实的光缆\n\n\n\n\n光纤的优点\n传输损耗小，中继距离长，对远距离传输特别经济\n抗雷电和电磁干扰性能好，这在有大电流脉冲干扰的环境下尤为重要\n无串音干扰，保密性好，也不易被窃听或截取数据\n体积小，重量轻\n\n\n光纤的缺点\n割接需要专用设备\n光电接口价格较贵\n\n\n\n2.3.2 非导引型传输媒体短波通信主要是靠电离层的反射。但电离层的不稳定所产生的衰落现象和电离层反射所产生的多径效应，使得短波信道的通信质量较差，因此，当必须使用短波无线电台传送数据时，一般都是低速传输\n无线电微波通信主要使用 2～40 GHz 的频率范围。微波在空间主要是直线传播。由于微波会穿透电离层而进入宇宙空间，因此它不像短波那样可以经电离层反射传播到地面上很远的地方。传统的微波通信主要有两种方式，即地面微波接力通信和卫星通信\n卫星通信的最大特点是通信距离远，且通信费用与通信距离无关，但具有较大的传播时延\n2.4 信道复用技术2.4.1 频分复用、时分复用和统计时分复用\n\n最基本的复用就是频分复用 FDM（Frequency Division Multiplexing）和时分复用 TDM（Time Division Multiplexing）\n\n频分复用：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）\n时分复用：将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。时分复用的所有用户是在不同的时间占用同样的频带宽度\n\n\n\n\n统计时分复用STDM （Statistic TDM）是一种改进的时分复用，它能明显地提高信道的利用率。集中器（concentrator）常使用这种统计时分复用\n\n\n\n2.4.2 波分复用波分复用 WDM（Wavelength Division Multiplexing）就是光的频分复用\n由于光信号一段距离后就会衰减，因此对衰减了的光信号必须进行放大才能继续传输。采用掺铒光纤放大器 EDFA  能使两个放大器之间的光缆线路长度达到 120 km\n\n\n2.4.3 码分复用\n码分复用 CDM 是另一种共享信道的方法。实际上，由于该技术主要用于多址接入，人们更常用的名词是码分多址 CDMA\nCDM 的每一个用户可以在同样的时间使用同样的频带进行通信\n由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰\nCDM 最初是用于军事通信的，因为这种系统所发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现\n随着技术的进步，CDMA 设备的价格和体积都大幅下降，因而现在已广泛用于民用的移动通信中\n\n\n\n\n在CDMA中，每一个比特时间再划分为  个短的间隔，称为码片（chip）。通常  的值是64或128\n\n使用 CDMA 的每一个站被指派一个唯一的  码片序列\n\n一个站如果要发送比特1，则发送它自己的  码片序列\n一个站如果要发送比特0，则发送它自己的  码片序列的二进制反码\n\n\n码片序列的挑选原则为：\n\n分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列\n分配给每个站的码片序列必须互相正交，即规格化内积为0\n\n\n令向量  表示站  的码片序列，向量  表示其他任何站的码片序列，则有：\n\n\n\n\n例：站点 A、B、C 通过 CDMA 共享链路，A、B、C 的码片序列分别是、和。若 C 从链路上收到的序列是，则 C 收到 A 发送的数据是 101\n\n","categories":["计算机网络"]},{"title":"第六章 关系数据理论","url":"/2022/06/06/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/","content":"第六章 关系数据理论6.1 关系模式及范式\n关系模式由五部分组成，是一个五元组：\n\n\n关系名  是符号化的元组语义\n 为一组属性\n 为属性组  中的属性所来自的域\n 为属性到域的映射\n 为属性组  上的一组数据依赖\n\n\n由于 、 与模式设计关系不大，因此可以把关系模式看作一个三元组：\n\n当且仅当  上的一个关系  满足  时， 称为关系模式  的一个关系\n作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开的数据项。满足了这个条件的关系模式就属于第一范式（1NF）\n\n\n数据依赖\n\n是一个关系内部属性与属性之间的一种约束关系\n\n通过属性间值的相等与否体现出来的数据间相关联系\n\n\n\n\n是现实世界属性间相互联系的抽象\n\n是数据内在的性质\n\n\n是语义的体现\n\n数据依赖的主要类型\n\n函数依赖（Functional Dependency，简记为 FD）\n多值依赖（Multi-Valued Dependency，简记为 MVD）\n\n\n第一范式的问题有\n\n数据冗余\n更新异常\n插入异常\n删除异常\n\n\n\n6.2 规范化6.2.1 函数依赖设  是一个属性集  上的关系模式， 和  是  的子集。若对于  的任意一个可能的关系 ， 中不可能存在两个元组在  上的属性值相等，而在  上的属性值不等， 则称“ 函数确定 “或“ 函数依赖于 ”，记作 ， 称为这个函数依赖的决定因素\n\n函数依赖不是指关系模式  的某个或某些关系实例满足的约束条件，而是指  的所有关系实例均要满足的约束条件\n\n函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖\n\n数据库设计者可以对现实世界作强制的规定\n\n\n在关系模式  中，对于  的子集  和 ，\n\n，但 ，则称  是非平凡的函数依赖\n\n，但 ，则称  是平凡的函数依赖\n\n对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。因此若不特别声明，我们总是讨论非平凡函数依赖。\n\n\n在  中，如果 ，并且对于  的任何一个真子集 ，都有 , 则称  对  完全函数依赖，记作 \n\n若 ，但  不完全函数依赖于 ，则称  对  部分函数依赖，记作 \n\n在  中，如果 ，，，, 则称  对  传递函数依赖，记为：传递\n\n如果 , 即 ，则  直接依赖于 ，而不是传递函数依赖\n\n6.2.2 码设  为  中的属性或属性组合。若 ，则  称为  的一个候选码\n\n如果  部分函数依赖于 ，即 ，则  称为超码\n\n候选码的超集是超码，候选码的真子集一定不是超码\n\n\n若关系模式  有多个候选码，则选定其中的一个做为主码\n\n主属性与非主属性\n\n包含在任何一个候选码中的属性 ，称为主属性\n不包含在任何码中的属性称为非主属性或非码属性\n\n\n全码：整个属性组是码，称为全码\n\n\n关系模式  中属性或属性组  并非  的码，但  是另一个关系模式的码，则称  是  的外部码也称外码\n主码与外部码一起提供了表示关系间联系的手段\n6.2.3 范式\n范式是符合某一种级别的关系模式的集合\n关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式\n一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化\n\n\n\n6.2.4 2NF若关系模式 ，并且每一个非主属性都完全函数依赖于任何一个候选码，则 \n6.2.5 3NF设关系模式 ，若  中不存在这样的码 、属性组  及非主属性 ，使得 ， 成立， 不成立，则称 \n6.2.6 BCNF\nBCNF 由 Boyce 和 Codd 提出，比 3NF更进了一步。通常认为 BCNF 是修正的第三范式，有时也称为扩充的第三范式\n\n设关系模式 ，若  且 时  必含有码，则 \n\n换言之，在关系模式  中，如果每一个决定属性集都包含候选码，则 \n\nBCNF 的关系模式所具有的性质\n\n所有非主属性都完全函数依赖于每个候选码\n所有主属性都完全函数依赖于每个不包含它的候选码\n没有任何属性完全函数依赖于非码的任何一组属性\n\n\n如果一个关系数据库中的所有关系模式都属于 BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常\n\n\n6.2.7 多值依赖设  是属性集  上的一个关系模式。 是  的子集，并且 。关系模式  中多值依赖  成立，当且仅当对  的任一关系 ，给定的一对  值，有一组  的值，这组值仅仅决定于  值而与  值无关\n\n平凡多值依赖和非平凡的多值依赖\n若 ，而 ，即  为空，则称  为平凡的多值依赖\n否则称  为非平凡的多值依赖\n\n\n\n多值依赖的另一个等价的定义：在  的任一关系  中，如果存在元组  使得 ，那么就必然存在元组 ，（ 可以与  相同），使得 ，而 （即交换  元组的  值所得的两个新元组必在  中，则  多值依赖于 ，记为 。这里  是  的子集，\n多值依赖的性质：\n\n多值依赖具有对称性。即若 ，则 ，其中 \n多值依赖具有传递性。即若 ，， 则 \n函数依赖是多值依赖的特殊情况。即若 ，则 \n若 ，，则 \n若 ，，则 \n若 ，，则 \n\n多值依赖与函数依赖的区别\n\n多值依赖的有效性与属性集的范围有关，函数依赖X→Y的有效性仅决定于X、Y这两个属性集的值\n\n若  在 上成立，则在  上一定成立；反之则不然，即  在 上成立，在  上并不一定成立。\n\n原因：多值依赖的定义中不仅涉及属性组  和 ，而且涉及  中其余属性 \n\n一般地，在  上若有  在  上成立，则称  为  的嵌入型多值依赖\n\n\n\n若函数依赖  在  上成立，则对于任何  均有  成立。多值依赖 若在  上成立，不能断言对于任何  有  成立\n\n\n6.2.8 4NF关系模式 ，如果对于R的每个非平凡多值依赖， 都含有码，则 \n4NF 就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。4NF 所允许的非平凡多值依赖实际上是函数依赖\n","categories":["数据库"]},{"title":"第十章 数据库恢复技术","url":"/2022/06/06/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/","content":"第十章 数据库恢复技术10.1 事务的基本概念1. 事务\n事务（Transaction）是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位\n\n事务和程序是两个概念\n\n在关系数据库中，一个事务可以是一条 SQL 语句，一组 SQL 语句或整个程序\n一个程序通常包含多个事务\n\n\n事务是恢复和并发控制的基本单位\n\n\n定义事务的语句\nBEGIN TRANSACTION;\tSQL 语句\t……COMMIT;BEGIN TRANSACTION;\tSQL 语句\t……ROLLBACK;\n\n\n事务通常是以 BEGIN TRANSACTION 开始，以 COMMIT 或 ROLLBACK 结束\nCOMMIT 表示提交，即提交事务的所有操作，即将事务中所有对数据库的更新写回到磁盘上的物理数据库中，事务正常结束\nROLLBACK 表示事务运行的过程中发生了故障，不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销 ，回滚到开始时的状态\n\n\n\n2. 事务的ACID特性事务具有 4 个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持续性（Durability），保证事务 ACID 特性是事务处理的任务\n\n原子性\n\n事务是数据库的逻辑工作单位\n事务中包括的诸操作要么都做，要么都不做\n\n\n\n\n一致性\n\n事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态\n\n一致性状态\n\n数据库中只包含成功事务提交的结果\n\n\n不一致状态\n\n数据库系统运行中发生故障，有些事务尚未完成就被迫中断\n这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态\n\n\n\n\n隔离性\n\n一个事务的执行不能被其他事务干扰\n一个事务内部的操作及使用的数据对其他并发事务是隔离的\n并发执行的各个事务之间不能互相干扰\n\n\n持续性\n\n一个事务一旦提交，它对数据库中数据的改变就应该是永久性的\n接下来的其他操作或故障不应该对其执行结果有任何影响\n\n\n\n破坏事务 ACID 特性的因素\n\n多个事务并行运行时，不同事务的操作交叉执行\n\n数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性\n\n\n事务在运行过程中被强行停止\n\n数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响\n\n\n\n10.2 数据库恢复概述\n故障是不可避免的\n\n计算机硬件故障\n软件的错误\n操作员的失误\n恶意的破坏\n\n\n故障的影响\n\n运行事务非正常中断，影响数据库中数据的正确性 \n破坏数据库，全部或部分丢失数据\n\n\n数据库的恢复\n\n数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）的功能，这就是数据库的恢复管理系统对故障的对策\n\n\n恢复子系统是数据库管理系统的一个重要组成部分 \n\n恢复技术是衡量系统优劣的重要指标\n\n\n10.3 故障的种类1. 事务内部的故障\n事务内部更多的故障是非预期的，是不能由应用程序处理的。\n\n运算溢出\n并发事务发生死锁而被选中撤销该事务\n违反了某些完整性限制而被终止等\n\n\n事务故障仅指这类非预期的故障\n\n事务故障意味着事务没有达到预期的终点（COMMIT 或者显式的 ROLLBACK），因此数据库可能处于不正确状态\n\n事务故障的恢复：事务撤消（UNDO）\n\n强行回滚（ROLLBACK）该事务\n撤销该事务已经作出的任何对数据库的修改，使得该事务象根本没有启动一样\n\n\n\n2. 系统故障\n系统故障，称为软故障，是指造成系统停止运转的任何事件（特定类型的硬件错误（如 CPU 故障）、操作系统故障、数据库管理系统代码错误、系统断电），使得系统要重新启动 \n\n整个系统的正常运行突然被破坏\n所有正在运行的事务都非正常终止\n不破坏数据库\n内存中数据库缓冲区的信息全部丢失\n\n\n发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态\n\n恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤消（UNDO）所有未完成事务\n\n\n发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失\n\n恢复策略：系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务\n\n\n\n3. 介质故障\n介质故障，称为硬故障，指外存故障\n\n磁盘损坏\n磁头碰撞\n瞬时强磁场干扰\n\n\n介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务\n\n介质故障比前两类故障的可能性小得多，但破坏性大得多\n\n\n4. 计算机病毒\n计算机病毒\n\n一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序\n可以繁殖和传播，造成对计算机系统包括数据库的危害\n\n\n计算机病毒已成为计算机系统的主要威胁，自然也是数据库系统的主要威胁\n\n数据库一旦被破坏仍要用恢复技术把数据库加以恢复\n\n\n10.4 恢复的实现技术\n恢复操作的基本原理：冗余\n\n利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据\n\n\n恢复的实现技术：复杂\n\n一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上\n\n\n恢复机制涉及的关键问题\n\n如何建立冗余数据（数据转储，登记日志文件）\n如何利用这些冗余数据实施数据库恢复\n\n\n\n10.4.1 数据转储\n转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程\n\n备用的数据文本称为后备副本（backup）或后援副本\n\n数据库遭到破坏后可以将后备副本重新装入\n\n重装后备副本只能将数据库恢复到转储时的状态\n\n要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务\n\n\n\n\n转储可分为静态转储和动态转储\n\n静态转储\n\n在系统中无运行事务时进行的转储操作\n\n转储开始时数据库处于一致性状态\n\n转储期间不允许对数据库的任何存取、修改活动\n\n得到的一定是一个数据一致性的副本\n\n优点：实现简单\n\n缺点：降低了数据库的可用性\n\n转储必须等待正运行的用户事务结束 \n\n新的事务必须等转储结束\n\n\n\n\n\n动态转储\n\n转储操作与用户事务并发进行\n\n转储期间允许对数据库进行存取或修改\n\n优点\n\n不用等待正在运行的用户事务结束\n不会影响新事务的运行\n\n\n缺点：转储结束时后援副本上的数据并不能保证正确有效\n\n利用动态转储得到的副本进行故障恢复\n\n需要把动态转储期间各事务对数据库的修改活动登记下来，建立日志文件\n\n后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态\n\n\n\n\n\n\n转储还可以分为海量转储和增量转储\n\n海量转储: 每次转储全部数据库\n\n增量转储: 只转储上次转储后更新过的数据\n\n海量转储与增量转储比较\n\n从恢复角度看，使用海量转储得到的后备副本进行恢复往往更方便\n如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效\n\n\n\n10.4.2 登记日志文件1. 日志文件的格式和内容日志文件是用来记录事务对数据库的更新操作的文件，日志文件主要有两种格式：以记录为单位的日志文件和以数据块为单位的日志文件\n\n对于以记录为单位的日志文件，日志文件中需要登记的记录包括\n\n各个事务的开始标记（BEGIN TRANSACTION）\n各个事务的结束标记（COMMIT 或 ROLLBACK）\n各个事务的所有更新操作\n上述三个内容均作为日志文件的一个日志记录，每个日志记录的主要内容包括\n事务标识（标明是哪个事务） \n操作类型（插入、删除或修改）\n操作对象（记录内部标识）\n更新前数据的旧值（对插入操作而言，此项为空值）\n更新后数据的新值（对删除操作而言, 此项为空值）\n\n\n\n\n对于以数据块为单位的日志文件，每条日志记录的内容包括事务标识和被更新的数据块\n\n\n2. 日志文件的作用\n事务故障恢复和系统故障恢复必须用日志文件\n\n在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库\n\n在静态转储方式中，也可以建立日志文件\n\n当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态\n利用日志文件，把已完成的事务进行重做处理\n对故障发生时尚未完成的事务进行撤销处理\n不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态\n\n\n\n\n\n3. 登记日志文件为保证数据库是可恢复的，登记日志文件时必须遵循两条原则\n\n登记的次序严格按并发事务执行的时间次序\n\n必须先写日志文件，后写数据库\n\n写日志文件操作：把表示这个修改的日志记录写到日志文件中\n写数据库操作：把对数据的修改写到数据库中\n\n\n\n先写日志文件的原因：\n\n写数据库和写日志文件是两个不同的操作\n\n在这两个操作之间可能发生故障\n\n如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了\n\n如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的 UNDO 操作，并不会影响数据库的正确性\n\n\n10.5 恢复策略10.5.1 事务故障的恢复","categories":["数据库"]},{"title":"第四章 数据库安全性","url":"/2022/06/06/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/","content":"第四章 数据库安全性4.1 数据库安全性概述4.1.1 数据库的不安全因素\n非授权用户对数据库的恶意存取和破坏\n一些黑客和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据\n数据库管理系统提供的安全措施主要包括用户身份鉴别、存取控制和视图等技术\n\n\n数据库中重要或敏感的数据被泄露\n黑客和敌对分子千方百计盗窃数据库中的重要数据，一些机密信息被暴露\n数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等\n审计日志分析\n\n\n安全环境的脆弱性\n数据库的安全性与计算机系统的安全性紧密联系\n建立一套可信计算机系统的概念和标准\n\n\n\n4.1.2 安全标准简介\nTCSEC/TDI 安全级别划分\n按系统可靠或可信程度逐渐增高\n各安全级别之间具有一种偏序向下兼容的关系\n\n\n\n\n\n\n安全级别\n定义\n\n\n\nA1\n验证设计（Verified Design）\n\n\nB3\n安全域（Security Domains）\n\n\nB2\n结构化保护（Structural Protection）\n\n\nB1\n标记安全保护（Labeled Security Protection）\n\n\nC2\n受控的存取保护（Controlled Access Protection）\n\n\nC1\n自主安全保护（Discretionary Security Protection）\n\n\nD\n最小保护（Minimal Protection）\n\n\n\nCC 评估保证级（EAL）划分\n\n\n\n\n评估保证级\n定义\nTCSEC安全级别（近似相当）\n\n\n\nEAL1\n功能测试（functionally tested）\n\n\n\nEAL2\n结构测试（structurally tested）\nC1\n\n\nEAL3\n系统地测试和检查（methodically tested and checked）\nC2\n\n\nEAL4\n系统地设计、测试和复查（methodically designed，tested，and reviewed）\nB1\n\n\nEAL5\n半形式化设计和测试（semiformally designed and tested）\nB2\n\n\nEAL6\n半形式化验证的设计和测试（semiformally verified design and tested）\nB3\n\n\nEAL7\n形式化验证的设计和测试（formally verified design and tested）\nA1\n\n\n4.2 数据库安全性控制\n4.2.1 用户身份鉴别\n静态口令鉴别\n动态口令鉴别\n生物特征鉴别\n智能卡鉴别\n\n4.2.2 存取控制\n定义用户权限，并将用户权限登记到数据字典中\n用户对某一数据对象的操作权力称为权限\nDBMS 提供适当的语言来定义用户权限，存放在数据字典中，称做安全规则或授权规则\n\n\n合法权限检查 \n用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统\nC2 级的数据库管理系统支持自主存取控制（Discretionary Access Control，DAC），B1 级的数据库管理系统支持强制存取控制（Mandatory Access Control，MAC）\n在自主存取控制方法中，用户对不同的数据对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户\n在强制存取控制方法中，每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取\n\n\n\n4.2.3 自主存取控制方法\n通过 SQL 的 GRANT 语句和 REVOKE 语句实现\n用户权限由数据库对象和操作类型两个要素组成\n定义一个用户的存取权限就是要定义用户可以在哪些数据库对象上进行哪些类型的操作\n定义存取权限称为授权\n\n4.2.4 授权：授予与收回1. GRANTGRANT 语句的一般格式为\nGRANT &lt;权限&gt;[,&lt;权限&gt;]... ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]…TO &lt;用户&gt;[,&lt;用户&gt;]...[WITH GRANT OPTION];\n\n如果指定 WITH GRANT OPTION 子句，则获得某种权限的用户还可以把这种权限再授予其他的用户\n\n例：把查询Student表和修改学生学号的权限授给用户U4\n\nGRANT UPDATE(Sno), SELECT ON TABLE Student TO U4;\n\n2. REVOKEREVOKE 语句的一般格式为\nREVOKE &lt;权限&gt;[,&lt;权限&gt;]…ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…FROM &lt;用户&gt;[,&lt;用户&gt;]…[CASCADE | RESTRICT];\n\n4.2.5 数据库角色数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合\n1. 角色的创建CREATE ROLE &lt;角色名&gt;\n\n2. 给角色授权GRANT &lt;权限&gt;[,&lt;权限&gt;]… ON &lt;对象类型&gt;对象名  TO &lt;角色&gt;[,&lt;角色&gt;]…\n\n3. 将一个角色授予其他的角色或用户GRANT &lt;角色1&gt;[,&lt;角色2&gt;]…TO &lt;角色3&gt;[,&lt;用户1&gt;]… [WITH ADMIN OPTION]\n\n4. 角色权限的收回REVOKE &lt;权限&gt;[,&lt;权限&gt;]…ON &lt;对象类型&gt; &lt;对象名&gt;FROM &lt;角色&gt;[,&lt;角色&gt;]…\n\n4.2.6 强制存取控制方法\n在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类\n\n主体是系统中的活动实体：数据库管理系统所管理的实际用户，代表用户的各进程\n\n客体是系统中的被动实体，受主体操纵：文件、基本表、索引、视图\n\n对于主体和客体，DBMS 为它们每个实例（值）指派一个敏感度标记，敏感度标记分成若干级别，例如绝密（TS）、机密（S）、可信（C）和公开（P）等\n\n主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级\n\n强制存取控制规则\n\n仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体\n仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体\n\n\n强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据\n\n实现强制存取控制时要首先实现自主存取控制，因为较高安全性级别提供的安全保护要包含较低级别的所有保护\n\n\n4.3 视图机制\n把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护 \n间接地实现支持存取谓词的用户权限定义\n\n4.4 审计\n审计功能把用户对数据库的所有操作自动记录下来放入审计日志中\n审计员利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等\nC2 以上安全级别的 DBMS 必须具有审计功能\n审计功能的可选性\n审计很费时间和空间\nDBA 可以根据应用对安全性的要求，灵活地打开或关闭审计功能\n审计功能主要用于安全性要求较高的部门\n\n\n\n1. 审计事件审计事件一般有多个类别，例如\n\n服务器事件：审计数据库服务器发生的事件，包括数据库服务器的启动、停止、数据库服务器配置文件的重新加载\n\n系统权限：对系统拥有的结构或模式对象进行操作的审计，要求该操作的权限是通过系统权限获得的\n\n语句事件：对 SQL 语句，如 DDL、DML、DQL 及 DCL 语句的审计\n\n模式对象事件：对特定模式对象上进行的 SELECT 或 DML 操作的审计\n\n\n2. 审计功能审计功能主要包括以下几个方面的内容：\n\n基本功能，提供多种审计查阅方式\n多套审计规则，一般在初始化设定\n提供审计分析和报表功能\n审计日志管理功能\n防止审计员误删审计记录，审计日志必须先转储后删除\n对转储的审计记录文件提供完整性和保密性保护\n只允许审计员查阅和转储审计记录，不允许任何用户新增和修改审计记录等\n\n\n提供查询审计设置及审计记录信息的专门视图\n\n3. AUDIT 语句和 NOAUDIT 语句AUDIT 语句用来设置审计功能，NOAUDIT 语句取消审计功能\n\n例：对修改 SC 表结构或修改 SC 表数据的操作进行审计\n\nAUDIT ALTER,UPDATE  ON  SC;\n\n4.5 数据加密\n数据加密是防止数据库中数据在存储和传输中失密的有效手段\n加密的基本思想是根据一定的算法将原始数据——明文变换为不可直接识别的格式­——密文\n加密方法\n存储加密\n透明存储加密\n内核级加密保护方式，对用户完全透明\n将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密\n数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可\n内核级加密方法：性能较好，安全完备性较高\n\n\n非透明存储加密\n通过多个加密函数实现\n\n\n\n\n传输加密\n链路加密\n在链路层进行加密\n传输信息由报头和报文两部分组成\n报文和报头均加密\n\n\n端到端加密\n在发送端加密，接收端解密\n只加密报文不加密报头\n所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息\n\n\n\n\n\n\n\n4.6 其他安全性保护\n推理控制：避免用户利用能够访问的数据推知更高密级的数据\n隐蔽信道：间接数据传递\n数据隐私保护：描述个人控制其不愿他人知道或他人不便知道的个人数据的能力\n\n","categories":["数据库"]},{"title":"质数筛","url":"/2022/06/06/%E8%B4%A8%E6%95%B0%E7%AD%9B/","content":"质数筛埃氏筛素数筛法，是一种快速“筛”出​​之间所有素数的方法。\n朴素的筛法叫埃氏筛（the Sieve of Eratosthenes，埃拉托色尼筛），它的过程是这样的：\n先将​​​​的数按顺序写出来：从前往后看，找到第一个未被划掉的数，是2，说明它是质数（这里是质数用标为蓝色表示）。然后把2的倍数（不包括2）划掉（这里划掉用标红表示）：\n下一个未被划掉的数是3，它是质数，然后把3的倍数划掉：接下来应该是5，但是由于5已经超过​了，所以遍历结束，剩下未被划掉的都是素数：这个过程用代码表示为：\nbool isPrime[MAXN+5] = {0};//标记数组 用来表示数字是否是质数：true表示是质数，false表示不是质数void aiPrime(int n){//埃氏筛处理n以内的质数\tmemset(isPrime,true,sizeof(isPrime));//所有数字，默认标记为质数 \tisPrime[1] = false;//修改1的状态，1不是质数\tfor(int i = 2; i * i &lt;= n; i++){//从2开始，枚举范围n以内的每个数字 \t\tif(isPrime[i]){//如果i是质数，则将n以内所有i的倍数（2倍及以上），标记为非质数 \t\t\tfor(int j = 2; j * i &lt;= n; j++){\t\t\t\tisPrime[j*i]=false;// 标记i的倍数为非质数 \t\t\t}\t\t}\t}}\n\n埃式筛算法的复杂度是 ​​，但是我们发现，在筛的过程中我们会重复筛到同一个数，例如12同时被2和3筛到，30同时被2、3和5筛到。\n所以我们引入欧拉筛，也叫线性筛，可以在​时间内完成对的筛选。它的核心思想是：让每一个合数被其最小质因数筛到。\n欧拉筛这次除了要把​列出来，还维护一个质数表：仍然是从头到尾遍历，第一个数是2，未被划掉，把它放进质数表：然后用2去乘质数表里的每个数，并且划掉它们：下一个是3，加入质数表，并用3去乘质数表里每一个数（此时是2和3），划掉6和9：下一个是4（注意：这里划掉的数也要遍历，只是不加入质数表），用4去乘质数表里每个数，划掉8，但不划掉12，因为​​，应该由它的最小质因数2筛掉，而不是3。实际上，对于数​，当遍历到质数表中的 ​ ，且发现 ​​（能整除）时，就应当停止遍历质数表。\n\n因为如果​​​​​​，即i%p == 0​，则说明假设在质数表中​​​​的下一位是​​​​​，设所以由有，因为，设所以​​​​​，则所以如果用​​式筛掉所以如果用3式筛去​​的话，当​​时，​​又会被​​​式筛去一次，为了确保合数只被最小质因子筛掉，最小质因子要乘以最大的倍数，即要乘以最大的​​, 所以不能提前筛。\n\n下一个数是5，加入质数表，划掉10和15：下一个数是6，划掉12，6能被2整除，跳过。\n……\n按这样的步骤进行下去，可以筛掉所有的合数，并得到一张质数表：我们可以保证每个合数都被筛过。设任意合数 ，其中是的最小质因数，又设，是的最小质因数。在处理时时，要遍历质数表，直到遇到时才结束，所以任意小于等于的质数与的乘积，都会在此时被筛掉。\n而由于一定有（因为的最小质因数是，而不是），所以在处理到时，一定会被筛到。\n代码如下：\nbool isPrime[MAXN+5];  int prime[MAXM+5];  //判断是否是一个素数  Mark 标记数组 index 素数个数  void olaPrime(){    int index = 0;    memset(isPrime,true,sizeof(isPrime));      for(int i = 2; i &lt; MAXSIZE; i++){           //如果i未被标记为非素数（即false）则得到一个素数          if(isPrime[i] == true){              prime[index++] = i;          }          //标记目前得到的素数的i倍为非素数          for(int j = 0; j &lt; index &amp;&amp; prime[j] * i &lt; MAXN; j++){               isPrime[i * prime[j]] = false;              if(i % prime[j] == 0){                  break;              }          }      }    }  //如果空间不够用质数表也可以不用开始就开到最大bool isnp[MAXN];//is not primevector&lt;int&gt; primes; // 质数表void olaPrime(int n){    for (int i = 2; i &lt;= n; i++){        if (!isnp[i]){            primes.push_back(i);        }        for (int p : primes){            if (p * i &gt; n){                break;            }            isnp[p * i] = 1;            if (i % p == 0){                break;            }        }    }}\n\n欧式筛的时间复杂度为。\n","categories":["数据结构与算法"]},{"title":"高精度运算","url":"/2022/06/06/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/","content":"基础数据处理函数void moveFrontZero(string &amp;a){//去除一个字符串的前导0\ta.erase(0,a.find_first_not_of('0'));\tif(a.empty()){        a = \"0\";    }}void align(string &amp;a, string &amp;b){//让两个字符串变成相同的长度，长度小的补0\tint a_size = a.size();\tint b_size = b.size();\tif(a_size &lt; b_size){\t\tfor(int i = 1; i &lt;= b_size - a_size; i++){\t\t\ta = \"0\" + a;\t\t}\t}else{\t\tfor(int i = 1; i &lt;= a_size-b_size; i++){\t\t\tb = \"0\" + b;\t\t}\t}}\n\n高精度加法string add(string addent, string adder){\tmoveFrontZero(addent);\tmoveFrontZero(adder);\tstring answer = \"\";\talign(addent,adder);\tint temp = 0, carry = 0;//temp表示当前对位相加结果，carry表示进位\tfor(int i = addent.size() - 1; i &gt;= 0; i--){\t\ttemp = addent[i] - '0' + adder[i] - '0' + carry;\t\tcarry = temp/10;\t\ttemp %= 10;\t\tanswer = (char)(temp + '0') + answer;\t}\tif(carry){//处理最高位相加可能产生的进位        answer = (char)(carry + '0') + answer;    }\tmoveFrontZero(answer);\treturn answer;}\n\n高精度减法string sub(string subtrahend, string subtractor){//顺序是被减数和减数\tmoveFrontZero(subtrahend);\tmoveFrontZero(subtractor);\talign(subtrahend,subtractor);\tbool is_minus = false;\tif(subtrahend &lt; subtractor){\t\tis_minus = true;\t\tsubtrahend.swap(subtractor);//确保大数减小数\t}\tstring answer = \"\";\tint temp = 0,carry = 0;//temp表示当前对位相减结果，carry表示借位\tfor(int i = subtrahend.size() - 1; i &gt;= 0; i--){\t\tif(subtrahend[i] - carry &lt; subtractor[i]){//被减数不够减的情况\t\t\ttemp = subtrahend[i] - carry + 10 - subtractor[i];\t\t\tcarry = 1;\t\t\tanswer = (char)(temp +'0') + answer;\t\t}else{//被减数够减\t\t\ttemp = subtrahend[i] - carry - subtractor[i];\t\t\tcarry = 0;\t\t\tanswer = (char)(temp +'0') + answer;\t\t}\t}\tmoveFrontZero(answer);\tif(is_minus)answer = \"-\"+answer;\treturn answer;}\n\n高精度乘法（需要依赖高精度加法）乘法的主要思想是把乘法转化为加法进行运算。以下面具体的例子说明：\n\n\n等式（1）​说明，多位数乘一位数，可以直接使用加法完成。\n等式（2）说明，多位数乘形如的数，可以转换成多位数乘一位数来处理。\n等式（3）说明，多位数乘多位数，可以转换为若干个多位数乘形如的数与多位数乘一位数之和。\n因此，多位数乘多位数最终可以全部用加法来实现。\nstring mul(string multiplicand, string multiplier){    //multiplicand表示被乘数，即上面例子中的12345，multiplier是乘数，即上面例子的24    string answer = \"0\";//answer必须初始化为“0”    for (int i = (int) multiplier.length() - 1; i &gt;= 0 ; i--) {        for (char c = '1'; c &lt;= multiplier[i]; c++) {            answer = add(answer, multiplicand);        }        multiplicand = multiplicand + \"0\";    }    moveFrontZero(answer);\treturn answer;}\n\n高精度除法（需要依赖高精度减法）//试商法string div(string dividend, string divisor){\tmoveFrontZero(dividend);\tmoveFrontZero(divisor);\tstring answer = \"\";\tstring reminder = \"\";\treminder.append(dividend,0,divisor.size()-1);//截取被除数从首位到除数位数的前一位\tfor(int i = divisor.size() - 1; i &lt; dividend.size(); i++){\t\treminder = reminder + dividend[i];\t\tmoveFrontZero(reminder);\t\tfor(char j = '9';j &gt;= '0'; j--){\t\t\tstring temp = \"\";\t\t\ttemp = temp + j;\t\t\ttemp = mul(divisor,temp);\t\t\talign(temp,reminder);\t\t\tif(temp &lt;= reminder){\t\t\t\tanswer = answer + j;\t\t\t\treminder = sub(reminder,temp);\t\t\t\tbreak;\t\t\t}\t\t}\t}\t    moveFrontZero(answer);\t//cout  &lt;&lt;  \"reminder=\"  &lt;&lt;  reminder  &lt;&lt;  endl;\treturn answer;}\n\n高精度阶乘（利用高精度减法和乘法实现）string factorial(string a){//高精度阶乘（最大可运行出10000左右的阶乘）    moveFrontZero(a);\tif(a == \"1\"){\t\treturn a;    }\telse \t\treturn mul(a,factorial(sub(a,\"1\")));//即利用递归转化为a*(a-1)!}\n\n","categories":["数据结构与算法"]},{"title":"第一章 计算机系统漫游","url":"/2022/06/06/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/","content":"第一章 计算机系统漫游以hello程序的生命周期为例来开始对系统的学习\n#include &lt;stdio.h&gt;int main(){  printf(\"hello, world\\n\");  return 0;}\n\n\n1.1 信息就是位+上下文\nhello.c程序是以字节序列的方式存储在文件中的，大部分计算机系统都用ASCII标准\n\n系统中的所有信息都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。\n1.2 程序被其他程序翻译成不同的格式\nGCC读取hello.c文件并将其翻译为可执行目标文件hello共分为4个阶段，执行这4个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统\n\n\n预处理阶段 ：预处理器（cpp）根据以字符#开头的命令，修改原始的C程序，得到另一个.i文件。\n\n编译阶段 ：编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。\n\n汇编阶段 ：汇编器（as）将hello.s文件翻译成机器语言指令，把这些指令打包成可重定位目标程序的格式，并将结果保存在hello.o中\n\n链接阶段 ： hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器（ld）就负责处理这种合并。结果就得到hello文件，它是一个可执行目标文件（可执行文件），可以被加载到内存中，由系统执行。\n\n\n1.3 了解编译系统如何工作是大有益处的\n\n优化程序性能\n\n理解链接时出现的错误\n\n避免安全漏洞\n\n\n1.4 处理器读并解释储存在内存中的指令\n1.4.1 系统的硬件组成\n\n总线 ：贯串整个系统的一组电子管道。它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字 ，字中的字节数（字长 ）是一个基本的系统参数，大多数为64位。\n\nI/O设备 ：每个I/O设备都通过一个控制器 或适配器 与I/O总线相连。控制器和适配器的区别主要在于它们的封装方式，控制器是I/O本身或者系统的主印制电路板（主板 ）上的芯片组，适配器是一块插在主板插槽上的卡。\n\n主存 ：主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器 （dynamic random access memory，DRAM）芯片组成的；从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）。\n\n处理器 ：中央处理单元 （CPU），简称处理器，是解释或执行存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器 （PC）。在任何时候，PC都指向主存中的某条机器语言指令，即含有该条指令的地址。\n\n\n从系统通电开始，直到系统断电，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。\n1.4.2 运行hello程序初始时，在Linux系统中，shell程序执行它的指定，等待输入命令。当在键盘上输入字符串”./hello”后，shell程序将字符逐一读入寄存器，再把它存放到内存中。\n\n在键盘敲回车键，即结束命令输入后，shell执行一系列将hello目标文件中的代码和数据从磁盘复制到主存。利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从硬盘到达主存，这个步骤如下图所示。\n\n\n一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器指令，将“hello, world\\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上，该步骤如下图所示。\n\n\n1.5 高速缓存至关重要\n针对处理器和主存之间的差异，系统设计者采用更小更快的存储设备，称为高速缓存存储器 （cache memory，简称为cache或高速缓存），作为暂时的集结区域，存放处理器可能会需要的信息。处理能力强的系统可能会有三级高速缓存：L1、L2和L3使系统获得更大的存储器，同时访问速度更快，原因是利用了高速缓存的局部性 原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。\n\n1.6 存储设备形成层次结构\n每个计算机系统中的存储设备都被组织成了一个存储器层次结构 ，在这个结构中，从上至下，设备的访问速度越来越慢，容量越来越大，并且每字节的造价也越来越便宜。\n\n\n存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。\n1.7 操作系统管理硬件\n在hello例子中，shell和hello程序都没有直接访问键盘、显示器、磁盘或主存，它们依靠操作系统 提供的服务。可以把操作系统看作是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。\n\n操作系统有两个基本功能 ：\n1.防止硬件被失控的应用程序滥用；\n2.向应用程序提供简单一致的机制来控制复杂而又通常大而不同的低级硬件设备。\n操作系统通过几个基本的抽象概念（进程 、虚拟内存 和文件 ）来实现这两个功能。\n\n1.7.1 进程进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以运行多个进程，而每个进程都好像在单独地使用硬件。而并发运行 ，则是说一个进程的指令和另一个进程的指令是交错执行的。一个CPU看上去都像是在并发的执行多个进程，这是通过处理器在进程间切换实现的。操作系统实现这种交错执行的机制称为上下文切换 （上下文是指操作系统保持跟踪进程运行所需的所有状态信息）。下图展示了hello程序运行场景的基本理念。\n\n\n示例场景中有两个并发的进程：shell进程和hello进程。最开始，只有shell进程在运行，即等待命令行上的输入。当让它运行hello程序时， shell通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，然后将控制权传给新的hello进程。hello进程终止后，操作系统恢复shell进程的上下文，并将控制权传回给它， shell进程会继续等待下一个命令行输入。\n从一个进程到另一个进程的转换是由操作系统内核 管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用 指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。内核不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合。\n1.7.2 线程1.一个进程实际上可以由多个称为线程 的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。\n2.因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。\n1.7.3 虚拟内存虚拟内存为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间 。下图是Linux进程的虚拟地址空间，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有的进程来说都是一样的；底部区域存放用户进程定义的代码和数据。\n\n\n\n程序代码和数据   对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。\n\n堆   代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。\n\n共享库   大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。\n\n栈   位于用户虚拟地址空间顶部的是用户栈 ，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每当调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。\n\n内核虚拟内存   地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。\n\n\n虚拟内存运行的基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。\n1.7.4 文件文件就是字节序列。每个I/O设备都可以看成是文件。系统中所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。\n1.8 系统之间利用网络通信\n\n\n对于hello程序，可以用telnet应用在一个远程主机上运行hello程序。假设用本地主机上的telnet客户端连接远程主机上的telnet服务器，在登陆到远程主机并运行shell后的步骤如下图所示。\n\n1.9 重要主题\n1.9.1 Amdahl定律Amadahl定律的主要思想是，当对系统的某部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。\n设系统执行某应用程序需要时间为，系统某部分所需执行时间与该时间的比例为​，该部分性能提升比例为，所以总的执行时间为，所以加速比为\n可以看到，虽然对系统一个主要部分做出重大改进，但获得的系统加速比却远小于这部分的加速比，这就是Amdahl定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。\n1.9.2 并发和并行并发（concurrency）是指一个同时具有多个活动的系统；并行（parallelism）指的是用并发来使一个系统运行得更快。\n下面按照系统层次结构由高到低顺序强调并行的三个层次：\n1. 线程级并发 \n\n\n如下图，多核处理器是将多个CPU（称为“核”）集成到一个集成电路芯片上。下图中的微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，其中L1高速缓存分为两个部分，一个保存最近取到的指令，另一个放数据。这些核共享更高层次的高速缓存，以及到主存的接口。\n\n\n超线程（有时称为同时多线程）是一项允许一个CPU执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器；而其他的硬件部分只有一份，比如执行浮点算数运算的单元。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另一个线程。\n多处理器的使用从（1）减少在执行多个任务时模拟并发的需要；（2）使应用程序运行的更快 两个方面提高系统性能。\n2. 指令级并行 \n在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行 。\n在流水线 中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。\n如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量 处理器。\n3. 单指令、多数据并行 \n在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据 ，即SIMD并行。\n提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。\n可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如GCC就支持向量数据类型。\n1.9.3 计算机系统中抽象的重要性\n\n指令集架构 提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上；\n文件 是对I/O设备的抽象；\n虚拟内存 是对程序存储器的抽象；\n进程 是对一个正在运行的程序的抽象；\n虚拟机 提供对整个计算机的抽象，包括操作系统、处理器和程序\n1.10 小结\n计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ASCII文本，然后被编译器和链接器翻译成二进制可执行文件。\n处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。\n操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：\n\n文件是对I/O设备的抽象；\n\n虚拟内存是对主存和磁盘的抽象；\n\n进程是处理器、主存和I/O设备的抽象。\n\n\n最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种I/O设备。\n","categories":["CSAPP笔记"]},{"title":"第一章 操作系统概论","url":"/2022/07/26/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/","content":"\n  88bbb2534917ec369b37a23a13f1c770f5f81ca39e1e10a22032924264fec571021d2150ed0aef4a3776b05fce59779d422ca21357e993179269d3ffc7ddcee7f23c0eab607e75dede002c845a8a9cc9530acce9fe57f17c2d19bb9eacd7eb45135940bdb71ba87d0a083224f7174a0b6f6a9343a349196abfb3fda1c03fc9312779dab713a8972f8573601d06fa56630e0de1845e3181bbfc1a3b04c66df6d832b0a1f2b0d1610c647f095a9a21cb5c69ce01d1bec652cdbf2b37ea7697660589cd91b8659c884f7093dfa0f3d370e1e4cca3026a6275e642e8e5e7761fde35717104b5b86c7c1cdda26d90bc6a8537b91758d0114a8bea3c7a7875d9d62697d1c545c5419b389f78bcbd4feef08086cbe1d72bbe4b2570019e730f53dc6e0f155be0195f52d4e89d33804107483e70404775d0b9f8f91244344bbe44ac7d667564fe3b5fe4f5f7261e17caf7f57aa7a9d2bb1e37da2eb5d7d06fa6e8853729d1f5e6137128e3b3d6df00a73c504f085dd0b1b092706f4dedf33f04354b3bdcf5e4117fe40d372a76e296d7bbf37c03e4c958ce9f6235f0d826758fdf988675be611a3b2901e2d7878b9d31042342eeecde5688a1d54bea3d04b87327eebdd8cee89054837635ea031f5602f68cef77987a7db03af5db41765ad78d167f0526580cfb860848f89ef52828e4884d7abad4d41b466991daa7b502ba3fbdcc8ec086dd0f553991b470a5ec7a051510eff0ae0f97a43c1f0958587dd1af4fcb18913e9a773510d9650f68518ee70b84206a1d0ac904cb0c33222afe76e61a757d8f2f2148db46b4c02cd0488cbfeb5825d13f9f1c3eb134c820344842eca4188563b4a788c42eafaf47852dddfaff999387d3f2978f80d047575ca66ce4cf0888ce50e04506dc990b54dfd69ec08e334217734577bf66a8f48de327185199f413be8298a0adeb83c650e42414af9a9330288fd0c3d48cf1d8378f240b290f3152e3ebe6c742afd663eb6b7573c0a515c1738172a075fc79fb8f011ce0be6d49367a37eed64a6f5d9b5bbcdd9eee4f3048024bbd26285a175f631aa5fa1401db3bedf8863957f1c1e447b3be81597d884ac7f84f050ea81d7027a53ef2c78f693f53245992c513d474805ea5bc3c9cf50ca03174d9a4c7fcb6c690725fad69250ba8b5708b6d5cc6d7055d1cfdce31ddee9ebe819aae918d941988efb8ef690e3a0a83169bc8e61f4ca63316b554ab7996d838424887179c8351b10c958fcceb5fbfc23112bb54b9a864c62993928c65c9e591231b033829f7a2fa93702a464b5824bc6e4c02dd6b6bbf67138d243cc6ea1cca07f0c4cb86fa5ae3fac8af29257b74d2b2a6e7d3ee8ff7e753cb6b38be4eef0896ca3c1659b7e3b869f6c05613ef85052675c666cc87249a03a8682dd3a4e4c132d7f79f13b888bf86a844e0051c96dcd80e313a9abe320deb8d6f640a68331d96f818439f7abce778bb4348939166e1604b802ba9eddb01f0c148ce992cca03b111dd72df5a16d0365122a0c2d4f468fb1fd29b39761a3bf8a72e810f4a1644e673a02fdd3e4bf3900caee1d1abaf9f4069f60aafa0bfd5b542f5f04d280aff69dbb0328150ad68adb5c0d188c86fd99db8a00de91cd233d734a949fa7e67031ceed5030028d5d109f782bb1cd0fd8d55c2d9109ce097e473442e856f8646ddb1ac291402edb733b39504c9d4039a352a0de2d2881bae71cd7f6e65c34f35dacb2ef07a6dc2b6147f33f8909d322099a504b0818aed6eaeea8bb8bfaa6c36904bb0c6c4911edde2a1a3c18ead1f3c26e3f029a5c2d0b560058550847c6661164d133ba15ac116d932f7392f73541d99511569678856dfd29de2f6cc76a01bcab833e48e9f89789fdf6e076c9454a02389616e4636e015f3b873cc4b0303f8a891b83bea6cae843ebd281a3301fa05ef1266f1390a4c01385e719bbe01721a7b352e0709654e7277d3884dd3668bc18ab1451203f8cc071040196ea5e00aa1c1a76630b59abb9f6650139e7e3935410b7a1f19c4d039c8fe6f80284941766bc24cbb136227e02c75401e07fca82c37c83da970ea235058e4bf092ffbfd3bb01aa301940e944abd85ca957208ee4352cb919960e6cea5dbf6a1c3c106bd1d3da1a200ec073b90ef574c4c4abe9c2dfd0b244edabc85c39c58e8152966e7a3a2bd61b661a9844c507094ccbdf164956d413d2ac1eaa57c41fb7fab923a241a75eb8f9399aa1c1da2983e18215a2155d76c77c829340f80f548324a22a3ba04cc16dff486300c4242caf1aefd5dff23b8435df1a31cf15dda0d120d27a5271b4834ffa211209a5b083fd47898386a5b67ea72b9cc3f780e1f0dc4808498075b7907b50b49b3d9a2fcc87d885b32e6011c52c67510e017acb68eeb6194af1728166e70a2ee0fcbc8245e065e87e2fd6ab98f6d8d4ceb4d69263768a7235194704f81d699e30ce650c109f2ce0d95771c122604edc8c67ac3dd92d3c4ee925ae0b9f3a26d7560f20c257d3e50fbbf5b810bb55f2cf7dbc66a5dbc37f1b7a694445865f66b0c1e4be4b15d0bc3681b2c95d7f30a23ccba21db1326ecb135575a4e07c738365bea47cf244598f17152863e6fd2222f1fb95cd0627bdd28ca724e55ef2c67f211d7e6c55a6002eccbe77dfc007a68a889c18ff1084be56c7deb1c6c014651372a065d8b2eb59d91beb31753bb6e21cf266a1292e1b7444b1fb91c0dd5f7c4d61a86b5deb234cd933778f5c47297b624515c0687067d0aefb06742a45403743f2bba313ff4899dbd2052c76f832aa0571b60d59e0b5c0c553694c5c53ef8cf8a0cc02ddbe251cf585730937c9562a41b9700b2a20284fac209a20b9c50b8f1d6918ebee4a04f14a0858dd1b7a1c428f2332c806e355bcf9240c1fce9546c79cbd28db1424bc0c2814f0f1ec31f4af58d4d34667ed5a232eadf2591e81a896d7aad47549f99a1b29add60924f5ed6e6e6e2b90b9de1e2e6e3cc3f66871c0eb733fe809e54ac9e3e5b497446e5e61824c35025a77b0c36d04e072735c4f0a6ec618e38f029b2dd4fb968e4dba903b174b2b03a69aa0e47d4e3899e4661f594d193bde1a21f029bc5cfb9bb0a809bdd27d8404373f5b8840361f1a529a674afaeae7616ac39111fb67d319c0a10b4cfc0d7506e923875ad01ff88fa92fbb4e64d7d86ebd3633ba3c7d57619214bc28e7fe86b396b94c20475d89e9d0449e1ee6ff2bec34ef4465979c81abaaa03a79834c4ed42a26e363e9fd41f7b0cf8d2c9797c5a64785be8bb0003c518fe208534aced4f0df30514b3890a2d0ff267c01559bfbb7cc9e72797452eaa4fb72c99a702e1497cbea76f062cc33965d1cbdc3ff31b0af62dd95339cbbba3ad66c6a57c9504724a16913743f4749e86831a939638e86e7db2921c89a107c0c4afe686244d031131dc20e2b0f338435d1337730231a042c9235292dfd2b7bdb1ad0d9ccd019c2d5aa220e9c0d5b2c549f7137a79791c0a810ce9c6ca767948bc3d41d2bbe805527d8c85c56c72c46753d4da390ee7c9e68c50e4f8eda7bdb6d380d615c370fd7118ba758734b1e89d7c5f297854b6e734a8d93c8d5932d28703af3e8848a02e9fde34b9fbfa19c6f0ddc8e52246d8b6cd2ab4aacf54102f1d859a6f92db158bda036aa419f70e06a65e9a07e030e213a7f839ebd164c9fb7b0908068f4d2c4bc231bab6ee55c49bde08f363588bb835f5781d2274870bbd4da21d678bdeae45310bad0b9e0d8c279c2674cc140f40f5b57731375caf2e26cec5c8d5a58dbd2865a196ca0820706a0f05ab5d8f91e38be527f6a99d0e95f892f65878ef406872c2df0f7691b3ffe2c3058db9d1cc355121534c1a08bae0d0f3f5b16916d672674073e644a9e7d2a814f0dd4ecdf034282289d66eb8928c72a98f3818ebe21575739e7c89640c949288770006ad96cafb26ea97b15f4d436884a47b397b3d5b2a7c646d4018f7ad0c96f3fe80b51fbb3c0e7070fd449f2a940b0c151d0f5f0ce2ed84340a6c1adb76f7aa4b5bbd53e9d6c8d8b5bf93f9d531539e985bc33f98c125daa4e4ee483efd8df7a03147b3553b23b45bc654e391434b976cec134f3e65b4dee3917c80c24e3e863444e91b3fb5694687a3291a9608c0a889a0b26c72c0e3c91b5bc622db2d28a7e5deb7e4c7636b5d70d725075f1d501a3e0caa6d72df678cfa72fa516dde0cc92d23245f7bbdccf9524d7a2d3ba313834f84f7753570e1df60988a1a1db4aeab649d16f0c818fbc587b9d3febe0154e5ce877add2541034617aa1fe860366ae1833d74444d5bccb671d28f1c2d01ce283c6ade31a1131fabb3fcaf897d89c55190634ce81af61c2fa85287295b6d220b9e438d24fad15cb518218689126375628eede2e458017c320089278cb0a2431777e150b5a29a82a4b71009d9619d4055f96857a5c3ba0561d555a1d12ac5d1696f316716e282a924578080367f1248cf9fca325c8949c53b67ecd8c19c3133838563e2951763cf0b393919f55eb0a202656f11877f0626d33000a83550941c35ba70920a38ce45a008c2ff208a4819ce6358c2389543a98be4d6062eec7ae76eca031e0fb3855137dce2e4e6d6705e4d830539faa495ff14f6c7db275250f13822bcf1de5c2eaee11b9eb2dd5dad36fe5c383488243b641dd72b47ecf95865d3b031527e08354754913d815a9f5e315a0cfb2e9ec1ceab1b6b7e0f64f0ada1cec0ddc49dcb78200c21f8637e14a13e854f673c52ee6d4c02e9281c5ecca13ee33a6448adb5b1c4da8ba586d990fc2f93372d921aaba04f4cae7636ebb7dc73394076fab238c83a254b7a61af5e145983820a97b2911fd264f943cfdf06d6b31a546e22920c74ea8f8d5d2a3ddc6a3d2ef2e49ac4e7a0a7338aad46e7ba071cab02b2953836fe63131fb9a0657519951176efc7801a076fff64af82843c080b92402368fc2a74af00fa6c3aa863412cdfd79d7e13480df61ef3c7ea320220cbdd3947389c7e2ef9e1048d65043d0afcbd6cfad0813457dfeb67b6f9dc3e71248a719b8419e6b3d8134db5e5d678bab7791ff18a829ac48821e888617f4bba0607bc709c83dead6ec1312842bef7954df564e70de81fd81d007bf91688ba600908800b6efd29c062f995a302b8afef400b0f90f9a8e5cc95671e0cc30e3c8e5669e43ed4bf8505cf2277f096d5dadc15b364fd4ead0857809e2acd11988bb6dc106069129b5e91506ac23bbb8f45d118a313f24c972f692f9ce7ac8e50354cca96c4fbf2f77ce0cb87c186fba96b53ac93c0a18ec195913606a34d6f60d8f7e843f5d49fc044467cba32b929cd6f18fc0e335cc956e67e0d438c1e673a944ad1715a1ea1b19f64e38ecdabddc4e6467ce368427fa8d8adadfdd6e390e771373a054293ffbaf6961067738fb0684a06672fea4973e195fb0376e93e21fb40955f2df6162841804f714e1a0e2e509fb2a2ebeee36a3a6b7ff009a0b54d3aa8c218f39ee7cdd66bbe72a2b04b1851195c8a43112ce596c2383bdefaf0e0205909db35237267f038355c50281d8d36fc6e3540ea4e127d8c1cc9ee5fbd4483238d2931c03f6e9798fc5d4c9020b00af1b773f4339ba203adf984fbd0d8d1bdf7147c5c0337aef32267cb5b9cd67af6f995227bf4b6d2fb3ff982894e6ff2707d2719938e6054086554fd7c663d778fcaf9a6b1fcb77fac867680cf8648396a47864d2dac34046fe5f5cc94b6d08fcfd6ebd8dab4172e0d32dec3d19992a551178e46b58624ae08f333510436e92d68d83e151d2103ffa028f4794d0daf0356e3bcdc4e3c25597db0b3e57145ed7fb1ff9cebceade9dff8d3a3c56bc48d4503574e5c5f8a302e5208dd433653dc0e0fe90ed58a3d9a77aa3bb1b8bd15af9df1b5e2b50b9c216404a6302bc6a7f5bb826c9a9150620e66b610412aa439b52817125c2f99c369ff6d81ff5ba648b734bc7cca3bdc04dcef72a62d68bd487526f8ba1c504af317c424abe0ddafe37a5abdb61e28042c4e4be05d92debe0e3976647315a89cbdbd5e6067c6d81a0951584377e7e825e9bcecd99ecbb6682e3c4e9b6f5b9efd6e323ab4151d7ad58fc8453fd45969f7ebd92f8bdd2f9a5075b3569d0239de2c6cc742a2e46c50e037e2d4760953220c6efe4f3c51486a45c1ad886882d28d5b50968f0f2681b73ab73776301f3768f8d1319d752d8869805fe1f55ee395f7137e3ba23692fd9ceb6d49d44dfdcd176149cbb4eb5169c40f2bf355c503d79bf09df47d6c132f7da880b2de2b6f8425645a2e194a9d13e4d76daf4727d51e73a0b73c9d8432620e12811a7e78f403a16c099ea3a7ce76e4f9b734d9a0fec4695ad265581e918c50eba8931173bbcbe61441e613318e8816c1293f21b0a21c21454c501cb9625b192f59d0e0fef27d36d0bcf800441d14f1f91b03b39e47a850dd770da0d7d2a8519945e1d500d9e655f2e86d0ca2806f2ff6669f2b6a18d19eb8c39124e519c1b481d0c59e88b2089c47f535211b509fd39f43b8c594cb94a75e34ab434feda3551fd6c7243ab45879f679680ffe3bce1454d5e4d31c635ac1c250e85767a1909f79f87b69fe6a67d9fc11c7f80ce1e72d71d36730d4a44415eae081e79c0bfa2bdbbb608e8b230067880678162d0fe2196c3d05a363a5b5cba3244831b2827bf9e63698faa490c0ecf39fa5ea254430fe4d8657d6b9e8d08b1031655cb549973b2f4e819003a769bdc017ee525fbf90978c6280d85ecfdd0a0955ea2e6b451a6c6b4a594f3bb9c9ae22c49f109a2ec1a582c24c6d68293914ef0764aa13fdcc9c1d59f99bd35b5e3d269c39e3d883316e87855f064b7c88e8b4f066028296c1529e65c848a2c0eb8d06401689953158c368bf91d9c47f5e220bd1f631d8e189ea9038ac45c271f9caacb3e6738751f0ed7a10424d17c3e84e7a7d4d2cc6bb3c1dde00f0111df74ad053adb463554f74cdef01ff04f0376f38347297972cb9f362dcc759855315c30483061044d2559ec35241769f19797005c125573135de20b0834164113787086cc9918d7fce9d36b1fce166aacf6da778a7f58c984ec88417e5a1545633ee6c655a052db206bc8983e5a7296bd816bb2a1ae876273375afbc16ccba98901cd9e2543c6f73b21de1d1f781dd1f9019e3eb35ae6c3521e1cca4c951c9d33f42d1564f081c64020a514088faa3693d7fc2441ff1e16a4214a9451ad357489063bc7b51aad6fb5d8b89e9dcad3b830fb6c7bb84930d0d11026bf2a8503a094a271b4f4480572d898e4f513fff7cebc8a5d6718204c98ec99bc07181020e8ce015dc1f77bce9a17be88035608e0b07b18a25eb17ccd483b6b3468b89758bddfdf5c1ccd6d513740fa2bb484db8c517556d63d66080cd1f26b8900393f5afaaa5efddea516b5b4dca2f4363cc961f06039dcad09f80a0ccd21ba2c2f5d9c672473d38336923a681bfad8ea67902953465174691755e3602b7152aa1f441ff98c37b3b67d3fc7e8faddb9a6ab032b6a1a9fecdd8363affc7ce83b7dcf29dbb030730c3f99fc6230ab87d40ec2b11f8446cc16a025fa2440d64e5207cabb41459e7c3c89fb3f69b0c650978da8fb2d6bccf82878ef022a0a0a5811aa5bd5aec18adc90ec80568da60ba9d377aabba3f513a817a7c7b8b8d1fbf83dc3248ad4b850ee5cca337f12c262929e3756551d4281d944d866a21b7e89126c0017cca5cd86a727f931e24e1a61697da582cb4b0d2966fd380b7d412af6095b59596c9f5dcb285e5bf37ab781b4f759579abfd7bbb9e07c9cfbba26d6a310ffa5e044c3a1b735451623635b1c4f40eedec69cf32bd8ca9f41c73ca7e102dc0c56b7018528963dbae44a68b8f6a3e2a8604979412e381a672778eaea3d4593ac5ca7f5f58630f623c275e50585654a9df194768f646e4b7ea664bc9c52b379b9a57efa94959a4037805fc39757cdb92050125eb265db7304ea188f0c6ca498df773b7689e1d88f257a3043b0f7bd915a86deb802f4e7facdf9404ea7e702fa6a87dfa8b01a43b30c5e39aa4bfa2cde0808629874142ad010e63b816d2f10ef50442e38e300fc5bb20ea300a697b6f19ffeb5a3ed19cc262e827b4b844011b88b3f5788963ac94f5308e1c3ed04b8e87a7a695d7417af89883786695232103809a0f8cf0a52d4ef195d5710b31bd2c938a6b4adbb56e4063edc0f06f678e960fd8a3bdfa3b50cd811c9030826f4100a59e30d9f004eb385374fc6a2650eb8d9029a8ed7eeecf1ae2639746c319d25aae6c20a59fe3c4a7255e74f473fa7bca35bff60663392a8e419983b41923204763c5847a266e8aaa98875c454640e633c01d24c6ebda9d9232b125a07435ff3387be221d66c4ee0ea55b1b413adcc0ca22a22e9696ffd23ab2c07922c5dcb2c2a02a8aeb7df053aa9278048802d2808ff0cd20a263bd625cef39cc27539051d8d886ef1199315f98c889210d37780736e18e55f37c3914ed7ec4002f5e2bdeb4d95255f89f172ef347b91e27f7ba9c114f84be34f8ea854edd05d83d7366384ea648ad5d2706e817baa1a53e8af1792dd00e4b1747a9f7f760656c202dd0a6382ab01fa9c490dfbda5fac91faba597936c30be2e56411d09a2eb9659f28fbbe6f164abc759a025bf380bb097ff0e2bd9dc6bb36a6a261a70fc0ff3800aeb7b74e60d5cb92eb311adb972b95cc03a1724c8694e580e7e6b726f7761d5d43f13dfead5a4c90813a8e4a1b41281a9738e0affb90102b6bed43c1f052cdfbe30674e4f121d404347e6f9d04ce9169f675a0b8beb136a6915c9aaa6eba5b517d7016d93a0e745e75322be76b819e1135480bb4ec695d69af80a92c6e0def4fa0322bd5cbb460d56cdec3d12ef0828f3badb0ea1ea4c3a65a0e14baf6e10f5a223df1d04f5ba5d6d41f43041274adc8bb3c00a59fe0f6f36150e0d7faa5f07d49e95015d2f73177406e8abdc9d98058e429d5e9048cdfe3b5c2d9c8fed9772ab61436ebf92321a220853b9984a09975c3aa91c8ff07dc34655e26d3abebc1e7225e42b80afc5a960e915346445c5f9bdaa15bd4f9fadd96cf0f6f94d5c06a8af9da7e986fd5c00033d7ed88e585e95ee8fa41d709386278f164e6b56bf8557ba236fe032a6836448b4b505e012590abed55a9efdb4af6ae68f1e37cfbd9c5b896c8b9d0af1d30b6b304b303a828c148e34441f4e7859b5eeca110de25da08ab2a1a7041a59d9f8bb224fd84339822a5ec82880022d38c2bfc4c4135c325cea65a822edc0359081763769ade1122e177bc20f8ca438a3fe0a7dbafb33a96a81327c922360d174df21aa3c7e55ba2bd98d08f0fdc47b3425b9911011486c7b9e275233cd0029ee23a9827e15860185775d378b897a4b8f5a74ce1c4b8121947f9cff7aff58bd419c325c16e3e2b5f79075834e2981dd126bb6ab6d697cd3721f6426441a8960a1fb5c0d64f9d11fabdd8ceead7faf3f276274878bafd2a4470e806d8c07d4685d41dd3235c16f5d6a39f627804c12c46bfd78c51eee38257d1b55bfc6eb96a85365990095c515376970e87a1ed70e0fe3fecf7e72659329cfaac25873b24a43e4e948c92d31693d714269e7a051446a4fc0be560064a7bf1a95239106f579ab5f4da4aefd1cfcd43ae699c04a60abeef78ecc7a0bf9fd857d9eec44252ce449e9d3720e35a6c8c74b955fe949558fb9a6deb3d1a17d19d8b0ea3f24ef1f6a8b3fa52857dcf8be7f37f98de0b46e324bd860ef10b0297b5161696e1052d3423a7431c5645e516798477997642ced177478926a864dc65062bacc292904797f843ac7d59c4d8e2d154d3843035f626b9ff11dfdd659a714a4e47de48226db7632e6cbe23530a4af3c291dc69b0a91d1544d59838314699f38b1031f18152647d8f6c58b1000bf720ea445249f6f79c805acc9dfe95eb994ef352e8a4685488e5a92cca1fd325074bb274c23ae696f05ec7dfb7b01caf5b0986e22a5779fa93fbfdd0c67f5425cf78757ee85f3d98549abd7c10d362556ca148f56ee9f750537bf540fc6456031b11c87523abbd87f3e3e6e77a4d983a6e150804977c4462c6679554651d38e585bfe98a87feefc3dd38390c03c0d40ba201d61625cd32d773f1c5b00ac4e7ca4590813fddc761fb83991ab046b788286609c10d2a14569a74f086ef6782ffc8cd2c2158e597f47e251e8ebd5c1c0629f67b79d4ab6d107c5669472e3bb10d193992f98d595d19fd3bbee70a9d8e76f83f7bde70bde05e48c87f8069efcc3ae84110e9975321a4543cbb613d5dfefdb495a1db5a9dfa49ef2f79cf5c3c4272e98f50db2ab47e164fde845cd9e8927e996273f362908b66c16e1c06f4c8aca90c7c36c9e55b2e02ab991eda21e2233276587ee3ac1d2921e01d755f48793928c15aa337fb94891e01ebda3fb10cd04bf0feab34ec057435a742d10a568c6d77a80bb36501b24deb0619d319bf146759b177f50f4c488e75999715a568bfebeb6312a35c1a4161724398842d02d1bf72cbe840ed9edaf060497f4b416aea92c55315ecdba0b22d19ca815d23369d2639610d28da8d24ab4d0de234204cf6c93ac1e6c885cc9b1ab2d7ce8c35cfa5096e5917db23179266b9eb2ec2d879da591b50667502717af48e2bde3f4798c09c04c31297e666eccbcb663054f98eabd52e7a2e17a8b494942e2942e6026690caf8c7fdc47d71b4ef066154c97e84a99ff7b06561edbee21d8782dc84b9b851326a3d40bd3a0b3cefbe727fc320a2a9ffecf9631b56d32d542d61dbf03ef2ecb04fb38b0154da1d206d5cc0714e4ef80f488dbbe01f7480f2e0b06077ae13dc1736cb9a790a1fb74a25eadc72c24d2e21832f7ae030e923ff192192dc88d8682f0611304fb447e7b3b0e200685e15f017a9ed17c372d999f1b462f9519c1e6d3e374ac2a0581ac451aa53fde210cfbd75bc44e8569303058ce0a2bdb51e06533ccd180f803d9d972418e1dcfaba61003b4456968595f2e54c6a86db7080067a7ad550aa54c090b6092737ce52c6210ac02d83d9d906695347ab16e12fbc11553ad43a3a0bd2bf36171cc01af58c2a04b69eac73ba87491d1ab9d9398447d2790ff3c4a3bafba4780e73b78e6fcf7d39adc5a601e5b2c92740f5950874e2ba655b405f73ecf862c97978f3aa068d94401f340e6841a95a9b3076d44f0b149f8a724cc4505fc57cce1c7c19c0cd3d7ecbc348e9d521141969089eb6c305b0571bdb677e5bbd36e51e98cfb20c861e716cd534eaf9041f0a728d53208e737ee5dd25881c4ee57535a6217e5eab5bff80955e1ebddc3c321e3572cd7610de3710d00dc858d677681c008001a41d00cc4dc7cff1cb0c4644c0443907922f837ed7c1663814fe85afa420722ed29774a122c2af53340cf08a62aa4786d596b035c1c6ebca5ac66eb7e846aca86d0dee7c9bd3fd95f9d7ab63ac1fd0a07cd58ac8d9b3c5fd9afefa616aa7327b6c699b198e45306b23dc5a28b54afe6a7c1c6ddcc6b3cc36a27ed66cdc307c33e047cc3ebf57790fc3f1afc64bf322ffb9f7c1a135d2acb9488b7c19d26b6c7803c064677d71b6a9bf3e363a93af4e7210104e48901782a5de3b3a4272f1b8fa19a7b9b1e71364ab77987da5ed7ac782b8bc1d9248c4171a3c96e38c892efe159622b27183f88cba8cc6820f9259848c128240780bcc0f3babdbd789af2c99e04d39228e988f1b1632f63503832bdb6c9bda627de39c59c986a5ffcd4c2f010a297e81b52e73eb0c8d9a81580edf093bf052d6e39e502cc8b15331617bba025fe9cfe6160d8178c8b665f8e305ef59a1bc353685f4cedb34ac9ff44dac6c9dc1d65fc0e09a43db78b3fb2c97fcce60a1beae44385ad624815c15f5315b06d6112757b01db7e8f47313926524da9e2549378d69e4b524ff825e446c9158821b0b34fe6657a47bad16c60b43a042e9eab6860e397ae5058c93c4d96fda7eb62844a51336c8c3f1a0dbc780d5b5ac4ad017dc7c7a0eb50e19c7fb608cda8de7c48ea98d7d85ff4df1810e0e8e7a4a6e1867177d2cbf5977cbba3b4d67c435cd71591002d58fad333997b34e77c92f81e3b6642c37c7d7bb44327ac67be09f81ecd37d63f8a391966807df39580d0347060c72373d83e86c5a4c3573a474a4c117ca11cf6c814ded99f20087ba9f4a25f0e11b57ea6d97668d8d30690c48191dc37351e9f1c90e7a5f96ccd15f99edfbfde38e2465594c1174e8040e0e6ae9cefec22d6c2c7933c7157b0447ca52afc02eb3470fed83867c12bbd1dcb2256a4afc03e410106f4fb8a6e1a0ff0f794a602581daed22cf9ce40ed8c7844a2d18e03a78a021a8db033181d3eaea91403d9912a9e922cd61a8c31f3ec2f0d045cfdf7b68a22cbf77b452d55764ef1e59c5103e9e1cee7fd19c50762d3f97fc86f4667e582c644daca2d115b4b1555109d9342867a22af2df6a1a1a9d79ad99c08bb469c349c74e06a5b3e824efd82bacf8edd014e7a5994b10f61d434c15b54e5f402e3f45d8fd2caebcfdfbd319da454e6bdb2ec2432dbcf44c01d67f8438e3d6afbe725dee195f113093ea5d7fbdf23f3232c271bba66a4e09cbb67c40a3d73e4644a1be5d05b3a8b104023d0546af17e6d0bedb039238115680175dd42052784c2ae3168bf4761e817a7d1fb769d3c3e934ee8d747170fad8a6c5ea3473d5557246be84bab2bb3395503147561611616270fff18db115111dcf66c187f62a9ba3b9ef7fe86f2049b0628101ebafe611f5f476a3ebc35df8df4a020c60c48fc1f96a13c4dac92c8772726b055f0de806355cdc8aa5eddb50bf9704c0459320a45e649b8e7ee640cc2ab0d0d80942f0b587abedf1a53450547bd88c93747e409e17c08df820254b21f2052ce3ea0648c6d9af492458e3f7d71dbc2c50c170d658bc2296e93d68f647f71e45a38f53e567b6bd87259be3c95874ee25bf99c7352ccec8b75bb8d39a14a2d5b4a90540f420085e8966cb7d0f47110b77b2bfbe30a402390c7c19ef8c829e4dd5e3a1f4db41a4acba000c6e5128120c76fb3467880feb2942c267775ddb33a085ebfe2328b3b75362a1617b014e4ceea818c5aa617661f4ee48bd22c16593258c79f0c8d641149baba382161f1ca39e825816026fb08699c97a06cb9d929d4d6e5dad041257c7aa22f69a5f9b086a7a1624bf365e3c20f1345b82587cf1ae212c436995a5c2e8c9d7a95f1cc775d184941c4361eaadeed0e8e15e69f68d160aff9616dacf100a7e76244c5097b4f5accee2a5daf1266ea2a7e5bd30f862ca45eb7eba4b5916b903f31818c2a9b5d7e1ea0e7d43fabdc88d52a80e7051c653f5fa7df52a6b7e12582f06f95f1ff181b5d59c6c1a7a38220bc149fb484b7664e1e63004066b5aee8d910a665f91f811147400f632bd58b736e8503af70f55d30f765f89d63dd63aff663e0da5ac2324c5875114c5fa38385010e1f0d4a5171f2a4ad05896da194af9e0c8c4c32d0f69cc7b870997b7ef5d9fe0076a87530864ef8a16aef2316d09ee737a84ae22f7bb061d417e4d6eedaa992fa3b161e890dd3a18d5c0b96b0085a75e47e84ad298f12d85937b536cd3c536613ddad98b80bb44e8be2b99dfa942e4a3122d830e56165a76853d50927e7104e1dc149a0ae0ead49c84d5005a4bfcbbe7469ebaf34ad202739cc5a906fa4c4c11f3349654f95e3b0c13af11d57e09a92ae87dc76caf735354c36e30b4d0f58a03e2794e82acc78949da7a6ea497f054b74af308f1c680905070eaa9276e0b43ed27bab98b3b9c8166383843fe2457926600331a05b040e927d13e046acff4adfa1ce4b36cb269884c1ffa70acf5c2d3d56ada9bb53da24ac3b74ec4f03fdb25d463e1314b0b182339ea555ad4e762b790b3415d6cf43224287e546a0e09f39d16fe44fcb00258549542b3ac184699f0f81bbd679df698b5cafaca81402a0ac249e501869fde34c6f0dc94c9bdc7b6dc2f35b9d993bf505dab7a03128bab3b476e67aeaddf712f70e40ca220f9be67a722426c4377ba26fe0818a97c01e1102c603807b217518ee34f46fe15edce8811c607080829cad5039905df9873c5b2ee072081dc6a8f151bb3e36f4da097fafc1780cc6d666dac271cd44db4c135d90cc0031c443a7edab70bc88485bee3e35802e6dee4edfb74f2658f8e45f4f80292e6ebf85dcd758375ae2e25cd462b4ee5929e148f071385faa4c682e20c63f372ee1ef30e3e18840b702f2b7cfe6e567ecefd61126776819da6be1c3454535f8148338fc96968d76c2beb34964df1ac2432ce83e285195484b429bd6bfb5db239f7da4236f9267b19858ba488cfc198745dba12113dc04dd50c6d30b0820732f8f1675570926c2897559c6b7df40d3bf4be6c203e45d37434d12dbd890b347da7a0721a3901b39e565abc1c05cb173e7b2085ca95192d92b30252dd818587367e02e4f0e2a99712f3b409170f32f08172bb3c2cc7a72a92eb6cdba08c6b1540ff3f2d6dfe7d105ef657d09a1f93ec35e14ca4925affe9b2e366b453ddc7af9ac2c03509480242e51848964abaca02a1d803295b978039013a5677834bf344f0737591edab4a8114e3b59d9fa2d9f3c128cdf57c114f3a90f75deb2d68cd8819e34f4c343d45d624b9d54986f48e0b878b8056f3dd3ba833f114bc843227fec802806c8ea85df2fe515c7b0840f699a6f6100e67ec6dd99f52ac0b8cee8acc41ef5d1c8367334a2db714619d4045d45bd70f86016763b2744298751b7922ab5097dd587581df38ec4d6a42de56027425eeb07770a4ea7e6dcab5405ef41beed3653d599eed031cf7054ce3c41625047da898080f9505b438659798829195772ce148fa315b6a5fa06eeb45667c62ad93a1ebc65b4f9af3b1c94da7d8f6064c9e033c6b6b850bbcba1e71c1f0e59191534db6792342b52cfbc2ecc138d031bce30e216075ed5f15b660778ed960f291e1438a3581a340916219d96952a8f112d1792340df04ce161f45678021eb6d7fadd208ab8724084790cfbc9ca41e08f6b646118b1adf251b4abec1d4bc4e35ce17fe7a87576449a73de14cc9a85b7e9e85d2aac550b81965a585a730dc2a5d232126d6a00f5a13a0534c418de5eba31ee0de4f9812361ad7afc92c8db8be6395934a20c67e53e30fc8c82a62c357f569edcc56b5b86ea3463b6598419308d73756c68e5337943534cb0f311e1a9b08963c2d36bc3d68a61d100e06944a0311e7164598d486ceed1440529db26f360f83af17061d22aa8eb1a9f1c5bc6d1283e2fe0d9f7fd20ad438daa33e0f8303144515f9d65fe145f201fe5310bd5ac4faba09edee3f0f80575ee6021c60f7acfbce9e7fc1d484b7956ab475cd16ef1b730d49bd11f5dace2707ac13f32649a5f67269639640bcd30e7196a869d843036a8b4ede2fcc40cf9c80ebfffd825c2aa1cc80c85437b33cad5539b94f132c228d69898816764f9c878782510d23f0fae80c38e8eb3e4fd6fb93f53dea1601784b5b1ddcf73d167f649dccb05c56633b03b88ef4e2a8d68ee65e27dcfeff4f9b5f79e9d7d48bd0e3e40972cadb440ba456e2d4d6fe3b55f9b5a7c47d333c2809a8200182dca8f59cdf123d5f8b91e3fc6e6bffb422b8f5519342cee2adf08595d216cf0356839b117a08462c0ab2801da850c99e0d404df9bdb1978ba6c8cc8ca08718f7cccd0ea38e8ce7c4b8362e579b69059d919194bbfb731ee9292aad7fee1dd80326ac955aba6626da55e1453e071dfe67492416e5c01d4943d05d90d91af5f43f8514978ed93bb793548527072fe3fb3192a64b562202d732295db654c0af6e0c34189bdd8485faddc9cb8470fcf6da1b740d25cff1fae369097864b58c9faa21bb92ff1b9bb2beeb427c7bace867d51b9c6aa5a00d56164dd5971025e3c759f422bb18680065ba9226f9ecff7a00444983b562b09ea6404712ed3d42fd5af33806fc763a4e873c0a2303b55a11554119eaef5663da07d3e9b5fe632ad2e452b3f0ae7896393e3aa12a5399b07b5acb9c27de91b27a2d8a7e9d8ae43a996ce94c590cf5e178799530f1f6137373e3c6314d1ebb83069f1ecb8759af84f74ba6aa220cd97dcdc3dda5d24bfa60a8489a56a7625183a39980479eab347e94c8222a4cc6304949432ffc7a4a863e6e32c934e6f97f5c4dc3e6d75a23b01ef7da194d4fd8e7af499a0ae4461bf3e776b864d1eb576b28637f891c022be055c7a0d9257b29736bb69c09c7b840c13a6eca32cc86365cae9af5e84c08fa89e647f16589cd9d480a49158a3e491cf6188ad96c7fd2bf0fcb97518d236d178dc43b07c27da243e40348cccdb3c7bdc8c80466ba233c1b49591d12bc5fd0902706d9abefaa847551609d2a0f2bad041d9e7c67b462cd4e95fd397291823f67c52ec4f0505a3475607bd5dc2d766bc17e22f81e722629619a0ec99b55e4709ed18f7056b3b52d1663362fbb31f95b681aa3e449a86e4f2450693361e91524a8b978c550123884bc9b49ff4da583157311ba5b77395757a9adaf84072c8fbad987b321652ace522f6806fabea99a4a9b1ed4120791cfd70030d3b464fabe72e6d0a09de2d4261c2675b3ce90f0af9175da3b77990cd1ab7cf516ea7c3ba9f15deddf130984b8f19ff38c85535f6e3d613bcf11dc93acc429bce925286cb329ec15be56daf2ceefb53584ddab745c7a8c921a6a5323f76c204a0e1de65a3dfba574fffb741a08972dd60462a6552d2f3e5b2c726ba19e48226134a47c95734de5fe302a204db7ad4ab77afabd0021c16ba570d83175082eb1efc6c2a6eb710a5cc3a0871c1c2b59a61ee0b56f939790af1f2df3e64507a24e02a1b9d4227fc1461a15f645bafa6bf43e5fbb3c38193278d0199a50239379bc2b7d0cbbfb9dabd154a714c0c38480f226c3fa5ec4be7df812968ba91a3dcfe2efe4097a1cbd6ccf9723a9641dd67e5e4b4a63515468f67b5bb5c3b4dbf565bbcbc16d48c986abdbdddcfea0a46854ec31d0ebf6b053e02d4f41bc02a019d449f4e10ad9bc205a9e2d9c7c45217aa44247a96cbca73ab66cf879c1f71ff4706c482e1af3836fefb9736574a732dc95217fb2231825d6186403bfbaa4bb42f952559a492d986d3dfb80bb627210ac14bedc70de7128ea65851bebc8e4189ea2126632a34ff1bca00201eff75460652a6303f67f2227fc559c8b7c5c2cab2e947e052d22abafb177d70d63bf7152ef1ff17538f2ec67205d7090e64300567594238a5b63fc9f559329719d80a624fc51277d0ecd0857d2ef4b26d1e5b2f0e191cfc0db0448b58915bbdd4c1bfdde34a7a5c0f700acb092cb922836000930dc73b78884eac36dadadcff040166065403001c4b687b079e5af2739650c13cdedfa79161404e484aa310d7bc6fb1a4a8d0705c277e17afbc785ae29e8da426a31bd4c12b821b6922af8b951624401e989df5d8de7cd50f0d9173ef23f39c52abcd3adac59ecd8b215362769829cb1bdb24f07773c625e909f55abd7efbd8bb36d092fbf3a57026f10a4e0c836d1cb481e4ce6ff53067626ceff9dee1f909de1ebeda4b09d40aa7ba41d59365e26e80d31ba9e85a61754475591d426638c1266b7657b742bc40e5d6296b24f7c6bf2b5016c095822a1202114b8c18342ad3f056c45bc906c1612045f71445d4d635aca218ac7289e0788861a24a82b3844282a2b3bc831bb64666878e614b58b487001601c064068ae9186ca86faefafddbb8b28b8c30e8642c66694a0f3cdb2b67966bcbde84b7373824b74a9976c30cc8ebf85d1fe06ee75468a56324d516f08d0ec2b017408542222530bde35481bcdb420ce3a70e6b564d27ed21a5f4e1c21364572fdf7e089412915ee326deaa79243d33459d1a3b6f0ed2657a00c49b1679541909829264739223756b9cc542b9d17d6505b7fddedf21bda86cd878fb5fab9cdfbd131ba1a76f0db4e736ea0cd240e2fbd4c7dd67ec81ba2b172a324f358d10675097b79e597f91d18e11be84bad6fd07a93808ba8b7a3b7e2474dadc7088344cdad05efd8644e3759ed6011c2f2cc49e42f6979fdef82fbb0675b011496af66dcff1544861aee70ee17af4918ee5e8a46ec2b28e116c35cb3df2c07028b49e0c7598b9cdafad128cbf9bfc50d9737ee144af09cfd26d79fe549a58b84f9bea5e794417acfe938f431f32a60454f15583feb6daa42336942c2e595e01670194736ee2ac57ebd6c316bbb030135df0d358b96961f57c664119da695e7bee7632725d08f1b3bfe246d1d56384b0a76a2fd613c84a02a3c8057d59a6a9890b30741ad1978da8f7bbc215408aea2943804f59612c03259ae7a38ea0d80a2cca2b5dfddf58e80a9244adcaf99810bf2cba7f34db8eabebf400f646648ab874fcd29cb0a0ef37993fed98fbb9fabef06da4df45798e968636261d23c5318c1809bfb5979e5f64a8ad08e1d74e1d353da9563c236aa77355c62331912fe12f0874c166ca811e82fa70827c349b470ad21613b56c33331ff6fee6d33e01c784d9454a382bc338c9b0a0d6653667c17c2a3775a01345f4e9f94692d389ba18edca885752d4d227f04dbf1fe6bbe3c55829dae33e8a0823e5bdead076ee64ef3e34b26f7d1da389f094459de5d80520273cd95b835a0a4c817932589dc23153178bad3d5c2e6231ae1464df71c369defd484d3758d18100339a16895a52050b45ae660e484758c40fc9a92add529c61c869db00016f1d39524a13ee99144a5179e03cfcded9f529493b3163564ded7cfc767131c88da0f352ab95d96b9d9e023143de55c47591d463350398e2e4e8459d8503809f20c166db3bf919676bc6f114513aab72c7bfd3dc84615d90f48c073b34867a51f0a9b4fe01be7c24308a3f52d717b9f804b5d79ccb1c12c665c0ed7fc0e2441bccdf930dfaeb9197ceed416ab4c398be16fbd3b218e4cdb797d2b2015da3ade8bea3b77b55859db4c1714e4dc33bb2fc2bb8cca0d49be7cca3fba6654987e2ec457ce7d4be7793e7842e4c7febfcf99b4474e2e92e89119e5794e7bcd44d649d87f788874650898a80784916f0cbbd6a0ada9e85f7e71023f3015bb855b1771134bf56b4431b217a966388a37e7a8806138a61d71aa1cf272d7b67debe8453f58441d8af3400e0231ec4af0ff69761f9bc9c20d174c48619b0593a82d09cd507aa48f76f3ff50b2717472fbc51f17791beb55f1e7a262b793715baefd1a37fa34b72acd8d9ad3da5a9f60a24bb605121e61e5d965934115019e853634485f82b4b88322320ec7332cf1c2c451841a174618669eb842daa7fa7b826cd289688f163572390e302dc49a326b306d5adf9a4520180ece252dfe3b4bf32e2de83fcb1e5e0e67ed29d2fe9b00afbc55de7bcb68927946b0a32f084a907e272491ade359cbeb26b7cb782f1704b6998f3ce79d92af5dcb5b92446bc0f012fdabf5153ec34253f3ed4f1b8cc7d29d75d243f68758f4187c44e486fa89b03f2a49067290a60b4b348a075c03ac4b22473dc7964d22c6f0f9681a807a1965a0610b11f2df1bb9fd7856f3ea94c0251e946de8baf7c6524550bfa4ef9e6edd1822da06a1a9a9f64acf7aaaf7b2d4acd5b8636d76e63fc380a161376b3fa048c876130a180f23cdc0076d9047c8d76fb9a04095cd1807baabd5d2c02457e7fda16d0d5d1acaffce8c3a053344eadfdef70d2eea49669cc48c8afe0acc53aa2119993895d6c1dbcefc9ffe29a3b7f373889d0a411334b7af04d9bb237e5ef39243c09855173b919dfa0d3a7cb5369789d73bedfde248fa3169d01082862f4bb1688a0aa979b5ad092caea710d25139cea58e772c675e5ff7665589bfbd8a1ab622ff5fee7920bbc14a69e54964d16faa7f2a954a9437af37dcc60ada8b0971f6c4eb67493bb1292364d2170ec9ea84837940511e649c14d49afbff1465c8fdde8f3219d2955019680967ccdd0ea92a405272bba674c79c9c8955531aa61983f4175df8de14f237ed929a84802a30596ae24150157d3af8f90a9420b25bb1a13227f33f821977a790bc1204d78d212c2fe38366616e5fc38f6560e9eed20cf7f660642ecb9ed625f9f4a50cc36e745d34258e048f340f51c15aac4647b60d6d3f430d3d152534d9123ff0c676d88cf8e174676de3ccf4dc3359bfa3fae644771c783ebdfc2de5414dda783e4079908c83c4a1ef2ba1ed83e5ff2beba5e5f1df81cde1ee228dc24c3dcbac5ce382ffbe5fede522e7342e97c229b143fe5d3f41d1c787305b79e3c496c2e4ef366e5e756f129d26a9aa5b4112a182b9dba828a34b622012bbaa08e309e4fdd6ec6a83dccb9eb4973180a4998f91ae7458078b82a0c854232563dfad67391f3b1feff209b1ad3ea6912bbd069a61076b33a473a4563de32f18c5887d686c477ebed8eedab68d3b1b45420f45e9a8b9daeedf58a0777b37b07233eba554af6a7ee0197d027552155b7a277571b02e2364057caf58f57140e3655eec30c9584d1eee5f419ce0c0d13e42198f0739d29336577471d1e8430cfc3e198f8e936794d4ad47b067f5475b1e8a6c42f32a471f71de4359902e267fedc52b6cacef7fe66ef8d767c16b5cf8b1aeef8b211c9095a45b9ef0fc5555c872d27bff5c3092ce89b5608f76732ca666a4b9e91ec4a6aa598f1ef5c75daeba8bc302d19954695b5bdfac72864099576d223edafde398c2fc752ace91d3cb4be821306a75318bc175b1148824700636cf532c880a6c1994ded2ff611ca468228f6f4e5a4d0778c1a9af40eafa6a7836d19a7b9c5ad37dac08d2c9ea995bf4b36a0ccadac45e80b82d882cba24937226b60883345326197c463ff319cfb6be0766b03b5ab40d9d5534eb403a00bd5b94019d2db89d53654126b96048e2ebfaacc92587dc4d9cd2d50d33f7e48bc1c17f87c40c93031c104229cbdd68cc803d764074bc2dd500f53eb3de24c431357557a6729681e5ca076a3cc066a6262c5e7b7e6a2f08a01ca13613af4b9769a2e9a2ad2af81ac37442c1041934a7372b7b019171727c4510c462c72786e2b34cd6731e6af6e5756c90d7fee84be913fe3e5f1a6903c61047875b20a0df9296ee3abc705e59d2f86d96d91a2c82885cf9bc2312347122a633b3037bf298b173698aa0f8554607d20bf8a8c14ba8939f06bbb76d83b79850a65059fe73f73d7cbee9f4fd3fce79e5edfa2a30e9e0aaee460e2e3227f8990ceff3e1907fd29a4f99d5a05b8597823daf3355fb0c4786a1e6e36fb4449553d1c460736dbfb766834fcfcdd081997fe32a81b7bfaf8a62d545113bcb457ce870f4784a9940570292d7b2e6c55eb30578d5bc7c83c13f27c3435855ec4fc47b4056ce69a8fb6dc04200d76f8738a5865eb4d573595ff79bc4a287ccef9076f59b35f2fd73ccbfa9af0f31e5441badc2ee5443ce172b083ab0742847b7b22e351c20f8c91033e816667407d66f5671e42e732be2ef5e2811d4294aadb60865250e0b513512c3426831506d3559523f0e96aeb2b7c335934a240ce2eeabe7f940f037e5ca43aef4beafc917bf3eb8371236e32dbfc2fe4e03b05c576697792a304a6a339b935046b3e7cfc239fc3cfcd23d2aa71c491761cda686342223acbccb8fa1b27adea6e8fe4e12959210739ba1e3fda3a27a764a7471dab6233c959f7bf31736d948702d3f06e8b01973a7baac31ba6d29cdd4ae0e2cf951c97c3c41c54449ce81f2799cc0596c43ed68e576e3c307d46c12876c929bd2b72714826bab57a77817eaed3ac38499c29d9b3edfbc5eb9814e6a018ea44461b2966f3eb6170a17d248586301ce495aef61b5340c10d552818e20ac8c74079253d48a45d8bdb2be10939e05b6fbc31394acb514a25b0ef46c30e51fb4f3c97a1879f8336feeff77ad97716d87f721f145076cfd4246ddbbd4adfbc9155e18afbf2a1ebc329bb6fb1a704b1e3bc1a2713709a0d8e35deae9e716c762faa2cd618ccf92a8dd0f2fc9adb9f515f4bc4078f3ee7746a3663d388e892a08a3a94dfd98a41c41b36fcf995af158bd93cb6be55b006e156c2b56429f0c5ae95eb3b4981f5ac3ccdadac3a63ecf70f88108367ca651400ca556097cf712a8e27c87f1a0dadf89029a9f0f978285be1669b9ad27d90ebf0656b02cb69561e59009b85c4103de10a122dccda061dc7d504072135f1fcf6602f491c5b350d6a9348c2093fd4578a1cdd8fe41de185ece5adb24f7a24efae19c4e7a76fc959c5bc3f7def7d7a38f10f7b3cf0c735c5df010a6616f99ecba4d9701a774471224f3c10c52a6f4fd15b68a6bb094e980eb1893b6b4b90ea3d65e5c52ebb7928d3d503a16c5bdfc899abff8627b5f9a48fbd6048d554ff8686a842422cdbcd00ff58c2b8f2f3ca22e27639cb258367571d08462f13d51c583ba40eac7a9130f6125bce49a2ba3ef964ee064a21486b29b4c8d82efaa6d8fac0e2be67250b67d3689ddbf58366557a5db8f72b3c1a5285f464867a77eae81a01b13e8d2d601f58194c020c88c9d6b89f2f73c053f98e807bc7ea7438b04fb729f5cc657206827aa7bfa10e93df4ff4d8109ee6e0e5b713eb0faeaad988cd69f10a3844e991acaadcba434135e2148cba9c0f05f0f8bd45abe0b5f5079a9df164d1211f039e556b21533e1e302e4026dced0ee683c8a6934585dbe779df6f5ea348b33aac5210104e1973500841f658e046860f6a9c2f682ab8f1c214bbfb3ce702ee66d492bbd2667c4b2d0ce672b6639591326c08e946f117d39b9bea8b45a6cf8e7e53249498de99edf47256ab3ffe311fd52d9641bc0767a7834348f48ac470b2942d22258a12ee4d0303ce5df6cf2a99cf830d745333ae1609b334a774a4e0e610a88de991db0c2905e2d51d540c935c311f7238fb0729388a473d59126d40dad4e82d542d76cb81f7230d0fe82fb1e6a0519a655aa35cc273b10ce00d2552936f3f0c99f7f79d98d57512b11077f3142d0887b2cbebe6355d9ab82431633d2816f126324528b20c89ccc7de86962b56a32c63b3c267c1dc6ff7941012ed8641026722460a6f633afa75cde00d6682e6fba3433404b8ebe798f4a5d8899de7024ee3ba68724700ba035a4cc8f9b6e4bf337eb5144e9b302714d4bc9b8271aa7b3e73d6ddaf2460809b6a6dddb10f2eb68e01e156b0efdae15c6fbb66eaaf9f51686ba650565756f0a50050ed4e1f047bebd838ac0c49e1ce62b7ba235acdaf15d38d98f1f84a015921772b7272b0e9fb3eaeb180ced4772272a539c4e6d5b6f318ca84c38500ef5cadd4a93a5e219b507dba3a0bfec2058f97e72de89bde8285f890b128907dd18625b9a07fc956c378b1111ffd107445acb6107eae807c9d2a5294ace3e1f865fd285364052d426b3f947401750a91833c365d3930de2b3d3019724a687cec4729c40314c2935d42bd66a2841d1156fdf3a57c207e4d6fe4a7a83c750e8e9ae18efbb1b82c8adfe7ece28e654fe8cccb8f5ed53013f4adf30d26a97b3ba8158d1c161b8cd84f84230d0c1cd334dacf569e77b0a4077eb04a93b02721902a44a52eb34616f0a7227a74abc9e747769f1d4033b6ec8f7caedd8cc0ac0655983739c4dd9a3d3417cb1787b10332c1cd3e2da7a94bc983c685ac6b8098410cf1bf682d291b8f4f8c1b57f8d68a2ee8d6381eec38533ed61f1e54f4b41c932531bfebedb2b03bdb2c3a5e1b2cb8ac11e9b822fd247fbf88cd8f1ad022bf12fd1c9f1bdd7b8a1a519625498ab2b87493ade2443de44ccc6e11f20831c64c2fd3f687f4384fe291a78a7671e251254b18c613b24569555384825b552d8784e7d8c27343e4600d834010f191fae2b03de0779949fa79925f15d9348ae2563423dd4e06ed11af6dc526da74be8387d396aaeeba1b6c726040386fd929c29e69a62b641eff3556bad30ce6ee4a6e1943d2d77585507124829b59de4f0e22f255dfdb7241379d9d5f03dbff097daf2533e1fe81db929e77a435dde0b9311bf3d181d6d54d15d100c030a2e25ab94012082d6727ff54edf2a32851ac5a34a4dcb207ade85b1805c4539229c4f6341f8a163f8c6cc58cbbd0527d15496cf2a5d15f5f5247138b4b7bf7e2a6f07bd6d2d6c4f8981b71932f4c5df14be7372600418a8510b61e7794efda9c4163eec47a2f90060470b7c653d19f3ea29cf923bf4d24a0d045b4173ac9b016db5150d060ff7fb012260bcabcbae28f62719d4367e2bc0f7df86e7306bf82ef234b53fd1af16b4c020260541a31f784a05de16f569e6fc5f08e03cfc8e5d68c8dfa66b6bb0f21fd1b30235eb426af15a6b7cddf20bd19ea4a3feb50cc27adeed17aa01e96be71ac93d4e19ee59788fa8e8cc95fecdbbb139cfb84b61bab583d0c2ff52be79436b734e01b21215e16c97d1ff8cf4705035e283db02c0c972da7c2a2a338b0d499caab6c1d622ad33240b5b9a87bb61df46e11a8d9565e24d04f03c45b08ac107e1c90fd87d5237f81196a0053700cb34e52749b170fff547b072459cadf9d0b1ee474564251f0d03baef150b4ee6db7b974c2733da9dd670d02fbbc0c04ecca39439d91d10d9b0133cf19a1041d39dd790a0da43ba66697743bc27082c769742f5fbdb4750108b2300828102bc5d02b1ca307ededebd8b3a3adf5d407dd0c9e41cb294ec26f334aaaded03c7e5512c46e2c1cd482dabbff888afe36326113703c074ea20b0e0a0ff485d21768abeb56c70fa8c2bbf27da8834c7bc3f7541930f995c5394bbdddcc96bcb9fa285c474f0661b4199c6782819f20cbec7fe099779d9a64e647547d3950634f433ab56ebe4aec96653ed9e066063ac4e178c9144a952797b8e310d075cb84998262ba2d99290f122f7fab0ffd63e17aa588260d2936a6646f5cfb87905b67b6028046a0973b890fa572f419510c4b98d5205966efdaf81f9d8f98d0d8b6d25aca1189ad1b18bcd852f0aaa0715afe438755f66c05ed2fe54246ebfe0566cc1117778745544897fecf3406441b119d1fc701445d73b8ea70bf01a91e9b1daee823faf24eedccaa21f5d1dda0019a481f0595f7d8a12c1c694004dddcc61703464b4dbfa9872dd2597936be9cdefd2ef8988a39e99d9ac273d8a4b4e22868c4d9d6d19b7d397913a04dc6e848624bb7135c3e709709466de524582e6230b891874ac7f65f1226c27662948c7aa11751017686fea9694e60c5718c449968c6d62c854dadb1e4023b14f3d2d890121bdf3b011feb57c844781d028dd642c54300ee301e03548ba37c64e07ef90d65946348078d187f1fc2b8523b9e4dc4d00beb8d612c8330ae586faceadbfe4ee7cb8662d80968d0197a9b379b6d2391a7f0f81d1c9a4f63c5e61bc3e1ece24602cf458e3231eff7ffbf8dd56a06d2a0ad7a359d0debb825e78e4bb33e5c5a6dcd29e2b6571230cd6c6402643ca2f4d9796f788ab624289d31ca7acee7d942f246ee7205cfc630cb5bd13bfb8409faa3ce309b436b964f05a8637deafb387980462dcdd75c9e317e1c319ec51853b8cb20eaadc433982083f7037911d4b66b9f411077cb44af481dd335cd3d221cd96077c04b81c3fe7c9d66808c846afa0c66b76fdd5cd293a1aa0cc769d91806c42359e765c6fe53660c609393acdcbdc66e28b95474920969964cc2457a890b37c52c08e020bd09e177cb27bbbfb41de614a89633df6d9054decde62afe7c761e83a4744066dcd07f771e01f1109e11a550d967eaff862638922fcb38634c39222f0bf767e40b7003cf4ed66849486ae326f3a5f3aa022614f4e50b3b5cf458a8ffd0a4d3c3ac2ce2903a05e30a497e0a821bc8b1c2e48324d5c002b010a68644ec758bbb79798c0ea7b7f8a2e8197456853b944b792f906b6b20fd22c4e7a527a8760a83d766b189c198f3ce772b50cef8de5727daae60cfb945679bb331d1c5eeec54a9161d7359bfc64bebf50452534647c0bf01b2c50735c0de076ff5886bf6b453c51c581f6d27db107f297807dfcec50c196966d129aa561b25e81f567c423d8b2274e61152e5c381879be2a6d5abae02543b1836ed4c182db61446490ccc071186676527dfb4ab51606011c93e5db67e13069f971dcb55c2e082cb32a867df3be19888fb155629746aa7f97db6806d1e39fa99183ac014543448c642ea37420aaa8a1966c2d3923ff5301afb6ea017b22c6bf2d2bd5730b7fe96249c99203afb3af7ba425129e02567ed4996bed954fb9143cb5d879562b947a8cac052b80e32aa17af52e125f64b4d33a50ce8ab1d0fd6bc73ec83af0c6825c4bdc5c0a6c2815a1fe81bb35ed22ee939c91b2f4abd6c01f94c2090cb32a941ec2a176ade97528d9d667130a257a306bfe381a3bbbce748a8c2620ab6162706faeb98eddda2d78990908319ba1164c77ea056f4f889902a8ef5bad89e1e752e7745f24918b84c993a2d685267250cff92ac2b2ef6f16533b192fbc065d42e354373b7d9de9a0395721879ec80d8938d367ffa98dfd65c37c86e39cde009d18d18acdc9f03797a2f11aeb416b5f4a36d039bb27bb07526f6c903776b7434c1750baca57d90fcef6b12b20cfb7cd517f9b03ef55757f8701209ec8966401401b5b5106005546c87b0d7739a5d3d2318a8a56f2e1983a5c93aeb9ea67910ff9f2292d7c98fcae7f761b39d5f284f6629323a1c336eadbb44c1ca01eece7ef83d76d439cfdae1207c5573efb2ea6e37e040554074c9bc712ee76c0bed74fd91f19ec4bcc21015f35ad8bc9d7321a8370f0644a4d17c8a9bd737bf5d2dbf49cb9fa599127274bec763ce5ac3d820233e02da9618842baf2b9cf7dfbd0f913463ad99f8e4ea6cceff0ee100c595fdd3c76d2b230052b84b6898c9640dda143568163ddd45ecb53b4714547b0da02b1fbbc1c99095abf6001a83c76e5a4517c89f2d6d9f2079a0d8be437bddd1267376b3219c095f1ae6f718e9a3738708fea5f90097299bfe6ea508b30a61e1a3544b17231a7d9d37f031879ce05d99ba2be293d1a80814b5a94a88c484421fc835450ed34310e30c7fbc9a95a0c22023491395d5bf63592b412e958dc24334e271cce7ef013c30bb9b53eadace4bc64c0b12eb1d9f513faa546c3dc860a7e79c9523e9b64d1cea095803c4efe3f113cc858a09f9bf99e8f68de38502e4815e0e3ada0fdea00012abe236f2985b3d413edb613c30d810f139635549c0225ce9dfa3090c8f48a6c4b6e283e25ff79021d54853072eb3f2335be3cc1ad3ef1c052a67b1dd4cc195b99f5ecd7dd2c22fc45c0b390d5bdb11312cac2708e273d6c8fa7482a5468803a622331f288c10325f4b877bbec8d85805e6e4b5bf7615edbbae7831b7f0dd71719774128b201d764a4c4e7242d7a5e74c8343fd2a438a4f515c392b1eb44f7d62f1ac5a48cc6e512b49ff5514f3534a32f2ea41d95d0ed56a6963f240114d2aa472aa72591de2dbd01e377a752b8cae8380ad4ff4c44ecb1f2019bb3cdfa98d314f9316a76f22d85f94e90b8217e392f22d64b19ebeb758e37ff46404227948c487b9d14be1c0ca4082f755d88689a8ab5fd5df7b91fca3c06c1c4839d916cc39cef4e5eb0fec5695b3a334122e5c9183cda545c9093837591919c3684237e57e845331c19fedab116b3584913707a4cc4b33f928216866b4ff458da206d18953b57b94ae0bfed547624c2860aff8b5065727f2d843cf6cf551b95bde39dd9a197c38d0a1751d7e87e0417d5af7efff0b1596fded7fda59d82b24f2bb3155eec3f51e0732a3f8c1bcfc0c93b2c812437f588d068fa18470d9047d44280f3e41b448c9fdfbe46b1d7037b60d586f7e1f34a7fa4f26093d9f1a1a8297ce787ef581177d7a70d1aeb75e4819c935860ae962ef2f1943321eccb49469095c6ae25d65a9b6fd5349a8d61d2de49c75e727917b7aa2342884b9550e4aa70739c23ed593e24f1733820d6750147ab85727868cf7a00e0dbe1d1c30eae328d6155fc8dbf1b22cac0ee709227b8aa233e315f62775aa39766886b91bc999bd70aca089740437082845f75c335ec8a4fb7d7bb3cc9d54a52701b03d2f1bf0be072eeb88110de7d79cc6d93291a838e543c8fe99053ba404887f4f9064114989e01e3ba92b1ee348b469717db4a7b6e4a7404df1128d0ec917bc1e51044795db30e35bfce4b701d9f7f1d9ffc37c15586fcea426b25163c27bb6d901fc149df83c6ffa69002c0e11056345bd9ed5688705c8b9008db8191a17cd6362197868ee566f476701bcfdda9343cb8655d49b14564cb87ae7c4345e3c35095d95d7184b0327c62ea44b66cebe671882ad11717681c11358add451c649eee7afb45f08fb879e3528a657a2aee8ebdba85f33759818ba46e9a4d19dd12ec501d38f2c046e996e25755c5627e842cece77036422774752dc6172c4acdcaf26301065a05bef37381ac4d17d03623c0dcac41aa018743c43ee346a40f3773023269d73f9532c3d81642f507127aa7a000efcddbc63bbd0db1c8061ba524ebf8d822b1bde665d77174ee27db00eb1f437a0ff36fd50cc6bd5b8d603daaee047599c4f83886fa987f8dc8ec8885ef357e341f07a62bba4ca1fbc8901d2bf7a2c1ec545d193dad6b3c06307e9dbd07b565d40cef207a338453267c30fe8957f488b3da7e45462ab2394d22f64006a4082c090cae05625392c6754846015396c0cb052e48b327f9ac8ce76f48756f7aa48e469924af3f1f2e33ce2f5b2213338d85a5c802e666a6470b571afbef5b8de9b07d5d3ce19e358381092dd7421343f2fa29fa72b6d14c7e627fd099dfc7d6494a16711869e6d32ac8dcc1f421f1ae574feb637f4679339e541829705f0141957a43e28c3b209ff2dfee44f583bc31feed85361d07bf38730a8019c5ae7d7e446560c3a96257095a8e9992ccdaad060b397e236011784f7c8f001d2d92939daff403becd9b0fbed05c55f847873a80b8b5ba97b3c115a9dbe6152995482ad3d7c415f985c0f7b779edcc83e7ef02f55a25b10253a74ab3d7edb0a52e49f3174cd86316dc67f5dd8b645a1a489d635016afe1d13c603d25fc8048fddb72cf1720b853fc1ed44453888826de0c4dd42a753a3c10431865772a7000792761e819cb4d2cad077de907680f889135e23d7860f2fce2596c95b21aece9b6d848ddf8d36e16c6bde86383243dd886b4769ad496a28231e18d2ff9f0e05cfd6259c38c7d8d5ca81411667ea12f13d2b1ad51a8c217eff08e20981c9cbac828a7953ede4530e248153af0014b401ff33190a7554372a4670f5dabdefbf235e317ca4729fb065f652833d9fa23e6ad8217f888490ea7e9d827b71353fc09be0d7183a59e7b1b07a91792aa8468671d0ee6d878317cf55f33c1b19385d3ef01a742798c20b06ba68e0b108c60852fa0188523e524a5867fcc958e67665abf0e1a3279167aacb9942c762d2a590e033ef42b724c01f3d86d7cdc4cc7d8fbcee5860592c9fdc9eb0280581fe2d1516256810243f11113c22d8926f6a0ac0a493e52d831ad1b3715aa566d27e120545f7d380304ec6740ef06472cbd544fc39f548534f0e2ea95bde5aa87d279f469dbac0074be86d5e5d7ef358ea7bd2bd7d62df2750411d4e02984b9ef935117898b3d1acfbcbdd265c65112b462df4fc87dfe8c452cb893a2afc4e14090a6c756ebc46d9c2ee3f96399ff6c6ec465f3722d7906b99fdcdd93e3dd1d24142d92ac1eabfbb03fad2f5907e63820a66e7b854cab13bf0379244dbb15df5aa367c892ebe6459670c7e529b61024ceec00eb6434ee4e380849293b1c7b71c7d4ab4860b511158f5127eac0b9e9552c2cb1b1db03f4f67c7c5db9228d4bb2b42c329dd0ceafc291bb9385c7b1630f6451cd0df236338ea6884b73fc4d3ee1b5f46654735e96ee3f2c42ed601f6c5a48fabb7b8015d960b98bc2800eda87368e5c8eb70649e89c9b42b795ab129740ec855e16ea9530e3b8a4efd76f8d4c09f4cf93177737f7f2646978723605c62a3f4f09695ed055935f07d89dc665e9f46dff0297254e1068a96490c17777fbb02965ab6eadfaaf58803f091f6dff2bf8c63ab7208b103ff029ef1f3cd9f0ed69362195d19d6089c7818bec2f8bb97026796f95ad916a9cab36d3973904a6fea5ac625a178e073fabd94edeb6f70f5a724e96291de5489362f4828e5d430eafbd538dfc166eca37996e03362bdef808ee257536268474bb5b6bef153d31a314b51a379f086939e9fe4b554e579b2fab1ada17510983a7c9d3bc5046aa8d9f1440018e56d76b0c7797bb185e5c9470faa34c2ad48a37154654d369a9fd0b12d09bd79720d8b091b77101a86b9b5bad1e5fdf89c5062a7d157a0ede81b217b59c2a796c6f728444c003b052e7abae06f66ba00cd8ee72878c5bb614fce2a0a750620c2128a57285071ebe190cfd8a4c08f80d30b81ede4be1c48bb202c44021053d53251badf41f127283c3f831d0822db8909c8796a3a4b9d11548517d64106273166fcfbe4ee0c010cb8f379d3bcbc7880db0bdbdcb4e6ad9cb2dba5692386fa2f31f5556fd5bd26cea7061dbe17ccf3b5a638f81e5556175c33c04a0e22e325bddb812200914c8a00230f156fdf8ce6e10164b69b173754b45195ce0d73329579a5019bb13a37ff8c4345afe5615792be8e99a331f5501a9401939e5adf4050ecd191c0c4a1e8de8433b8b8a7e26541b674ec9d381c486753ea1b59f962b7b6d536635cfb7dc74752b6f7ef3bd7acae0076f196d4d4c4bd83460ec76eeef7df60aaa64e51f7fd9340172a1ee43d9f3d7157a19bc9dc812a7d6b48505bdc2d954d69aca9131b87de8d824a600393c9776629f197f78edadaa3decbfe8b92a5203ca8ba3481d4ae3fbce4c8ab90c5b4cc882e188975d39e84696e7d53d9afab450f69eb28b847c5ae95fa18cd3b725ef9b229c2493c6a550895734d1e7030c5e70b598172e0261d4c1c365796f71d826da388ec2c95ef61cb3e70317165ce1eb70f545d53bd97e806683927acf69357aceb9227d5f0f073e36c63ab16df44b308d69f7df134caa89e9e9d57c0798dccd3132e48abfe6beddfa4621fd2c0ef2cca01a72e961f331f417f8cac269d14d7555e43101b99697bf2a35c6958c54ee1623b7b303e93e489846ee6d67c4bcc7a188df1ccdbe938e9e4e18f4f5010dad215d458d6638516abd96c85e069c6b7462565daea923f025b86f8a172af3074f706b04300ace956238609d04ea8181f1d97c03aded9e4e0054a56e772899a189f92f691a622ed243ff74d7e479ec70856bfdfbcb43cc024072d1406bf384a933ed334f48a5b922e073ca661badc72b1f726842f083ee1b94dc450679bb92ca8fb1b3fe9e7cfde4f8d8e3d832c763730e1e79062e7fcaab9431d506e936a5d1678f7961744ceb40d3c4e08f6666b5aa1b670cc9985a06c3ebdd1b699ed4f662188a5c3d18e8c7c3a174f11411fbe6b3d551634d81b919cf9835042ccb191cc319b9fef7f89c26de5a2318ec342e5f43c68851987d67394b90390e986de32f5e3c4df34d3bdb0c9c7738a30c39dbe63a49fcc0f0f7e62cfde7f39e8ee3bb7affb8703d1fccef9ff6a322d23e919ad91752f89abe932478e989b429fc28b47f3327bd9977a461488426b73d201c2549288f66114486d58e07eeab4c34840e37c2368f5f6ee429f759fa03451ad954d046416fc854ebecd95bed95a0a8fc1eec7286195e97605a188500a4378565b0fbfb681ce63b33867829d8302c274322eed8ff2b8570444d94a5b18363f1411d57b310995d045c422d952e761c31a2d1681acc64e3fef6aac8bede7b8857363597b8b2b3273120c7c470d3438a1fef9d593ff3fb9f19e4d12a9dedf17fb12e5451dfaccfb4efb281b89de1409fb99fe1c9fec59e2810eb66357fdacd5979ecbdbf60cca2e722bcdd30b84d652e3e356af19806676b2d86355dbe6a68e1a71640cfe4803bac2759e68ee984b37f5aeb9ee6a678d7cfff3e2eef0c913010949402af999b641e1dbe8a1f7991fb5710a78ab542e14e9ad86e50d2f62548bf11720bd0db1ad0767cc53cb33ecafc748ef53c7d5a03d6ec28bb2beeed63eeecacfb27f5f3b47393d348ff2e8642466c8541a32e97a0f0e30a187aaaa957695379d24470c2f6d5596d8853a4f53e0f97a9d92b7c1e86664ea5068a7ab004a88d25832c7770ea941c916619b204aab5c408ca9faee9fea0bde4b7b31eb3095fc54c1165a0f0263ecb8c93fd72874adfa239e01ed1d68fe71b103b60d7b85fe79573d0834e9fd09a52bc3cbb48471a2da38126555f9af6ff6d1106c4bcb81537e77e74467080eb8d97a4e807752f45425025416d03b8debb6eb633d8529b9b8abccc2a317977bac8135427cd83f233d353059314533269871c3e6634fdec679bc29d8d3f04cc455b1ac702ad5a64574064b4ea7dc109f5959161d724570a3fe0a689e1d61814dd11842dbdf66f9cb924491cb115b3735799e0afb2269c195c0c9c5180e91779bf884f7dd918dcaf8bf80f6bd8e395fc01a6e933fa3de9ca3e2a04d92ba966788038a1209f8c0f3f25a30e569fdfa38b1928abf989485bd08e7838cad071bdd8c7a997d6c1ec1785517f3a49b79bb22862384ac58c3392a9aad15940d0049bd28d76d0de4611a0abd284e531e88b79f55ff9c00a7717c5c4424c85d3ea2ade736291b4a5c902e331a7c92adc99e602326baada887482d01a5a83c9fa0c3ad8216b2215cb760bddf90b2ad92763eb97bec8172032492de25e421df18b7b681a037e25000a86e6bc3850139971989841850f90a6858ffb3f882e9246614b89cf462ef0729b3c72eefd0d4ca065a45a7fecb062ab94bbf1a8016acba7d65ad38abe42a742f2b24bfd6e57148983f43cb17bb1a8c5ddb314d513f6291ef123748fc3a9da0ecb5727b977f441986ba93936d92f88b2330a72f74fed56b4bce316440c02eb130c147db0d5681174df4287f2853d338d0797e445dbb10c651858f26d96be3dc9017573ed18b60a210b92dfc2c16e45d4b72c987563c1da8553ff34de0483512876c011ce046b066b9b2c0d72a968674d02c90ab504fd8fc99c4156dd0c37d3137fd4b9ceb2d308f10c7079ca27d45cd76ead24187b24cdb8b6472e5a49de0a29f4ec22d7e01cc06efa6d9cb0e5b4ff407db5c2b9b9696828596ee030f4492c52db59fbcde4a61cd183055f1c3a38f964854038ce092e950cf6e1f3720cf0d6eabb484bbf5e75a9cc7be8f17b50b6ca9ae8385270f14e3fb482240e827cc172aff689462bbb86422b752fe406522773c5cf5e255aea5be3fca11e5cec0ba302f0ed914361a0ef8a95fe994152be570de71bae31e817db4f9467ef55f70b723ae4f70303931f88ae439a766785e3b994c37659d9387e5906ab9452c1ba7821d45052ba14a7ee3ab6a6eaf2aeaadd6d9c51c47bddd1a20569dd413b4848fe1812dc535c467de59856a5cee2104d4403c75dc3a330194f6b0a601ce6e6af5c53c4e4471319c4eeb72d3b9d9fc8d190e49807842b1c3f1fabaff1cb5f4111461c45facf0024bdd66281ddea04df89e52077149c70b4d598cf89cfee08028e62953f5156ccd28c473d74546d59505e0cb8f578aeb646702defc5cb9cb3a683ec8392586cb808dc30a2e7d35012f7131838a2639d1a42a1103c013b0fbd436f305313bdf2a44e06323150c21eebfb22d88a00bb6caeebef54d57ece6b6462c9b83acf9d538b6e828fa6d962a408d7ca2c9aa923acdef6fe4216ed45aba0404b2341d8563ed6e5620427579d075e82ff12b6c52208afe0f69b8d0cc6bc29f287327b71a5ab1a239e4b32ad640ffe61b1232e8727e382eac94d23a25c7bb0e78bb1b3f292ba0616d6dfa9dde01f4f4eb66b3a177ef0264f538b23c81a4ee292eb912c80643eb66777a713d19c35b143b9f1a274b38f470a73ed76eb7f06fcffbaecea8b6d3f8be1fe518d033c911be0da189fa7eee9db61d1299b277961b6f6586ec4c02b58400c5d21edf56bc315f3a1c4acfe02a6dedba6ba18362311c2fb123c9ba8bbedc6ad1bd2f0c3a10255fc3c1e328539c93970ea2eae0badcb63767be7db2a023c76cb6831b96955c619a702f07ecd59fce20e8b5181ffd2994a20e43acedfa231ed308befcaa6bdaebb478601def9d198aa2db6aa74f0d25823361b3b778561a9dd0be42f534a79f8892e59e67baa52f84f4f114b15a1527874d54f0c030fcf3c811d2d249453f93800e8fcecb6038e3c4b6cb267bcdec80b4ae75ecf48b560adf39eaa21aed8a43287969ed48104bbfdea856ed490dc429ffa21d697707555eb1c02edf50c6b89c2d3697e80aec6ad2c67df8da93bba7f61de0ff06358873fc12f11b341eee4fcd2c0dc6b148f159e8c94835ae1562a4313603602f6d568b1c347e81d4983f222ca4cc41aaa85e4f7342565f533844913c413f317c220ae7030e977bb24236afc56eea7e10c49eaf91c1f812f66f3a7ca22b0f63bc2fea0ea803bffc64ad1e214b316a4dff3ececb93da9faa7947c999a37364d96733eeebb4b3f353323524e5893f21f8dab14ce9d8da91451e8bbe02e14a0fe043319f3513a5e7eabc889956be402bb377a7c90f30a2b0aca153627c1b7aa712ade7fb167fe0fca343e07e25cf725f466ba0e64045188c87ca73218a63527f4c65d5ee26a27dd94c92c42ba0ddb0aeed26cde0a01153b22632275600fe5e9526e4e2e980a493f93686a3fc37a6540ee0db1d29107ed2a633b6067d924ca9c7ad75b141e359e3cd52a434663d708a0ca52f8679f17dcbc395e2e18942f04d6dcefcadb25b06e0a7015932a589fc72c21aa0226a15f062d230383294d01793a60ce62bbf2b46f97565d2fb6052b2ac54ab3a35e1cffe0c5aa2f561ee7198941eb0d63905f7afed54947fe906bcb8c565ffb12a495d598508f346a7a41e517490be33a495c09eda3348cb829cc0844a255d0a4a99f644c6f0c0a89e2f61a66fa04f5aeff3590920bbd55010ab4cec659aeb0575a6a7b031d4efe7b3d68dcc734a29c151f2d5a122325f951ece209a15d6de0a8b546be1aafd35d781cc889acc9e03621a8cd7b0ec70ead00f3882e0ecd50d1293c2a5f35ab23fed5e8550f6425d9f55fcb99e9961757455bab0fb1ea6134ff885dababa5d4bd00427c8e456d9f915d7c218328301cc3fefb7888368301be11a9ccd3b958e52a85e1cafd0172916b2d53bde7e1faf9c443a18bf059610cc80458f4edf9b578f82be9d448f3e26604c743d4d8565cedb82af4479726483cd4d9e9129d539202f5c8ee8d1b51b913a06d64bb3de281411ce94b000812dbaa957cb5b7de4fe1ab745ccad3d50dcb75c39f9fde609e38167def8d3a5c893bbdc3bf34a27ee4ed7208a8dbcdcc375c3f453ff35c74644bb338949bf7750e161b9fabcb52175f10521f051571d1b7a5a07c78f6301621df4edd940deade6b7018db4ed187f618f696a61bbdfbcce5e92e6ece905e0b875aada4c67965f73d02c0108c61e394a31a86bf7a82f4f41bf62e9d002c7149143dd099d884bd2f6b5a1f5a7e7b46596e85ecf02afd9974c1811980839561e21f38da9c7c809b302ca72682ab3a820d8f2de0e87d574a5b120a8a7ce5dff0a01fb792cc014836ab6b2aca504073816d359917366ef341803d740bfd8b51ff5d45a2519e51ebeb0e338aed95129c7a565d4acb1060925a2c7dc1f4ba797904e843bb569739543f6d348ef22c66ffa06d1c0fe64fb1fba07289d42d9b0765a48bfeb21e3f23faa1245662e57feea7ac3841d85f616e06cf5f99713667e36d3b5184e476d43b48611825592e579f606e05c85dddec003d1890d76f5cfaf82f66b2ead80114d90b1353dd3752b722bcd3f1a7b3645792a546b387d38d1eb96933b0e33a0b35b9d40b36671905ad67d69fad123539fbc770522a3876acbbdc24627460473bf45eccb995d93a7b23568729dce3251e4437f5259bcd87e6da4793138b6bb4abb0b4e6c08b680b9755cb5fb2829d895038bd06f8198580bf9bb223a94893275dbf9a691f40a01a26bd15ee3ecdb18626657a37c507a98a429dadd28a60811b2d61a51f9c5e5ad687bc61128a8cd6edbf896e84be1893c29eba10b41066549ab4402ff20ed32c8f7cec74b279aa0ea6a5ebad39847868236632b2a0817b88d1376e3571fc1dd6f713bf8355fb3986c1070a9c3848231fcc6a21b56f62d1fd2d52e47eb12fbeb3ff045557cbaf74e379c8a7060d4fc83263664a0bdf25d35190d31a04114e48b3d0af840e277813914ac7d08472960bd5e79117a783cb6fccf0e14fdfc99e10af562813be1994fb7325498fa2cf3bb64587530d0536a108e2d6b2ea42b65cbccd5b802def60f5cb07c2138f99fa5c349978097dd6db5e16a9d78665b6d778195c00719d14eca1a828730aebc2a77a454345b490c8a9d48dc9e79b742f56d5c7cc3bc1fc5fd1409c0766c66fd6aa38ab333e97df31d27e7c1bdac3fd875fbbdabfe78a7152ce8516edfe20b7fd8b0c0888aa015f33e1ff4a62cbd36293d11167173ff6ea7a6ed832ce46cddc3d45c2049435168b3e1d74fbf9a9ce7470e3fae22e3eafb15eb579b6ae6677942db9bcda5a6d15cfd4b5fd2e2b7aa6e802cacea50f108c7c34b36d190997799775aeab850d9f624476ec2bfeabf6c84eff21bde157a99c3df4975c0ea3ba361c2540ad8bab05e888b9a87424dd24595d550a1074e60511a21f8ff3920688acf9e1348663e2dc621fe281c04a888e89f3e992f444db71c8fe5623d1546c5b867e5f6655b8c50678d84d7dbebc559d1a0a02364a5bf328c34f2d456c960e434800b4517dffaa76ac88b9a2aee0d345c4989501215322b3ecbad7c088299da02ce68ce26d7ff73f742c272c8dc560346b4ec8f5a828be86935701a76654412ad9339adadb41e1031f10a6cf31423a91f97b626f42e9cbafdb32d5a37d2bdfe53bd91fd306d65db6d47136f8497f8fe8cdef2cd7b05840b468915742ed296beaaae9980ff04fa336581472f2db0024807c8ccd4fac5afeea91ff02d08df84a47a6ef20c761f1c54ee22452cdeca0279eda3e0959441e02f69e49a7fb5a0735dfe4e99284914939596d772b923b8eb05f2885e82e756298c6086cb6490114c8cb3e340cd97343968883ffcd36071d364493591b3813160c3b74662e5b09361bfa287acc414f0393415a8a498d222ca540f5c12906f417be5eb5469bb9a124f21eb3fbe4df30a5724141bea8d0779dcb8bc9ac24e62bb8b9a2ff95d63730fc4406eec6142003ccbe9ad87a854ff7140bd3de9860e276b9f36f71e56c313b242a1c46ac1d53e95c63aef1cf5bf889c57a81b849b35f9e4aa4a351052863752d9017ebaf9e365c9937090c5df27c9f1eedeab1875aec7e4d0d6928abca175d81751393c81c9f60909c611cdd2b1620c61fe3b994fd47b875745dbb780a55169497165b024189ecc5f9c44d20aa9991c720c90073b55c833c02deeaac2f33614ba9cc6b1b92ccef98f4800332929697709b2aada98a5b475d7344bc91975a2d2ad781a416d4dddb524c455f13d6dd63709a00137e1a1158ed5c583892dbfa5bb30c347b17883a39b3101cac6160268c201640d667c8832976298d1a5151aad39a7918b97087a7e14398c7038aa293cfc766d958aa9ad36c5475cda31c1cb1f835f2c99e1b17a03d1122ae4064000590eda75cb3db131ed3287d6ebd7638407aa7add5a76ec3660469964ca3b00e293c6f662438a22b8487273cc6f7fe8bc1c353bb351168268354c77e51a497daf20f0428d81dcaf6fd3a8705182c303be20f8998bd2544a4fa1d8885d0092085e88580e4d1245093b5554ac267c2a3691d649b99991c7788a15fa0eb4486cb6cff65ca5a91d2f7f8de975ea1b697fb73f98a0e505d8b908e2b236ba40bacaddf4b19040d2f1494666378b7969f51ebb587dc9a62677944ea9dda4fa063cfefcdd90473225857454392e6c5cc7f5ba957dad0294c9230f6c01602aa5b3763f72011b89431adbbcdd1af341c97ff20a0d92c4064eba8711ddfc382e8e09141f6dd33b20c50a729f3cada47c16543f2ca5c32c3aee42979707ce144e053de26d786dd51fed2c0330a5b41158ea1db390e2f54cea6bb9c1dee63f8451849c849e4bf2cd19d2369c9706e542e48d2aaa3594bf50388432e67e7930b9b9850b61b9ebff989daa6d301386567869670c0b47cf84d3e2f79a71eb976d7c9ce42ef4b276ff6836a0e7adff86e8406a088839f1a749618a1aa9cb17e43fc1e5f6277fbcb67e73c5e02b725e972dc57ad4256eae4b1375d59fdacf16bef9d8a120f930e66b7be37b6eb6282125626f3b38891daf1cfed4e756711e8e20324a2f58e9f7933a3b1539a56697918fe8ff3155347126db1b23fb29ed17c785983f797f5f8d2b3b17c5991bdde761b33f1fbce712acf6c7d70189bc6e1c6869579851cd8ba89ab2c4ec6c3be95e2bf87bbd6e11e5b58b33c02eb68eafb9045c4d07d048af9380fa2e0164d1f43f9314dca14fa6f13cefd2a1bfffac47f957735e69335e87fa5e9966f597094794f5e35d5ca0ffe32a3c282be20a6ab42ab1f3e11e4a7479811d9fbd0aeb8efce91887bd961f314bbf02f2085eb6d5ccceac31db3ff33e2191fd514d658ca26bfcb7c2eaf0726ccf014e7abf4bd849dc7c08ae34e73ee738a3b18009214d323c7bcd870b39cd0c4e5ff85d8ed8360f17d8b52477a94f13ec27c0145ee22f2e89cdd997962b4771b55a98279d0109b7a03276012966f647c7dd7fefb6b136b7ae5ae39b70bc8306b3b15d0a801c5bf85dedc7448b4ab33acf1fbe4c788f898d74320490baf33784ab6ab120f85fccb9a797875be42c1a4973816fa0ba8990fb814e3565f1b3834d137fc9d66144518cc6f0a0c653f9704354ce3d10c3a420974f6298c19f624f3d9c019bc98d8bad75310ee6097e034084c4676fc324007a3cf672f8f7b501f0114b573950769bc65cd26568fe838663e1db6b8bd45b52ab72f189df30eb0e5e890b1fe549c8d88eeeca79d980cac0247d19930be737f8544887403e6e7d5eb096cabf85263bbb0512c309ad820998c39939b72afbeb6c50916761ab285e392e577f12c84717f12a88a82ffbbbf015000e74aa9d0ae7d5613cd58bfdfd350ace5cc6bdacfd29742ab918afba6ffab95061805dd8ecb856a5d32ad70cb00c51a52e1fa511e74de77b77cb4a06aec7abda3a74966736a8d690a25d4fe521fc1abcf68172401ab6ed388ab9ad66eaa54dc8bc198a0bf3fc853d649f8f39637cfb165652c879c9bac2272a89751c2e6024096a5dade904df062a972ed1340b8fe01f071f766c085551c7a082c0c3b861541773a5a5b1a29d4845b4347d193660226c3a51730d4f5a81677d1a6966c52681741a4c3ef157ae195b7ffc79f26c67ae2d089959d8b3670bc2dc59004286f919ea8d4364e22335f8697448efa3a5d2be6084a93a94e76755503491975919eff8acc66e996451abe9b76e840a0cef6a9cc95800bbf2772e2fc657a0283dce92ea3f06d543a9d7194da010b2caff067bc969c82b4428693c5a530bbb899321b3c09e1d8f01c428608ae83d1e35f88a7d73690a3578121bec9d15c5494c4a01732ed2aa24fbd94f4d2a43b91afb4291f35b161e3b6eb0ac369e7f38ab7a6d26e9a0a262ab57e00d69ebe72d5ed756acbe71602975e47d0d533f79162bc07d57fe7a4f9b5dcfd61cdc2bbc17884227bb4d8af143298f3d2e0705318a72e29341367b9acde42817995ab20fbad0a17fbf9ab5530d7237f1813aa66cb6a1b8c73e39312ea5fd79cb8217615122f7e6550bf32847c558fc83a224315bbf3ede202f89f4d3187ebf987af607a3dac29678d71d1f6ad0f8310e346685e6f72b0b0dd4e5eb188fbd7ed3508944f201fa64b4fbd35f46f631a9400fc765e295c8dc21fb73b2be905d2e0812226a2b65cc597445325e4949df12f3a4f198b05029c068b1e405e55c01a1888088cebb2d4062e1b0eeefe93966ec9b0cd42bc879df7e0fb2564559cfe6417bd543c77ae119cac8a92227ac7ea06c4651df57b2df0cc0a550130bd73879b025915f12ce38bce91852cb97edb271f9ca40cd0a7b5a71a6fe44c4e3cc554747ce1c3e0745a89da5ad794b0a43f2db5c9fffae6f1b639af291d90c9baaffa69ac71674f4f4c37a030b0dcebd645a510e6c85d9d03653381790a050bbdd871fce2cd6c88db0d54e65fd8eecd930e65ccbd24043f730445ea741ad5a8b86c8d1d8c6e4e8dff1e281a74c1dcde2ff60e684e20ab07507d3a738d7bc4bc8a8bf0c279005341957f17839ec12c5313a60c9e3c846609cff29b4b4e3e8c689c46003bfd8cddca5af12605f57b450657753122e4d86db100e4eb3415023ed5938e49f7f048e37fb78a5ceabc4e3a3247fc888f152302f8e40c348337f9a38420abd9036f175a5f6988d02a7e661ddf93713c8df578ab277abae841f9572320b58357b1133f373a5611373afafb83ba175350b19071b9ba2afee75cf5ef798aa38da6129eaa31a269093b48e44961bf6763e178c6719e39f90ab9a5f47253cacae8b56b2c7779c398da903f597f315699a5cc5de432f497bbe7df82fd03c4ea4a5ed9ba72e137b40f7f6e178d564067036d69d46ffe0d1571767809e11dfc15e3851a164f88faa3e4ae7eb3d56fdaa749deae3ed7a5b5ca484e04fc102a9abd212dbd3faae58a7ed3ed12809b66a6250670cbd2deb277d69951c6d054634be1736ad16ebfda6a168d3b29f021b7db81a61607d6396bf39abecc7b5cf595b83891b96e0517fe6bb2be3f19895cc294c10fda35f047808a8b9c5b96503812da4e855122e523d9eef8695cb0d8b480ed232cbd7e4d9396715e68e979eb3b03a30dc8b684bc498867b98536b7f1845d26054e670de4c67983d0bde42ef2af41c55ec173afc6a310d920195d5f1a0f2ef1ac35d0b8eaaa80b6f5c2673ed304a66480a208b51483e716d56dd3c3ce35528a346e65a01c9eb52ad24390ba776b137c12ec69d829c202a4b90704f49fff454a2aad3b9edb671ef1654835c97064fdb5d8e6ab2142b5e26e07e4462907d101aa029d96711b7c0a72b5441b7f83a13245a28eb4918cc882b94560d00f228651aa5a5f7875ef61f59edf961d55dea18bced332f2b5b8adc635546a121fb2465deccb891f63208c58c5dc2a28cabf8cd5a86627e5c601dbb139c2dd8c1ea358751836a8c51c4a86f986f09387a5b155a9a940ebae7e051d89818dd8411ef350cc48a30771a64280728ceddea4f216ce710be251142594dff917973ebe06d4901590e016f944318266242b4fe4ec784b78ff8435981b0b745e53d177b7b11931f5f8c7a9d3b8e87d55d15ad9a4ee91610c035f306d4c4c423d4be59d8d43d8668bdebfff1cee9b163270f1fdd9a07c7892b38c89c85dbaf62a80ffd818818b9b53f855d443380446178131b4191a19eb33e37636b6a7f2f98528ad71fa2aa76eda5db922f3bf090b401081ec09aeca71ef57857c084758f398c0a08d04d89471429aa3649c3c381ca9f163deca45ba8de358af8929c8eba2097d0d0062230fbab0f02226d828634703e079a47c912008ae44dde75272969333b97160bb60cb8445d5ed09dcef40d45c78da1344ca85f1612db9d09c10d8615b9feac43395f65c13001e0e53a3d7a5a56f31c92c722805c9cd1f5bb531f55a4e85ae69dcf37559e634fa64f370e3e65df50b7e234e3c1ae0e3f1bb2334800a64cc0b53ec11d44cecf6575fddc676aa6ab5de358e3372d52b290d1d6b8b8a42e4dabc01b99ad466df853007cb328694880e4e2111da5811d429f5e5962e1b4b3fefe4bd439758102ae62c73540bf8b37d2bbd4d2bc45d1e933e6d8beb6cb84bd9d7b716a8bf2bf8c2c38ff69486289b2feac2010927765ab7b322987773e7b6fa10f8cbfc4981346aee66aa6b4b521ecca8d732a100a70691cb84514aec7a5748670d4880dadaae83c3139aba188484e76733427452a435c5da25f0b82221f6b118407b06eb252a064bf9b4b3c98411777b4139d6569a6dd00d3afe6c290a127ef90f59e75f04baa5f388edf0681cb9c94b38fd660f10d7e8833b228e639fdb25e62c757abb934bf2c4456d31f2105951255734e2d6338ec2cffae4054dc4548f04dffa98839bc727adfe6786476ab41f42e12131e06bea70df0b711bbc2a0d725c8d05212e54210238db317f7437930c75b583c91f2896f748378e875875c70c749d8d5e48e80cc655d120d11e3b6b9a451700534afca9be77014ffee087bd134c24307b5869d2c7fa019270ec09f2f62797caa4cfb27ba9d96c90c915e596e2f32791ed0425e3493a99ca41d7420c24da80e741037288694afb21029d3fcc9cf838e47c6ddd8dd4a7fc0887f3094182a9228929d2d5ff568570352ec02c512f5e6d5996d7bab095ec576f81524e030069b7be68686bdaf6c55d3021bb56bf8b2a893bfe42a2685305efd00181b31faff069fd9e4df9e5896184d85307f98a63261066cfb60b2da2172e5240d83cdc3f5d091f19bb993e11ea56fa5cd2451565963d6d4afbdd39adc8d730ce00645a4ccb6beb2e0797d08e9d05046701b5d550b10bc73f0bddb4b07c6a9abe1624f265b4bfd1129b5b04d0d5e0fa25dc109070d2caf1eed7169cb9d8b23594267d2e61b4d940ef961a0bf710dd8c6ef6e0ecb0cbc0a7b137ff6b065cb169c7748bdb25f8620ea07d834defaab4ad1520b04a658efe5e3e9ef1358393e11218bbc15264d0bfa11691ed75789596fe4e5dd40a0e82385ccfa9a428233acf39dd77059054fa4feb45df5bda1ab48c85fbadb9cb376eddc35e41e892f2c89122d92ab577dc90c525b7558d1a9adaef5342496b5fc95d230ff0de0ecf9568598e8fc5642bec41f39dc37c83fa6293c0faa5ec2505928c0b6b06b7fb5a31edea1599fa6d4b2fe138af47af61849cc89bb88a43770ae7db08a1fed5a08b6d625e73db63f45737d4b79af3888d9721634f9e6684293c9240fb5845ecb7025b88dd2a4cbf4121b850628eff736ec1391d3e7a16634ef2ff8261e781e722814abb26727a84af2b9b080be32cc6140c3ebd396f59c3ac3e9ae3eaedf974e465cdd02da17a74d1a1971234313330bc129779fce29acb510678f72ceb694786d9b480ccf19b8c647c6638beafa4558d21eaab29d0822266f7a5827de461ed39e3ef78fbd3819c6249fad879969b7ca0d745c6b30b95471141a1b20cdd29cc6aeb7cda8d9cd2e7e221059da3a80591d6cf5ecccd48878f6c99430233704ce241a82c4c842c6200ea45789a927df3e1144b814a5ae9ea5e2ef4550b5f94b4c4dfe79c66a1f382a6fc8b015f7039337cee7f730c9bc45cf2c7daf8b95384620e32a00e44cc330de3da61fa0bd1533f2e69317266cc13858b0d4c7e5b1492eb538f27fa936e10e0e0efbd27ebc6e3aaeda09d5305ddfc60d0eefb84b686a310c5822a0f771b833e31936f19a3b8c8a56bc828587feaafe18726c49ab1b51d1fc6a0abbf800913022343b49a364f8bcbfc86f7573520e7348e80375cd3b9863e2cb7d39826d345a1e1099f0c1579663e3d9bdac0ba1c341b94bad56f5158ea3fa061772b5ec2185d47eb7d4f4a40aabca25b08630c7b2469059fc122dfedea5ec2a0b03e3df497c6cf9ab19faef952776c71fa20d4382620623f50343c3a948e6d2c8511357fc1ec7e5f135dfaa86fe5d43d83d5dd4fa87bd6c1c2e9e2ab01de08fe03b85f0482628d70cae99776799fab46e2cb17f34df72cea31a2fd636df99e872069526603c1620b13666f8c5725376b5e7d54d066d4e50749ea14000b24a28e78c28e0c90e819d9729de945b19eb253f79a4ea7469aedb7aab4632615445c1bbdd01b65f12c49a321e5c21bb9b932632c981c4f038e2d7672214049a849c9030fd2adba6b645c8e81615fa6c611f677a07fcacaf6b9a637e40818c2b2c169ea82919c5cf30090e185e39ce9585b0e3d0c7b19d95bf59f317ec4b5aa28e40e2e8bc1c94e10319a586236f89ecb13aaa42d3b04f95d86da50aee8d434df875b08dd087e2f4e34089864eb34219c356b6efa7d56f860d3c133049d1dadc1fdefcb4cf73daead0ff5a0a0fd9f6506789dd961a9530c1d91bafd433314bc007feca72449586832d437c685012914b2fe24e467ff8c26c3c6df9b59a28a5c9e83f9cb3e0a4e8d9de7fc489544afe0e54ad14ad2d2cb05ddb522c457902d403353b0d7b5bea5d94bdbf1747606cbeda2c1f621e9870f25d2bc0b9585a5e8b4cacc9df1250896e89e142a57a7371fe1c518a6f9fd93f57221f26699fd433d1d345a000d4d8aa97bee2531d87dcaa9778ec1460d7f51069993e437306d0fbc36cf7322d321fc2a502237c585620e341207431cba07fd5b24e9a11e9e7fd52b6de1ed1eb77b6a1f326e55a55e3cbca21bb782341344dc0e331e9131e84a1dd589af3365e5fe89d86fd446af8a3f8b403d8b679b4b039ca5c8af01c75ede976e063cf9f33a105c0d5bf8e7d95124887940d0c03615e22ea25c1fd27ab6e038f601398f2992adf4aef883be5071f6c8030cb5451b77ce0bb1577a57d7f4ab1daca25710b7b1bab23f17d66806de1e933a67a5ac49d6520835a08d65cd23f25aaccc88672d1d84750bad3b5b6ccb9b4a9db5fa96481c378c2f5046368b7f21cc64255549a8dc263123c82e1676802698617466f08f505b610ea754fadeba974e4a4fc67626a9e2ba2e92705057abfe68aaf74f21bd32385ddc94eede7abd6b69fda70be2358c036b9b56882f527aef231d19c3df33f699f9c105f1352a319430e9ea4ce71f9d4187b018605b2f8d38dd08ce6c1b5f22f7bb1b60b50daa611821f224e43447052fcf12a61352a208cfc02a89570c78ab0c29ff474d5e3067ef62b5cd3e3c6d740fb09432eb1e068e55cb76b3385181174dbe9d4ac9e91277ac40af09b82c72bf47d9061e3dfc4f66e8b1282b75e2b93d542468bfec2a2905e7f906c6cf8051238df85a9481468ef9e54707eb5ccd1241f0617ccfde8197e17716f3aa4277457aa5ca83ba7249c2a1687ccd142402dd8a034ca7324a01000d8ccb4f3ebb09afd49a62fed8e088ef0c9c1cf6079abce95cf6479131b24ddac02a8364bd7f0cfc74e1e2f11c8ac5f99fbd2f236df778add01e9dc241f600eedf9ae2c2784cdbb3b4aa6bb317f2c5334c304b1bddac288878b77b0e92b0223da6c2e59f35f59a40478db80477392a4c08c916bac6e946b2ded6de6a8a370e36629f57ad0192bab1243ef6d6e2ce503229160e5591ba27e3980ae7f7c40953a8985dfe7400dd8471c661c0c8b3f6683ec840adc18fc48f0392e179c3dda24965e5e3ccac4fbc91020a2f405181ebb1d4d4b77483b8ff652301912a2bec35b9e36f6f3951ce891eebfac7413be1c16335bab9ae95771c85f00d18e289c8cc98759c62656cd1a6025ff674d301fe817decc6feb6c893d4a7bd9e73b12d35e717d5151e414b90835feafe62adaa4289bdf5bc12e275acd3e96528e6a40183ebce5112b2c69f71c776e53d3eeac589f0a87327c650c6d39ac319f985618bd43f94885ecbecdb7424162a6692b63da938c84150d911b1e71abcd19c5488566eb354ac899efab74d3f649b93e778b0d16d087d0f46b87103355405d1998f0e6e4c4edb021db432d7695673ac071e9e00fea8e5d1d0009b3b8e88fc967de4c5c76a4068c5198f1c5e7be7707ee1679a139701e07cc6871c05214efcc5181990936dad3c736a3c4265641a37fd90446e863cd19de7ad9373e693469b490532fb9f17cb75686dfb3aa366d6f128b78001fe61f593cc592db0e0303498dded6fd1cf02e227c568633bc610cd8a3de8febcbbd1cd097594699680654d2a38ec2cf9bb6aa3f5ac30de73113ba5a9068a0d73a66f6f370c947dfe0b8a13f147df3da529401fc8df4c8497f072faba91845873875d8473e995d6a09bc62c795cba5e2d8dabc6960215856eb48346f1642c1c920d89534e2229eb1bfc5bd6975a2c2bcc00c072241305498280cbd7bbe775ca896a38b19cda03bf584a95c2a3882a9b400f0ac4fb8740f667ef94cb0ff7b987fb0bad4254bfe1715d177df883f73de085e593cf019522573c5da768494757f631e97f158d29cf4624221399c6b78bd2c9366461e3ba902cadbf4a63f9312524e3536d0b98be3b5718459e4a94a886a9b52e7e3f430c7a39a7ffe92a979d5ce80d54484c39a3525177c7e01a7c6da9a504b257d5b2f0da121f32de53ea444156762aca1b0a291257d3caa648b43fe4a0a1142cd10d3a44d2b7a3173c9c556d763198dd7d105f94a66421985083272ac40c3bf6d2b20d955d2abaca38a9335f7371c3f3e62596d7be9d6dacbf8d26d5ef69089c7b1270ec9b2be18b2f17e160670fdb7b06cc808205959d1c02ab60587695792c4d27280e30fd1e2ed6aebbc8f28ccd57fc540eda6cb1354c143939b98fbfb19c1e9404afab7fafee1527333ae284ebf5e64959a3e75122285ea369a5be03698c5aee1195ced1036a0c141548c413ef20b248a74cdfaa329476caa3b44dacb0c1bc0a964776a57ff8f468a18553984e07df00683c3aca8952c5dcdcf82f2f5566ba960f81468c629357eab9392c007d4bfe036a6dc84786e0712e4c632570d5e7a146c15b55c1699349e3e31f70f745fb6ed23a8559d39c1582897152b6e40d3c6f54ea4a1e44451cc49e665220c5efbbbad8770fb346a277f7ab7a3aadf1f9ec69e3fed39b962f4127a57e09412ef7b75c178515d59683f2bbec55f9c73a8fbfc2ee46c6f717a48d7cd98dcc2ba4caa10a82111a2913ac81adfdcc2d317a104ca7558f548bcfc371cf5677352786d7e801e0e1b16e1eb1f31826b03a0ef9d792d644db1a8c7cfe421754fe8fd63903bcfc030ac637eb1c8e42e52262950ecd1b8f16d8ca8fcf647b415cc69b8fe0d6be06147311857718bce79ac2c38c522c18fe2157de0593dbc32bfd440f67c6573c081f91654978cac37331be0b2beab510a805a60043e48663276181dc48c2cc1e09360803cc41a07f834cdb6eb55372b4b1ff174af10cca58481a17fd2cf7ee2576a461f233a16ccf0bc829d2e6ad0d04b3d19e64d352d1ddcb92c447ff2b20e385a60362b4651fc6fc485e95738ea3bd2a365445a87a4e709ed97452c3a46fea47b0c24e64432d947b93e638768ef881235a74e23d2744085643da52167c8d5fe0985b65ee7559db350520712172be5519d1349cbc163b0852ec724f02f595a298cf886e7b54c5c123fc965d643b3ec08b87dec4e5cb8d05cca594afc6f927522592e9d0ae83cad12f7d82d6ba900e2e4717646a1990859678ff8da173dcfacfda49205da5324e6a4e9d456f6e001f38a55ff21c4a2a72c9da08a93af698526f907dd646b5177502bf0f137e754affb50d2a8b332225fe5c0664dbd16dc366377505f4838280d472daeafc6c6bb24d27c8eb4d11613964bb80a4c658bd62a511d6c6bda73858ef9cd43f713c89a9a7ea2f756d2369b82990ccaaebbd0c322d7ee2d260c148afa23977212660e06f0b15dfe3235c68e3ad560e37a0df1905aa662be44afbb574d4798a9437b00b86d96157b9cb30bfafd570e7987fdabcf2fd7040aafa2343bdcb8b049c682230ee75b53f88c1c000922127f0323997b3e0f95350f29a7a0b0e6f438b77d5355f69d720c4bc1879c1bde82f794deada61201e1802fa3471fbc5affd09449a14c48d20ef9e513cf28bffb0ce5a4b78b94eba92e005c05bbec93f06b93754346fb32cc2bc5666cbf71ccadf9d22fe2cbbf5ad1675de9646781e75cc37f3aed818566d1c9ee7ac4ade5bc8bf439599e4a66992e396d4ea43b02f189c9b9b3ffeee6641ebff84efe9190e0c77f5ef52d74c86e0ac1ab59a09e2f1a723d88ed223e08d3f1e39712b4494879b5a765612097cc3af71174c828a8c838ee439efaec7d16e8e2de2ee4f54018e8838b3339d79ffd75273f1509ef6bcb73eb4f63962a4b0db13215af17e88d2f42632bc81829d6c9f63eeb116c0c42c68ed00a8f70c6f2a43728329759065d9f2e3af6bd444d5eb744fc0af58c1192d83c163468947b3e20d19bf6679229400f078379f864d0ebd972a919c4fe1dec4b8f7a4585aad8122babf622b96697a33d1b7cbae2951771f3bb1242df7258b91a579204ce525bc1644c9e1904182733f830846e9d03693ea41d0f8aa454b2a11c7297ed3c4a28c3508da4e5e87ac49d1456559ee881c5882b781b1542ded2844f3b56874f63fde98c2ff7935a8b3678f5ef0ce56fb43c695acc4c6860117d4c4c22bf8c9726cceff2fb89a92552f95105db579b21f03d1a5cca7d038dd0ec0f8373388ae56bb2ecd1549299d725699e6861d05f60c7144fa3251f41320b111d58166eac5a373e4ae24b696f0252d0a0ca0b90b07d26467d77b66f47a47eafc98efe98dbccd6cb48bb63035d4ce5c7c4b11eddbb9b6bbf0adf6603dfa2364183d3e966f6ca78560cd6b6849ca183b0fc7e1c12aef22e253bdf181f0f321e42a3abefd4e357f4bde6e0a4459e6cecc810d6d094792c48d3081c819bd16a4a4f8bb0ee9433872a61dd841b14a285dbb8d75e43c04322f59ab16f845dfac46a463085f2fd9610c93dd9f35ad42c8155429833a3e70f2a899ddbf868c029054e626f94509f1e13ad04640647f3f583703e3d8ed93bf3f36e4c1c57cb119feec62d326d4e3de07f6bbc604909bec26389ab5dd76f64ad3176e7fb9a7353293be6a86293a1a7befa3ebb1081c128c5d87eccb25e337d16fb46cc4653bf9727996994812f7b568a5a4bcd06825a405914b94670f432f3baa516a9ebcd00227f078c9274e7018cb5541fafff8e70ab5be85ce903a3258ca7a957f14a134fbea7eeba58bf752bfcf2af05d9d9f5354a107e7048b0a75145c6dd76c4fed974c408e472f0ee6d9042aea1fbdd7921eca35a26b780ed3136e40b6e305ddc25e771417152cc0fd65136c61c64ad13d455bd625e8a40c4902c2ed58c1cf5e9e654e2c7c3086a8cc43907bdd9ba06194569b023be5a21ec86c0377c934bb7141342091bb0c1b415928f6feba6cc9d45a795c552c551c94bfa27f45beb7e6f228e72205f5c5fec6f505defa6c2457b87be151b40937c4e02e4d07adc127b2984ca403785a1089d5415fbcbdb6872b80f8fa8008e10abd231bc4f43549b22eeb0d44891a0d63d2a38764e836ad29d23186adfa37ccd2a100141b5d397903fb198b7505b9852476bbc6d494085531b55131b2bffbbebe7988cefd81ed5be7cc1bee44d9e27c0396a14ba490fb4c194ab8caf5ea66399684094147a090d5aa9ea952065a124267f02c66ba995bfb3ac93fa84a08dc0956a18b25191ebc2bea926f9ba3cbcd32a9b3f370233cd03761ec13dcdb5ad343ee6d68926acfb51550457ae232b8a181be698b083c552aafcdc02dc5c6672f2efaf4c5112565d34d02a5177136e31d6adfd00f842efd5abb175a7cf742454b1bb96b8062d151cbaa6303a80dfe3d4f01188bc0944044d7f3f0bb8dac7328f4dab53abb6f8882d277346dbb1b8a606e4fba28ae09a6985ca3dffa85ac5cf7b9aae1b024b2c68e6c2388d54a3b92fce4152f397e82803b5d65776f10db4721030033fe78ef9bb7cb482c4fbbaae5c3fafd0cc9e357a418ab2a3af64b18484176b0d89461304477c01091d481f48c0e5b901d353c5302a4d3284760f8777591800ddca3c8c48449aafd44c2bdd10b77705958ae889b5f36b2352c03654fbf001c6a55ec88ece41b6172830b1cf931a3270d851f64e89da7e085cd47567a5a0d835dacfbf75ee881281cb1c86b86c77b51313d9e6e2d00e22d057a034ed4a640d00aec701d8587e2e5eb9c2b4281bb56955422b9dd3f4d33478a5c31dca518572f8b01751029e4abf7b80616517a3c682adbe108534df47890db0dc369eb0d59d5f4ac308f964ec85ca4471c61b2e2dfef43fc2e65c66604da80ee49dae11e27e1f09b657fbe30a9a0a0708942a8cf5e1b1ec6f90f3b67f79de2e4a64d008adbf8e72eadfcfc8f42214737ac3d66b3c59a3fc511c36a9553cc3d87859ea62a7326ceb98c1547dd0b8c431ef0e14e798dca94829bf8667d8f6c6a7770f5814e65e0bd9aedea4b94f4f8b28aa6ca9df852762b529f8bfe5bfc5d0012562e76983bf66f8166ce9e0b9fc15efb6ceca207c769fc22e4a92fc609aa84ad9e5a4da6cfd2474d1e5b6506200fb7b77315a5d048d6a5c957ed3724760ee1f560a77cddbb3a4fa323d54d9afdda577af60792e6a7efc19e334feb9b0b8d5eda7f861c5262aa795237e539ee7d3783ce864352d72b99f6d81602977bf6db56586f5417c476e852aac9baf1af5df2d81948cadaa292b7edf087fd759dc8401e178ea05a9e82399eb8c5181415e44709cf5705ca2c617d13e6d9b14880ce8cae8c6f083d57a3bff079e62a2f3227263ce7cbdea2bb2ab6119702085a22b9a1ddfcd1454d90c779a787f38c6eb772b8fe07908e32a1604b4fe8562055de6417ddd5a3fde38ab038f5d026d217a93a24ebdf3b82a52e8ab1bac32b6f373b69aa737a0437c1c3a1615efd83214640d29381351189f5c0dcaf8f50c8668bb916a621198bd9c85196be20e80453fd05063a9545c271c43b9f51fac7d867a3c30427606b7abcf8beb96fe4b913258367218b3f0ad720e342770c8e4e31a954886f185d077a6952c9a1bc2484ca43f7f0af026a2b9f767c1c69e249425c74e01c6f4054cc619302ad0ac4fb490727d407eeefa963a51d087ba0733a4d30abc5a3f542d5b4101ec8c37369fa8b4c0c14c4ce47890de830e6fb155ec4a78db8f7cb4e3620967f8fda0f6b041868305dcc93c4a5dfadc26f30fb0379efac912750c96fe57d4aeb0cc3efbf341ac81dab7b1886633f44a0129031d7a91db5002a6b1038f2c91f287ea0a11f7494812aad8de5c115eaa2f5c4aa178326b4fb067645a5786404702bc00c83bda7606925d49395cad7019e717593c06396052e9c56afaafc6082aca4ace5e7213047162881cce75819ccff150b3f0d42fd9528338adac939ba9120755f8a353e3aeb6cdfd0fad37cc8e813f3340f7c1a96269588977fceb0fb949068708b257feedb7b48e4511ed800b80e0b9400be602f92b294ff033abc916f9203e0146b379c510e0f5cab28eb34cabee4589d01c935bef8cb2d1d0ede4f0cdd75f5daed22d073a384655cbb738d7d1185b1120d384055f5ec77b62cde6fe2a56e010360c4d5b7526bc4980db8c9b9e84732e1bac92abf6b4e98287ba0abd8c6ff582eb8bb89b644c14da6aeab14d248e41c22b286074e8b2229e35825783b0ea6a26484050fda586ad3a06ffff24d6bf9c4b82b9492a3ba99fdc44c3f99f37091f02ac2fc97aece88697edaa7e6958e5d4520a58157a540a2dbac51dd4afe61d859e9440ac3e74e7696eef519202572d01b69b83c7b683f279a033ddff93f35816fed71c1e41a89a622292dda2c421eb102f29e0b2ae4f9a320405b3f1b5796487bb90f7aa7866494f8357ad264923eee9b5caae90131ed49162351fa79959cc21743a6d308253812f31de939f1215946e9f6cdd5a8f13fd8729c55ca9b1783352fbffcc4b91cfef9da5ef4f02dd953b8e7afb4e08a5659c9071c1442b0b9e1fabdb3e48f3e12de69c95df328ae7cb735db86f33d5e9a405a0868cc0af5f15cc19a2c6ef6e566256a5f0e8e060dd510b3f794a94ee3f5a408a64fdf561dd816de07d9e1e6f1c4e24baaa9ecfec34bebe925003385ef6e604dc28344641f973295f17dd97e2199cf17c0f57268e72ef2f46eb2d682294b9b3cf3eca6b68e4c2f5806f1fb3be0f23a2ca3c7e30748573168e64ca860acfc98e292619dc9d30576a96b0ba116b7278ec78a56891e3278baf118b81a9404270101c2cd201ab228a87dcb72c08257a21eb43d7be56ce3834fcc51745257816931c1047286c0f07e68884a93a53351b4d45ceb54ae0189a210e31a5bbf7fc10b3390786a1a10651a70582f25122147b5b97a53f784801604447fbe6ee28770aed2e482b232fce7d85eb13f1258187c82339b7edfb4a5ede504a143e6ce53740304e1adf21cf0dcabbb97a36d4875db2cdaf0c074b3483cab46e001ebb00af4082a7ee158cbb9ab6359e347914fd02c08db58e2eab0e7d0d6196b57da8db61073c93c868b988832bf0e67ac0f64ffde7f5672c37d0e277d49ddb6999c358a41210fbf4b2c4c411b1f9a8af2a696781425cbe7801af912a37ef17431a62b404da3a5522d3554040c686b0af62a68438ff71b9e225b09a694fb9ade5d79e21829b037605f799eb39dd01a5b2232a368ae700ad1dab9b42d45f21b036bb126246d8c2efa2e1f6594dcad466b37a471faf967cdd071f349eb167e4693bfd9a191394d93df19a849d85d453b7aab572c2b2d173fb0a8c49e8a5cb7fa5d999a28ae2f52fe4ea9ee2cf394b2006a626c02673fbb08f0ce58165b56bd4f4ad94594b62eb0734097360871539d18fb54079292cee2f315f733e7c4eb775e7a7790f2dfebe9a3a1b1283fc325f6f04ed1a796fb7fda20f228a39614739d3a08a93c2a378b703bee7a2c144c0d6d647efbb95bdf3c11c05548f2bb17ca4029d91cb2b1e76db809a283060751be4c9fcb6abd456cbe30687b25586305196d6eb2bc372c3d3912060f601752ae94fceb23310dad4634cdd9c60afaa4a881a88286ccee3c864bc78b44d8cc0221904760fa08ed1107db8617367584da6419bd0a21ae7e3ca049dfbd519b52ddcd51865d47f408faec6bfd41b10a26b1c0dc9e1bc158a81c569bff93720b4cdda5e184b2d64d5855fef2045b3b7a42cd78e4a8ce1424bd00c8e5a5ccde98264435c745806e7ebf6a93aed9b8647cf12ff8576e0e00355edc9db105d79a4a0d04d45e973556d435f1937924c5e12b187bb0d8102c5c8b9b20d70a9ccfead7a96e700a5b50a9711251800e704a45ca145781f3954474d7b75ed645a689d29bd3e238c742a4017180ff51befd024e5d174587c31898491cb9b67fca180eb2087bbe3d2eaefdf6f34b5abd37d7bfb5ba2d6761a17ba4d8d9f6622cba0bb660a73657caba9549fd49a605eb70273da337fa8b8f1fcd879c170fd2bbc5639b7fb5f885d460c395a6bc8a4c8fcde3109e78997861fe46f617226701795569692d017bd571af5aac08139ae09d67e419633cce18feece02f1be4ed1cf2325712fa93d3b1fd634e497a176f376668c43ce04bac2f6bff90f2e46870b77c59a5387cec28c213d303b0eb587722b854c5e7aaba458e808476d623728899c47b2254e43771987f03c81ffa7cab6ba39f945278658fd3771b3ac6f6457c752ee103683d05263c622c47c5f6d34b316cc44064b7f5c3992adfd5177147c2d1f3ebb9ea4a1657de1cd7bfac19a9510cc24273c5a8cdc4b75f4fbff4085767aeceee517c29202e98e6c704a2e3fc80079f94cd230cf101e73cd34fafc647065467f44c62542468b9b5d13717caf50570338d56186ab95755e28fa0b1b8f7a74e43a07a5c3f7bd77d7ef884bac3e4f172fab45565fe1fa5573f528e0e71d5c6c823301a0e026542ea6a7590f8d9bd74051b9c223e2bf7d93ec018c3db21b9df649f03298261ac127b7c74fba0f4203dd2bb9199022fc95b107e600a733fa6e7572054fe1afd2f953740b005bdad58fba4bfd22d8080dbefdab5c47bedf8c9d8ec0989a6f63f6ea87fece28c52a68c466394732b4f40280ad9fd6e09c9437707c30c6c0f6b54a6a0c782c42c388377fab173dc9dac37591c8c23d9f58c300ff28d8c45a8c18cb99dc6b853d440905972fd9dedbbef60e7159a391d9ce7b09d884ef9e66f8024ef2991670d1a9e89dfd8b627b2f4251bd168b9db0e0a381c8dd09d2fb932891809ac74d1accf94a56fad8a51f3c29309b6f9cac7935645edbe56e3976c365ce8ece171a1da44aa6ef76b64785bfb3a0b457c8b14c76e585f41e3bbe01eb6473808ed4aee7f292ce374237b6d292a10ee6f0ef36bcf7c100baefa3a9cf4c44712c333b6f2bafa504c812202f311ed48c184451e6876166a8a6189f8db0e697e18e5fa348881ee569cacbdef16986f05fa64b6034ccbf6cf2671db6f38e904a1666449bd485f97d1efaa7038c2ef56152c6582ebb0301c7ad9582b103a52516cfef28f547e95f04af39c2fda976cd8ea555823a9a68103cc55f96ef57f42d8031179fcf071184c0ab1a70c42be4aba252c4fd9806245aa4ac174da83dba40a6436676b7feec6073886a454650ae9d6a5a53b040d40fd01be58f3b44b8f224dcff2cf203a08c2e70aac97f625f47088090461e651b198ec47c76f08cadfde81c701001b64330e9ba9bb6870ab7771484321d96d50ad214c3606bf555c2f6b9900cd2466c07e2a43c7cee63b6a7236f6f497583a6ea4e19271583bdb192e64cb723ad2432ed8687dae845a6f4ee2d939f40e72825d75cf36298e0a4ec4034361ec6d7cdb31dc5e5d1200faa40d1987c9ba206483c8add79c6ef8687499ce9fc63024e809a5118783a0f8dc40ea733f419f12c0c766232da4b74c759649b0342adc3587495bd3e659d998faa2d5fa0d8451764f786db7c82e46a35f6e70c692f2661669b473beb76d909fd8f741be5dcf4cca7f3af4f1a5c2a0a076d0c90c61679b70d29298fe791302d653c0fa2946b83d50869f956a0485b894ff5cae07c7b4cf2d092b64a58338114eb1ebda39787062b79fdee8b209d7649681ad22d81de5dbadf31464eb967159542a564e4ed8a91dcd9bc4bfd6664cb75fa5bac1eb4c965cb9c29e62ce9acb7756b554517dfa88384d46b897f29357005d13af3f9eba6c41a680e3b89c4f7be2be9fd87c62d78cefe01c9815f04cc017767af1886e2d5a3c5d81d5d7cba83c0824cadfe9130dc5cd1ec72fd576fb40175a0f40abd2d00356adc95219135be2ce288ec1514caf25fec38d76110cd37b757622fe7b7703193966cc3bc9c4a2e362f446f9143f3a831dc871ddb7111ac70195bd482741ef4d1ced03732f44dfdf90f6790800337de3be6c70ae4b810491789d676277fa5859ea558c9ba89a7c63ff56c6592c9a9944e8ef67322b87f8d1304a1a4081dd2fbf2fdaddf3ebb84cf62eb0c178ef4dcaebfb2a9cd18c247c963e2487aa3daefa64939f72fb0934b8b2534413dd0dadefc614a89a8adcc83976135c97984600ea1d22108edb2cb0891953ca5ba3fcc9e6ce65f475e5cd1bc957568595fef3766ce0e841322e55e507f43ecca140176686b783853e97264e2102317849249561afe5fd51e24b8d13df6c3861f507f6ecb75c13d9722d98a00af988d72db8da7616be5f42df8f6755cad384a3628a5c35cb1fce58933f8034d09ade39ca624dd63b38ca56d56531d76ef43bc87b233f2657faeda17fccd80e401745bceeff57b533959b9942f10c697f05ce53de5cb8dae65da772bd1e3e70eb2aa8205f79b314b2fd4580487aa379f65968d78b82cd960f502a3e882a733f157a27d0378478c50546a003f044cfa8b49a8db966f111268f0982451d894042c5a354c848cff2be3d0fa844958ae4b69f42cb3215ce34e6f46f6c906601689d8327e45770adcbd74d1a307048f7a6b0c020606e420a9f4559003803989bca0a3356bedd43ed11f3744fe814f415bd7373df27acbb5af181117c403be445855c01a39dbe74a236ef8d15c5b5e1baebc67a0610471e5b80daf14704be03444fc41722753f445aa329a776f7dee7b00e8fc4f643cc5c726c45982ecbabe18db8a63e6ae1e470da61b005c9d2387654ab60aeaf7c15fa428cdfa57d49ddfdc8d89c0a7018b76fa95980eda3a9b371cad603eb00db031e5a57e310f8a8873cfecb8140cd2f919fdb140270e889ac8a20cdc61700d9d5b746465505752050170e845b4e69ab8b5b60676a17204f9589ac362eb74726dfc4ca6c2ea5b315bd9cfb22ac5b9abdace95aa3c892a98fd6df9f7503476c8543c34d908ef564348e34cb3f977cd515754451a5e4dff3476a144449ebcbdfec1b7e5b5322ff523518260129a83603884fd6fa779299f0f5934f94b5faebed43fb8d52fc7146318bb42714247d995f47eae8a2267924848e395e2367548512c056c25645b5fa0eac00b56085764eb8a872f2056dc24b4bb3c77dcdb5b177b1252b11c15f953528a8fbb8b6832882473b94383717b90c5442a9e2cbbb2416d4689aed97a2fd0e2bae7098c5020bba980c878e313f610296f6097f5d27343a149521df2e68ed08387b23cd8f036df69d5325e293b8ef8bfe4898202a2cad4ce4361565bf95c426057234499b28372d9355131880c05a699eaf3da68d2852abd374097c8f57c9ab307756deafb30b06d41f8d597e0d35ddecfec4847fa79cf1a9056b8f5ab7767d6658d69df32b1915fda3cf62baaa35d5854039b9e49613f2f537817cf1242794ea4e8d6f5614b30fd66a06739d055e9dab81c6bc463da7f733a1752baaa1bb9e3a8e9b510c8158eb2f8f7e1fbb3be1635a8c9ea04f7f863bdb027e5f22e1a90bfb26c58095a6ba884123ff6b935830a25dc69e359436ded80581964c067942c523bc324016ac4ebb7662384051097848161f3870fc19910936314de28962e40e1863bdc025b67a12836efeea2dad842dacd0f8efa2da940b797005961d77908756d300c4843726ddef678c0c303a0b6ac2306750e31a621ba639b4293b5031a78a4b0cd2cd0d48d641071932f2dc9cd40a8030154a7e65fd6c3fc7cc93454f6b4d59aae4e0ffb495b250735c02ffa835a3b9998122fcde9afa45c65287772c88534b7ecc89c1018d98f8c4dc58d69cfa3f16d66e616094a7325567583f2959fc51d40970e72b2fa3aeb7f3ec3d77bc902d7f66fe37c1de3a1b0a994b760f50917833df2b6c3644ecceaeb6f062608429c6efee23412e46d714ea5d8597c640d92e875ebaf7206b5385ad3ee4635e99755b16f3364bf7bfd410b2b559a388196b2376d2afba835f511684b9292feb6ec34ed844eec9189de17dc888cfa56143fb95795868cfc0797716a14f6340d516632512452e163b5140ce29fce6b7eea57f54d405a7081e0d32a16b6e1531c3cbb272b55f5dfd2d0b92e2e9564d015462df5ee16e2392cb18e203d84266c80c592de02995b1d21f8abf08a41ef6e96adf39c26477b35e408ac354ef067d20a5bc620d817592bc96a8c2c400376e74842a7dac647fc2cc45f56f44e974bea4bb1405487935b290d42b9390bb70e3392720daf8e1167e072192a2e9d38c896c32ada1124b020fd682d50a34ec35872db5c5195025e1c397020e15e597158c77757729ddc5f598268075f09142e82872f8446a29a70b553b8aaa89c5f74c6f21be88e833bdfb4479ba04a6e120cfbc0b32ccb36a4c324ef71174600dda4da7fa052ae5fc447a6cecebeaf57cb7dd5f2319214cbd53eba39fa9fc6c5f1870bf041ba95a8df84b60b5fb2989ed1cec3f437e8ec78bad06f111e0fd1e41ee1899c8b7ac68bf13d8dbf6d29dfeb5d1c4b13d88ce0bbbfaf489960a91092572d39dcc522bdef706d690bde64d48dfcd4b3d685c677775effed66bd1bfd076dcc86dbefc9283ee57db3510c776b2dc683174544e451bee3de604b6796bb05b959466c8ceffee653942162a5c712bf12afa2926b39db291c797b9581ebc47deda7f0f41e4bb9e868dded6b42b84284d5caeff847e9101e28e3a6467671a0b172e2fbf4de01660a9fe6a794a90f3a7aa815bbb7fb164b0e1f8504782cc8a4aea38f64c279d85060cd5341ad42de5cc064c47c174ced01bbbfd6531a0e90bd2a32f180e63908ab0992519aefdbe5ac37e0437b6a1a22d276cac626108f25cedbcb80409faffbbd1a06ef70c78f7eea86fda3f28477296e59d13a72d0c2ad01f8cbb4bb345a7493979bea366d54e013fbca9c633b4136be53c85c8bc8f07507f638648e7b4c47e7889ec1be2909140dd8020ae28cad2f728edbf4621c2bd7349000bdbf8ed681298aa58654513ef31ec42fbe73a28ddd271fa7a46916775c56cdb8946572aed1307ac8ce0f64b4e8119525f2412cac05cb9fae09d79c5e680274d9cb67748bd566032dbc44e8bd4933e5eb7b3df6875432c3acd501167d8642c6c34c8344581eaa545eea08dbd8d87178425fd409a6c223d62dd7d30b51c28edd7694b6bd6d0566ee286b2f7560e2c5b002326b634e48f9e85ebe9c0570aff8e6bdceba82c0e94c7ada49b42d91399740f9ba664fd966a4752cf63b57d6baf7d8b37dc95105b244068ea90f7100e7b63bd3ea5c2054b9622e140ab440551b93a952da28abef5e03b720ee93123d2312031da7f52167ac167ce7c87673371afdee7ee1945705642d21b0f5e7539e9fe418ce5d0ef944d0277634c24007dce80a2ddf9e4a54d14c62b6ab5de36b961e78048f9f8b2d89cd15bd3385f7c7df5bb3ca9ab8813fb1245745c3ede72891b8d27e576dd9462f226ed88292923eea4502e4d0d32f979fc64e67a980ec524d498f670b05e1a1e0c2ae3606aff160c4150256d56a03054a9e2d9d7f6c2af13b26a952d6265ff2d580b856e91308e3cbe45aecd6b4b56236c3929237bfaedd415ec5d9d2673d1439cb78e3669f23bf1de241d4be268a6640076297e388e9bdbb0950332296865f839243020012e87c35c09de2084fa70d998706c333baefc9db129597ad4cb1194b3ba262058c99c83a81897b8ad3f6bb8fb0dc4dcf7ee3de551172288aaa73726566fae46b678b798c364a80e899d7c0b8ad38abaa1ed65432b30e71f0a297972d2c8148523c56e1cfc4bcd71ae8d69b9c98cf2e24f33a16a058d9e8effa837edca5ba3f441896c373636bffb7c752648d2ccce8596d2a3b5455739b73173d4755b93655f8210335d860ac35257b78757df9fb1a4566b4178eff2ed39f01727893eaab6b0c6b321f861f20d55314b0b08af25563572d169eac331a5364b3cab48814b7ba51ad6478259e14b60a4be3bb2ed326fe7fe1bb8e46d6e07b9a89b0d45b7e248391ecb497f7329352ddbad23d4d6f912cb89b26ac49930d5c4101a263b356995299a1237a734d518e816d77986cf0b38d4ed0107ac1ea91689478401c1f3f5355a7b8ba78e6415327b4ef2f9ecfb096a6ca23fa32e724f672a2f5536fbf3a0bf058f66c500432d9ff6c9f495e356661ff55f6b2bd03f39dd0b2d1e6ac0e747eb1fc10eac65509eddb53b714cc15c63e79ddce3a2b3ee8c61cfd29b461896af6c483fbd7ba506521900bf36f815956a320972f02187f2a7811860733a104d5a672ac0f72abf5f54fd88e08d7fd99a404cd822b8bcd6d1c0e8fc27a0143d6d8afdce72c0903640dcb904aa2380a33914e5d9f2a7714c9be54b75387d0307ca5638fe0dda18380312715d3f03dd555bc8430db40f79853dd9fc57a524445294c428d94eeee9cbe90606d460760e302bec5670159f0c9920b2030189562cb37c7cf6eaed9f12f063f365d5554301e828add87d2bdafe1a08825d2752ed0e0dcb2ba8db2cbeb663e745c809572ecddf660116d7e890f633083cba7306c9335ab5db70d4f1aa1e761ac3f6444a33fe8a5f593bb6c0bbb409944a164f50f6ea729a8c89cb5857a81b171893714fa1c99c317a70c005aa97e4354c517190654ef6ba0608ac1c2ddda16af600b267956dac89ca802f0a9fbf44498ae95845c16b6ac46838ea715aa34ae853234e0022303d2aedef0bdc28eca77d718a19b8aa58954eb72d6ee2cd283637406d1843954ce2690074fcd89c62aae267b22b06f451c00dfb1b02815d72f7aa0412e50d57d02f89076e8d7faab1d09bfb688d1a2a6ef64d3a69de3c1ed69f5841c21655f565747f7a943a32dbfe7d1df889d28f630059f58a848ffe1f9773aba71d80982f7a1678d865f08f39bb50645b16bab35a278661f21ae1b4b9236bc6b603587a6f634563df3570cf14f9ffed02008bd98f5111d64f5b661e4360c375298176a6eed50a688a05f7a7978cc921936152caf20892aaab51111637146031f9709981f6b912ca6e7553f88e8f82e71db264896132c8fdaaf8601c8e59f699bf098aeff4b2a0c009f33ab04967e382b1107f885ebb1f8733502fa3300b7342340c4febbef692aa4b92f8696f9c52e87820dcf0f1c16577b0209b2799495da33dc6b22a2e252ac63b91eb2f5e966be1775d463a3f5ff5f0b0ddded5de62831aafb969ccc0100ece514a32b248752c739e332271b7251b6e610d151982353293b25801e71d0a98dc55ed34c307f0a63c9f8aae579942716a8ad68d23c0e88c205fe534805121b3a1e389e37f4f98618427b265c5f8ab621d4e805c17398e824fb93057e127162089bd1100da886f41347b8f5482a7f8bd2abbe68a2b3b604e7e69f1bcfdffe9dd93a87676d5d349032931e31d07210cd125b3f2352dc9070771995997e848a14066ba1fcd01329cde1b929eaecb645213d1667f7d3b5ccd7f2a8a8566056954efd5f089736523faed35bad6f323b6c9679a6266c9a905cc543a38d9a8631e685731c2c66e64c396e7e47\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","categories":["操作系统"]},{"title":"第一章 概述","url":"/2022/06/06/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/","content":"第一章 概述1.1 计算机网络在信息时代的作用\n计算机网络已由一种通信基础设施发展成为一种重要的信息服务基础设施\n\n计算机网络已经像水、电、煤气这些基础设施一样，成为我们生活中不可或缺的一部分\n\n\n1.2 互联网概述1.2.1 网络的网络\n计算机网络（简称为网络）由若干结点（node）和连接这些结点的链路（link）组成\n\n网络中的结点可以是计算机、集线器、交换机或路由器等\n\n网络之间还可以通过路由器互连起来，这就构成了一个覆盖范围更大的计算机网络，这样的网络称为互连网\n\n互连网是“网络的网络”（network of networks）\n\n网络把许多计算机连接在一起，而互连网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机\n\n网络互连并不是把计算机仅仅简单地在物理上连接起来，还必须在计算机上安装许多使计算机能够交换信息的软件才行\n\n\n\n1.2.2 互联网基础结构发展的三个阶段\ninternet 和 Internet 的差别：\n\ninternet（互连网）是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络。在这些网络之间的通信协议可以任意选择，不一定非要使用 TCP/IP 协议\nInternet（互联网，或因特网）是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的ARPANET\n\n\n1.2.3 互联网的标准化工作\n因特网的标准化工作对因特网的发展起到了非常重要的作用。\n\n因特网在制定其标准上的一个很大的特点是面向公众。\n\n因特网所有的 RFC（Request For Comments，“请求评论”）技术文档都可从因特网上免费下载；\n任何人都可以随时用电子邮件发表对某个文档的意见或建议\n\n\n因特网协会 ISOC是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用\n\n因特网体系结构委员会 IAB, 负责管理因特网有关协议的开发；\n\n因特网工程部 IETF ，负责研究中短期工程问题，主要针对协议的开发和标准化；\n\n因特网研究部 IRTF ，从事理论方面的研究和开发一些需要长期考虑的问题。\n\n\n\n\n\n\n\n\n制订因特网的正式标准要经过以下4个阶段：\n因特网草案（在这个阶段还不是RFC文档）\n建议标准（从这个阶段开始就成为RFC文档）\n草案标准\n因特网标准\n\n\n\n1.3 互联网的组成互联网的拓扑结构从工作方式上看，可以划分为两大块：边缘部分和核心部分\n\n边缘部分：由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。\n核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。\n\n\n\n1.3.1 互联网的边缘部分\n处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为端系统。\n“主机 A 和主机 B 进行通信”指的是“主机 A 的某个进程和主机 B 上的另一个进程进行通信”，简称为“计算机之间通信”\n在网络边缘的端系统之间的通信方式分为：客户-服务器方式（C/S 方式）和对等方式（P2P 方式）\n\n1.客户-服务器方式\n\n\n客户（client）和服务器（server）都是指通信中所涉及的两个应用进程，客户-服务器方式所描述的是进程之间服务和被服务的关系\n\n最主要的特征是：客户是服务请求方，服务器是服务提供方\n\n服务请求方和服务提供方都要使用网络核心部分所提供的服务\n\n\n在实际应用中，客户程序和服务器程序通常还具有以下一些主要特点：\n\n客户程序：\n\n被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址\n不需要特殊的硬件和很复杂的操作系统\n\n\n服务器程序：\n\n是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求\n\n系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址\n\n一般需要有强大的硬件和高级的操作系统支持。\n\n\n\n客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据\n\n\n2.对等连接方式\n\n\n两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方\n只要两台主机都运行了对等连接软件（P2P，peer-to-peer 软件），它们就可以进行平等的、对等连接通信\n这时，双方都可以下载对方已经存储在硬盘中的共享文档\n\n1.3.2 互联网的核心部分1.电路交换的主要特点\n电话交换机接通电话线的方式称为电路交换\n\n从通信资源的分配角度来看，交换就是按照某种方式动态地分配传输线路的资源\n\n电路交换的三个步骤：\n\n建立连接（分配通信资源）\n通话（一直占用通信资源）\n释放连接（归还通信资源）\n\n\n电路交换的一个重要特点：在通话的全部时间内，通话的两个用户始终占用端到端的通信资源\n\n当使用电路交换来传送计算机数据时，其线路的传输效率往往很低：计算机数据是突发式地出现在传输线路上的，已被用户占用的通信线路资源在绝大部分时间里都是空闲的\n\n\n\n\n2.分组交换的主要特点\n分组交换采取存储转发技术\n\n将要发送的整块数据称为一个报文（message）\n\n在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段，在每一个数据段前面，加上一些由必要的控制信息组成的首部（header）后，就构成了一个分组（packet），又称为“包”，而分组的首部也可称为“包头”。\n\n\n\n\n\n路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器\n\n如此下去，以存储转发的方式，把分组交付最终的目的主机\n\n各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新\n\n\n\n分组交换的特点：\n\n\n\n优点\n所采用的手段\n\n\n\n高效\n在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用\n\n\n灵活\n为每一个分组独立地选择最合适的转发路由\n\n\n迅速\n以分组作为传送单位，可以不先建立连接就能向其他主机发送分组\n\n\n可靠\n保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性\n\n\n3.电路交换、报文交换和分组交换的对比\n\n电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。\n报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。\n分组交换：单个分组（这只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。\n\n\n1.4 计算机网络的类别1.4.1 计算机网络的定义\n计算机网络的精确定义未统一\n计算机网络的最简单定义是：一些互连的、自治的计算机的集合\n互连：是指计算机之间可以通过有线或者无线的方式进行数据通信\n自治：是指独立的计算机，它有自己的硬件和软件，可以单独运行使用\n集合：是指至少需要两台计算机\n\n\n计算机网络的较好的定义是：计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛和日益增长的应用\n计算机网络所连接的硬件，并不限于一般的计算机，而是包含了智能手机等智能硬件\n计算机网络并非专门用来传输数据，而是能够支持很多种的应用\n\n\n\n1.4.2 几种不同类别的计算机网络\n\n\n按交换技术分类\n按使用者分类\n按传输介质分类\n按覆盖范围分类\n按拓扑结构分类\n\n\n\n电路交换网络报文交换网络分组交换网络\n公用网专用网\n有线网络无线网络\n广域网 WAN城域网 MAN局域网 LAN个域网 PAN\n总线型网络星型网络环型网络网状型网络\n\n\n1.5 计算机网络的性能1.5.1 计算机网络的性能指标1.速率表示数据的传送速率，也称为数据率或比特率\n2.带宽\n本来是指某个信号具有的频带宽度，单位为赫兹。表示某信道允许通过的信号频带范围就称为该信道的带宽（或通频带）\n在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”，单位是“比特每秒”\n\n3.吞吐量吞吐量表示在单位时间内通过某个网络（或信道、接口）的实际的数据量\n4.时延时延是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，共由以下四个部分组成：\n\n发送时延：主机或路由器发送数据帧所需要的时间；\n\n发送时延数据帧长度发送速率\n\n传播时延：电磁波在信道中传播一定的距离需要花费的时间；\n\n传播时延信道长度电磁波在信道上的传播速率\n\n处理时延：主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，一般不便于计算；\n\n排队时延：分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延为无穷大。\n\n\n\n\n\n\n5.时延带宽积传播时延与带宽的乘积\n\n若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特\n链路的时延带宽积又称为以比特为单位的链路长度\n\n\n\n6.往返时间\n在许多情况下，互联网上的信息不仅仅单方向传输，而是双向交互的\n我们有时很需要知道双向交互一次所需的时间\n因此，往返时间 RTT（Round-Trip Time）也是一个重要的性能指标\n\n7.利用率\n利用率分为信道利用率和网络利用率\n信道利用率：表示某信道有百分之几的时间是被利用的（有数据通过）\n网络利用率：全网络的信道利用率的加权平均\n\n\n根据排队论，当某信道的利用率增大时，该信道因此的时延也会迅速增加\n信道利用率并非越高越好，一些拥有较大主干网的 ISP 通常控制信道利用率不超过 50%\n令 表示网络空闲时的时延，表示网络当前的时延，那么在适当的假定条件下，、和利用率之间的关系为\n\n\n8.丢包率\n丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率\n\n丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等\n\n丢包率是网络运维人员非常关心的一个网络性能指标，但对普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包\n\n分组丢失主要有两种情况：\n\n分组在传输中出现误码，被结点丢弃\n\n分组到达一台队列已满的分组交换机时被丢弃；在通信量较大时就可能造成\n\n\n\n因此，丢包率反应网络的拥塞情况\n\n\n1.5.2 计算机网络的非性能特性\n费用\n质量\n标准化\n可靠性\n可扩展性和可升级性\n易于管理和维护\n\n1.6 计算机网络体系结构1.6.1 协议与划分层次\n在计算机网络中要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则。这些规则明确规定了所交换的数据的格式以及有关的同步问题\n\n为进行网络中的数据交换而建立的规则、标准或约定称为网络协议，简称为协议，主要由以下三个要素构成：\n\n语法：即数据与控制信息的结构或格式\n\n语义：即需要发出何种控制信息，完成何种动作以及做出何种响应\n\n同步：即事件实现顺序的详细说明\n\n\n\n分层带来的好处：\n\n各层之间是独立的。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口（即界面）所提供的服务。由于每一层只实现一种相对独立的功能，因而可将一个难以处理的复杂问题分解为若干个较容易处理的更小一些的问题。这样，整个问题的复杂程度就下降了。\n\n灵活性好。当任何一层发生变化时(例如由于技术的变化)，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。此外，对某一层提供的服务还可进行修改。 当某层提供的服务不再需要时，甚至可以将这层取消。\n\n结构上可分割开。各层都可以采用最合适的技术来实现。\n\n易于实现和维护。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统。\n\n能促进标准化工作。因为每一层的功能及其所提供的服务都已有了精确的说明。\n\n\n\n计算机网络的各层及其协议的集合就是网络的体系结构。换种说法，计算机网络的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义。\n\n体系结构是抽象的，而实现则是具体的，是真正在运行的 计算机硬件和软件\n\n\n1.6.2 具有五层协议的体系结构\n\n1.应用层\n应用层（application layer）的任务是通过应用进程间的交互来完成特定网络应用。\n\n应用层协议定义的是应用进程间通信和交互的规则。\n\n对于不同的网络应用需要有不同的应用层协议。在互联网中的应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议，等等。\n\n应用层交互的数据单元称为报文。\n\n\n2.运输层\n运输层的任务是负责向两台主机中进程之间的通信提供通用的数据传输服务\n\n由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能\n\n复用是多个应用层进程可同时使用下面运输层的服务\n分用是运输层把收到的信息分别交付上面应用层中的相应进程\n\n\n运输层主要使用以下两种协议：\n\n传输控制协议 TCP （Transmission Control Protocol）：提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段（segment）\n用户数据报协议 UDP（User Datagram Protocol）：提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报\n\n\n\n3.网络层\n网络层负责为分组交换网上的不同主机提供通信服务\n在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送\n网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机\n\n4.数据链路层\n两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议\n在两个相邻结点之间传送数据时，数 据链路层将网络层交下来的 IP 数据报组装成帧（framing），在两个相邻结点间的链路上传送帧（frame）。每一帧包括数据和必要的控制信息\n在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。\n控制信息还使接收端能够检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧\n\n5.物理层\n在物理层（physical layer）传输的数据是比特\n物理层主要解决的问题有\n采用怎样的传输媒体（介质）\n\n采用怎样的物理接口\n\n使用怎样的信号表示比特0或1\n\n\n\n\n\n\n数据在各层之间的传递过程\n1.6.3 TCP/IP的体系结构\n\n\n\n1.6.4 计算机网络体系结构中的专用术语\n实体：任何可发送或接收信息的硬件或软件进程\n对等实体：收发双方相同层次中的实体\n协议：控制两个对等实体进行逻辑通信的规则的集合\n服务：在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务\n要实现本层协议，还需要使用下面一层所提供的服务\n协议是“水平的”，服务是“垂直的”\n实体看得见相邻下层所提供的服务，但井不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是透明的\n\n\n服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用千区分不同的服务类型\n服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语\n协议数据单元 PDU：对等层次之间传送的数据包称为该层的协议数据单元\n服务数据单元 SDU：同一系统内，层与层之间交换的数据包称为服务数据单元。\n\n\n","categories":["计算机网络"]},{"title":"第七章 数据库设计","url":"/2022/06/06/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/","content":"第七章 数据库设计7.1 数据库设计概述\n数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求\n\n信息管理要求：在数据库中应该存储和管理哪些数据对象\n数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作\n\n\n数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境\n\n数据库数据的存取效率高\n数据库存储空间的利用率高\n数据库系统运行管理的效率高\n\n\n\n7.1.1 数据库设计的特点1. 数据库建设的基本规律\n“三分技术，七分管理，十二分基础数据”\n管理\n数据库建设项目管理 \n企业（即应用部门）的业务管理\n\n\n基础数据\n数据的收集、整理、组织和不断更新\n\n\n\n2. 结构（数据）设计和行为（处理）设计相结合\n将数据库结构设计和数据处理设计密切结合\n\n结构和行为分离的设计\n\n传统的软件工程：重行为设计，忽视对应用中数据语义的分析和抽象，只要有可能就尽量推迟数据结构设计的决策\n早期的数据库设计：重结构设计，致力于数据模型和数据库建模方法研究，忽视了行为设计对结构设计的影响\n\n\n\n7.1.2 数据库设计方法\n大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。\n\n它要求多方面的知识和技术。主要包括：\n\n计算机的基础知识\n软件工程的原理和方法\n程序设计的方法和技巧\n数据库的基本知识\n数据库设计技术\n应用领域的知识\n\n\n手工试凑法\n\n规范设计法\n\n新奥尔良（New Orleans）方法\n基于 E-R 模型的数据库设计方法\n3NF（第三范式）的设计方法\n面向对象的数据库设计方法\n统一建模语言（UML）方法\n\n\n\n7.1.3 数据库设计的基本步骤\n\n数据库设计各个阶段的数据设计描述\n\n\n7.1.4 数据库设计过程中的各级模式\n\n7.2 需求分析7.2.1 需求分析的任务\n详细调查现实世界要处理的对象（组织、部门、企业等）\n\n充分了解原系统（手工系统或计算机系统）工作概况\n\n明确用户的各种需求\n\n在此基础上确定新系统的功能\n\n新系统必须充分考虑今后可能的扩充和改变\n\n调查的重点是“数据”和“处理”，获得用户对数据库的要求\n\n信息要求\n\n用户需要从数据库中获得信息的内容与性质\n由信息要求可以导出数据要求，即在数据库中需要存储哪些数据\n\n\n处理要求\n\n用户要完成的处理功能\n对处理性能的要求\n\n\n安全性与完整性要求\n\n\n\n确定用户最终需求的难点\n\n用户缺少计算机知识，不能准确地表达自己的需求，他们所提出的需求往往不断地变化\n设计人员缺少用户的专业知识，不易理解用户的真正需求，甚至误解用户的需求\n\n\n解决方法\n\n设计人员必须不断深入地与用户进行交流，才能逐步确定用户的实际需求\n\n\n7.2.2 需求分析的方法\n调查组织机构情况\n调查各部门的业务活动情况\n协助用户明确对新系统的各种要求，包括信息要求、处理要求、完全性与完整性要求\n确定新系统的边界\n\n\n\n7.2.3 数据字典\n数据字典是关于数据库中数据的描述，即元数据，不是数据本身\n\n数据字典在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善\n\n数据字典是进行详细的数据收集和数据分析所获得的主要结果\n\n数据字典的内容\n\n数据项\n数据结构\n数据流\n数据存储\n处理过程\n\n\n数据项是数据的最小组成单位\n\n若干个数据项可以组成一个数据结构\n\n数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容\n\n\n1. 数据项\n数据项是不可再分的数据单位\n\n对数据项的描述：数据项描述={数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系，数据项之间的联系}\n\n“取值范围”、“与其他数据项的逻辑关系”定义了数据的完整性约束条件，是设计数据检验功能的依据\n可以用关系规范化理论为指导，用数据依赖的概念分析和表示数据项之间的联系\n\n\n\n2.数据结构\n数据结构反映了数据之间的组合关系。\n一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成\n对数据结构的描述：数据结构描述={数据结构名，含义说明，组成：{数据项或数据结构}}\n\n3. 数据流\n数据流是数据结构在系统内传输的路径\n\n对数据流的描述：数据流描述={数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量}\n\n数据流来源：说明该数据流来自哪个过程\n数据流去向：说明该数据流将到哪个过程去\n平均流量：在单位时间（每天、每周、每月等）里的传输次数\n高峰期流量：在高峰时期的数据流量\n\n\n\n4. 数据存储\n数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。\n对数据存储的描述：数据存储描述={数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存取频度，存取方式}\n存取频度：每小时、每天或每周存取次数，每次存取的数据量等信息 \n存取方法：批处理 / 联机处理；检索 / 更新；顺序检索 / 随机检索\n输入的数据流：数据来源\n输出的数据流：数据去向\n\n\n\n5. 处理过程\n处理过程的具体处理逻辑一般用判定表或判定树来描述。数据字典中只需要描述处理过程的说明性信息\n\n处理过程说明性信息的描述：处理过程描述={处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}\n\n简要说明：说明该处理过程的功能及处理要求\n功能：该处理过程用来做什么\n处理要求：处理频度要求，如单位时间里处理多少事务，多少数据量、响应时间要求等\n处理要求是后面物理设计的输入及性能评价的标准\n\n\n\n\n\n7.3 概念结构设计7.3.1 概念模型\n将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计\n\n概念模型的特点：\n\n能真实、充分地反映现实世界，是现实世界的一个真实模型\n易于理解，从而可以用它和不熟悉计算机的用户交换意见\n易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充\n易于向关系、网状、层次等各种数据模型转换\n\n\n描述概念模型的工具：E-R模型\n\n\n7.3.2 E-R模型1. 实体之间的联系（1）两个实体型之间的联系\n一对一联系（）：如果对于实体集 A 中的每一个实体，实体集 B 中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集 A 与实体集 B 具有一对一联系，记为\n\n一对多联系（）：如果对于实体集 A 中的每一个实体，实体集 B 中有  个实体（）与之联系，反之，对于实体集 B 中的每一个实体，实体集 A 中至多只有一个实体与之联系，则称实体集 A 与实体集 B 有一对多联系，记为\n\n多对多联系（）:如果对于实体集 A 中的每一个实体，实体集 B 中有  个实体（）与之联系，反之，对于实体集 B 中的每一个实体，实体集 A 中也有  个实体（）与之联系，则称实体集 A 与实体集 B 具有多对多联系，记为\n\n\n\n\n（2）两个以上的实体型之间的联系两个以上的实体型之间也存在着一对一、一对多、多对多联系\n\n\n（3）单个实体型内的联系同一个实体集内的各实体之间也可以存在一对一、一对多、多对多的联系\n\n\n2. E-R图E-R图提供了表示实体型、属性和联系的方法：\n\n实体型：用矩形表示，矩形框内写明实体名\n\n属性：用椭圆形表示，并用无向边将其与相应的实体型连接起来\n\n联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（、 或 ）\n\n联系可以具有属性\n\n\n7.3.3 拓展的E-R模型1. ISA联系\n有的实体型是某个实体型的子类型，这种父类—子类联系称为 ISA 联系，表示“is a”语义。用△表示\n\nISA联系的性质: 子类继承了父类的所有属性，子类也可以有自己的属性\n\n\n（1）分类属性\n分类属性是父实体型的一个属性\n\n分类属性的值把父实体型中的实体分派到子实体型中\n\n\n\n\n（2）不相交约束与可重叠约束\n不相交约束：描述父类中的一个实体不能同时属于多个子类中的实体集。即一个父类中的实体最多属于一个子类实体集\n\n用 ISA 联系符号三角形内加一个叉号“X”来表示\n\n可重叠约束：父类中的一个实体能同时属于多个子类中的实体集。子类符号中没有叉号表示是可重叠的\n\n\n\n\n（3）完备性约束\n描述父类中的一个实体是否必须是某一个子类中的实体。\n\n如果是，则叫做完全特化（total specialization）\n否则叫做部分特化（partial specialization）\n\n\n完全特化用父类到子类的双线连接来表示\n\n部分特化用父类到子类的单线连接来表示\n\n\n2. 基数约束\n说明实体型中的任何一个实体可以在联系中出现的最少次数和最多次数\n\n对实体之间一对一、 一对多、多对多联系的细化\n\n约束用一个数对  表示，。例如 $0..1,1..3,1..，其中$ 代表无穷大\n\n 的约束叫做强制参与约束，即被施加基数约束的实体型中的每个实体都要参与联系\n\n 的约束叫做非强制参与约束，被施加基数约束的实体型中的实体可以出现在联系中，也可以不出现在联系\n\n\n3. Part-of 联系\n描述某个实体型是另外一个实体型的一部分\n\nPart-of 联系可以分为两种情况：\n\n非独占的 Part-of 联系，简称非独占联系\n\n整体实体如果被破坏，另一部分实体仍然可以独立存在\n\n\n独占的 Part-of 联系， 简称独占联系\n\n整体实体如果被破坏，部分实体不能存在\n\n\n\n\nPart-of 联系的表示\n\n用非强制参与联系表示非独占的 Part-of 联系\n用弱实体类型和识别联系来表示独占联系编号\n\n\n如果一个实体型的存在依赖于其它实体型的存在，则这个实体型叫做弱实体型，否则叫做强实体型\n\n用弱实体类型和识别联系来表示独占联系双矩形表示弱实体型，用双菱型表示识别联系\n\n\n7.3.4 概念结构设计1. 实体与属性的划分原则\n作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性\n\n属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系\n\n\n2. E-R图的集成E-R 图的集成一般需要分两步\n\n合并。解决各分 E-R 图之间的冲突，将分 E-R 图合并起来生成初步 E-R 图\n修改和重构。消除不必要的冗余，生成基本 E-R 图\n\n（1）合并E-R图，生成初步E-R图各个局部应用所面向的问题不同，各个子系统的 E-R 图之间必定会存在许多不一致的地方，称之为冲突\n子系统 E-R 图之间的冲突主要有三类：\n\n属性冲突\n\n属性域冲突，即属性值的类型、取值范围或取值集合不同\n\n属性取值单位冲突\n\n\n\n命名冲突\n\n同名异义，即不同意义的对象在不同的局部应用中具有相同的名字\n\n异名同义（一义多名），即同一意义的对象在不同的局部应用中具有不同的名字\n\n\n\n结构冲突\n\n同一对象在不同应用中具有不同的抽象\n解决方法：把属性变换为实体或把实体变换为属性，使同一对象具有相同的抽象。但仍然要遵循实体与属性的划分原则\n\n\n同一实体在不同子系统的 E-R 图中所包含的属性个数和属性排列次序不完全相同\n解决方法：使该实体的属性取各子系统的 E-R 图中属性的并集，再适当调整属性的次序\n\n\n实体间的联系在不同的 E-R 图中为不同的类型\n\n\n\n（2）消除不必要的冗余，设计基本E-R图\n所谓冗余的数据是指可由基本数据导出的数据，冗余的联系是指可由其他联系导出的联系\n\n消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余\n\n\n7.4 逻辑结构设计7.4.1 E-R图向关系模型的转换\n一个  联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并\n一个  联系可以转换为一个独立的关系模式，也可以与  端对应的关系模式合并\n一个  联系转换为一个关系模式，与该联系相连的各实体部分的码以及联系本身的属性均转换为关系的属性，各实体的码组成关系的码或关系码的一部分\n三个或三个以上实体间的一个多元联系转换为一个关系模式\n具有相同码的关系模式可合并\n\n7.4.2 数据模型的优化关系数据模型的优化通常以规范化理论为指导，方法为：\n\n确定数据依赖\n对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系\n按照数据依赖的理论对关系模式进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式\n按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解\n对关系模式进行必要分解，提高数据操作效率和存储空间的利用率\n\n7.4.3 设计用户子模式\n定义数据库模式主要是从系统的时间效率、空间效率、易维护等角度出发。\n\n定义用户外模式时应该更注重考虑用户的习惯与方便。包括三个方面：\n\n使用更符合用户习惯的别名\n合并各分 E-R 图曾做了消除命名冲突的工作，以使数据库系统中同一关系和属性具有唯一的名字。这在设计数据库整体结构时是非常必要的\n用视图机制可以在设计用户视图时可以重新定义某些属性名，使其与用户习惯一致，以方便使用\n\n\n针对不同级别的用户定义不同的视图，以保证系统的安全性\n简化用户对系统的使用\n如果某些局部应用中经常要使用某些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图\n\n\n\n\n\n7.5 数据库的物理设计\n数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统\n\n为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计\n\n数据库物理设计的步骤\n\n确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构\n对物理结构进行评价，评价的重点是时间和空间效率\n\n\n若评价结果满足原设计要求，则可进入到物理实施阶段。否则，就需要重新设计或修改物理结构，有时甚至要返回逻辑设计阶段修改数据模型\n\n\n7.5.1 数据库物理设计的内容和方法\n设计物理数据库结构的准备工作\n\n充分了解应用环境，详细分析要运行的事务，以获得选择物理数据库设计所需参数\n充分了解所用关系型数据库管理系统的内部特征，特别是系统提供的存取方法和存储结构\n\n\n关系数据库物理设计的内容\n\n为关系模式选择存取方法\n设计关系、索引等数据库文件的物理存储结构\n\n\n物理数据库设计所需参数\n\n数据库查询事务\n查询的关系\n查询条件所涉及的属性\n连接条件所涉及的属性\n查询的投影属性\n\n\n数据更新事务\n被更新的关系\n每个关系上的更新操作条件所涉及的属性\n修改操作要改变的属性值\n\n\n每个事务在各关系上运行的频率和性能要求\n\n\n\n7.5.2 关系模式存取方法选择\n数据库系统是多用户共享的系统，对同一个关系要建立多条存取路径才能满足多用户的多种应用要求。\n物理结构设计的任务之一是根据关系数据库管理系统支持的存取方法确定选择哪些存取方法。\n数据库管理系统常用存取方法\nB+ 树索引存取方法\nHash 索引存取方法\n聚簇存取方法\n\n\n\n1. B+树索引存取方法的选择\n选择索引存取方法的主要内容：根据应用要求确定对哪些属性列建立索引、对哪些属性列建立组合索引、对哪些索引要设计为唯一索引\n\n选择索引存取方法的一般规则\n\n如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）\n如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引\n如果一个（或一组）属性经常在连接操作的连接条件中出现，则考虑在这个（或这组）属性上建立索引\n\n\n关系上定义的索引数过多会带来较多的额外开销（维护、查找索引的开销）\n\n\n2. Hash索引存取方法的选择选择 Hash 存取方法的规则\n\n如果一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，而且满足下列两个条件之一\n该关系的大小可预知，而且不变\n该关系的大小动态改变，但所选用的数据库管理系统提供了动态 Hash 存取方法\n\n\n\n3. 聚簇存取方法的选择\n为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块中称为聚簇。\n\n该属性（或属性组）称为聚簇码（cluster key）\n\n聚簇的用途：大大提高按聚簇属性进行查询的效率\n\n聚簇既适用于单个关系，也适用于经常进行连接操作的多个关系\n\n把多个连接的元组按连接属性值聚集存放\n从而实现多个关系的“预连接”，提高连接操作的效率\n\n\n聚簇存储方法的选择\n\n选择聚簇存储方法，即确定需要建立多少个聚簇，每个聚簇中包含哪些关系（一个数据库可以建立多个聚簇，一个关系只能加入一个聚簇）\n\n设计候选聚簇\n\n常在一起进行连接操作的关系可以建立组合聚簇\n如果一个关系的一组属性经常出现在相等比较条件中，则该单个关系可建立聚簇\n如果一个关系的一个（或一组）属性上的值重复率很高，则此单个关系可建立聚簇\n\n\n检查候选聚簇中的关系，取消其中不必要的关系\n\n从聚簇中删除经常进行全表扫描的关系\n从聚簇中删除更新操作远多于连接操作的关系\n从聚簇中删除重复出现的关系\n当一个关系同时加入多个聚簇时，必须从这多个聚簇方案（包括不建立聚簇）中选择一个较优的，即在这个聚簇上运行各种事务的总代价最小。\n\n\n\n\n\n\n聚簇的局限性\n\n聚簇只能提高某些特定应用的性能\n建立与维护聚簇的开销相当大\n对已有关系建立聚簇，将导致关系中元组的物理存储位置移动，并使此关系上原有的所有索引无效，必须重建\n当一个元组的聚簇码改变时，该元组的存储位置也要做相应改变\n\n\n当通过聚簇码进行访问或连接是该关系的主要应用，与聚簇码无关的其他访问很少或者是次要的时，可以使用聚簇\n尤其当 SQL 语句中包含有与聚簇码有关的 ORDER BY，GROUP BY，UNION，DISTINCT 等子句或短语时，使用聚簇特别有利，可以省去或减化对结果集的排序操作\n\n\n\n\n\n7.5.3 确定数据库的存储结构\n确定数据库物理结构主要指确定数据的存放位置和存储结构，包括：确定关系、索引、聚簇、日志、备份等的存储安排和存储结构，确定系统配置等\n\n影响数据存放位置和存储结构的因素\n\n硬件环境\n应用需求\n存取时间\n存储空间利用率\n维护代价\n\n\n\n\n\n7.5.4 评价物理结构\n对数据库物理设计过程中产生的多种方案进行评价，从中选择一个较优的方案作为数据库的物理结构。\n\n评价方法\n\n定量估算各种方案\n\n存储空间\n\n存取时间\n\n维护代价\n\n\n\n对估算结果进行权衡、比较，选择出一个较优的合理的物理结构\n\n\n\n\n7.6 数据库的实施和维护7.6.1 数据的载入和应用程序的调试\n数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作\n\n数据装载方法\n人工方法\n计算机辅助数据入库\n\n\n\n\n数据库应用程序的设计应该与数据设计并行进行\n\n在组织数据入库的同时还要调试应用程序\n\n\n\n7.6.2 数据库的试运行\n应用程序调试完成，并且已有一小部分数据入库后，就可以开始对数据库系统进行联合调试，也称数据库的试运行\n\n主要工作包括：\n\n功能测试：实际运行应用程序，执行对数据库的各种操作，测试应用程序的各种功能\n性能测试：测量系统的性能指标，分析是否符合设计目标\n\n\n数据库性能指标的测量\n\n数据库物理设计阶段在评价数据库结构估算时间、空间指标时，作了许多简化和假设，忽略了许多次要因素，因此结果必然很粗糙\n数据库试运行则是要实际测量系统的各种性能指标（不仅是时间、空间指标），如果结果不符合设计目标，则需要返回物理设计阶段，调整物理结构，修改参数；有时甚至需要返回逻辑设计阶段，调整逻辑结构\n\n\n数据库的试运行的注意事项：\n\n数据的分期入库\n重新设计物理结构甚至逻辑结构，会导致数据重新入库\n由于数据入库工作量实在太大，所以可以采用分期输入数据的方法\n先输入小批量数据供先期联合调试使用\n待试运行基本合格后再输入大批量数据\n逐步增加数据量，逐步完成运行评价\n\n\n\n\n数据库的转储和恢复\n在数据库试运行阶段，系统还不稳定，硬、软件故障随时都可能发生\n系统的操作人员对新系统还不熟悉，误操作也不可避免\n因此必须做好数据库的转储和恢复工作，尽量减少对数据库的破坏\n\n\n\n\n\n7.6.3 数据库的运行和维护在数据库运行阶段，对数据库经常性的维护工作主要是由数据库管理员完成的，包括：\n\n数据库的转储和恢复\n数据库的安全性、完整性控制\n数据库性能的监督、分析和改进\n数据库的重组织与重构造\n\n1. 数据库的转储和恢复\n数据库管理员要针对不同的应用要求制定不同的转储计划，定期对数据库和日志文件进行备份\n\n一旦发生故障，即利用数据库备份及日志文件备份，尽快将数据库恢复到某种一致性状态。并尽可能减少对数据库的破坏\n\n\n2. 数据库的安全性、完整性控制\n初始定义\n\n数据库管理员根据用户的实际需要授予不同的操作权限\n根据应用环境定义不同的完整性约束条件\n\n\n修改定义\n\n当应用环境发生变化，对安全性的要求也会发生变化，数据库管理员需要根据实际情况修改原有的安全性控制\n由于应用环境发生变化，数据库的完整性约束条件也会变化，也需要数据库管理员不断修正，以满足用户要求\n\n\n\n3. 数据库性能的监督、分析和改进在数据库运行过程中，数据库管理员必须监督系统运行，对监测数据进行分析，找出改进系统性能的方法\n\n利用监测工具获取系统运行过程中一系列性能参数的值\n\n通过仔细分析这些数据，判断当前系统是否处于最佳运行状态\n\n如果不是，则需要调整参数或对数据库进行重组织或重构造\n\n\n4. 数据库的重组织与重构造为什么要重组织数据库\n\n数据库运行一段时间后，由于记录的不断增、删、改，会使数据库的物理存储变坏，从而降低数据库存储空间的利用率和数据的存取效率，使数据库的性能下降\n\n重组织的形式\n\n全部重组织\n\n部分重组织\n\n只对频繁增、删的表进行重组织\n\n\n\n重组织的目标\n\n提高系统性能\n\n重组织的工作\n\n按原设计要求\n\n重新安排存储位置\n回收垃圾\n减少指针链\n\n\n数据库的重组织不会改变原设计的数据逻辑结构和物理结构\n\n\n数据库管理系统一般都提供了供重组织数据库使用的实用程序，帮助数据库管理员重新组织数据库\n为什么要进行数据库的重构造\n\n数据库应用环境发生变化，会导致实体及实体间的联系也发生相应的变化，使原有的数据库设计不能很好地满足新的需求\n增加新的应用或新的实体\n取消某些已有应用\n改变某些已有应用\n\n\n\n重构造的主要工作\n\n根据新环境调整数据库的模式和内模式\n增加或删除某些数据项\n改变数据项的类型\n增加或删除某个表\n改变数据库的容量\n增加或删除某些索引\n\n\n\n重构造数据库的程度是有限的\n\n若应用变化太大，已无法通过重构数据库来满足新的需求，或重构数据库的代价太大，则表明现有数据库应用系统的生命周期已经结束，应该重新设计新的数据库应用系统了\n\n","categories":["数据库"]},{"title":"第三章 关系数据库标准语言SQL","url":"/2022/06/06/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL/","content":"第三章 关系数据库标准语言SQL3.1 SQL概述\n结构化查询语言（Structured Query Language，SQL），是关系数据库的标准语言，也是一个通用的、功能极强的关系数据库语言\n目前没有一个数据库系统能够支持 SQL 标准的所有概念和特性\n许多软件厂商对 SQL 基本命令集还进行了不同程度的扩充和修改，又可以支持标准以外的一些功能特性\nSQL 的特点\n综合统一\n高度非过程化\n面向集合的操作方式\n以同一种语法结构提供多种使用方式\n语言简洁，易学易用\n\n\n支持 SQL 的关系数据库管理系统同样支持关系数据库三级模式结构，其中外模式包含若干视图和部分基本表，模式包括若干基本表，内模式包含若干存储文件\n基本表\n本身独立存在的表\nSQL 中一个关系就对应一个基本表\n一个（或多个）基本表对应一个存储文件\n一个表可以带若干索引\n\n\n存储文件\n逻辑结构组成了关系数据库的内模式\n物理结构对用户是隐蔽的\n\n\n视图\n从一个或几个基本表导出的表\n数据库中只存放视图的定义而不存放视图对应的数据\n视图是一个虚表\n用户可以在视图上再定义视图\n\n\n\n\n\n\n\n3.2 数据定义\n层次化的数据库对象命名机制\n\n一个关系数据库管理系统的实例中可以建立多个数据库\n一个数据库中可以建立多个模式\n一个模式下通常包括多个表、视图和索引等数据库对象\n\n\n\n\n\n\n\nSQL 的数据定义功能\n\n\n\n\n操作对象\n创建\n删除\n修改\n\n\n\n模式\nCREATE SCHEMA\nDROP SCHEMA\n\n\n\n表\nCREATE TABLE\nDROP TABLE\nALTER TABLE\n\n\n视图\nCREATE VIEW\nDROP VIEW\n\n\n\n索引\nCREATE INDEX\nDROP INDEX\nALTER INDEX\n\n\n3.2.1 模式的定义与删除1. 定义模式\n定义模式实际上定义了一个命名空间。在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等\nSQL 中模式定义语句为\n\nCREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;;\n\n\n在CREATE SCHEMA中可以接受 CREATE TABLE，CREATE VIEW 和 GRANT 子句，即\n\nCREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; [&lt;表定义子句&gt; | &lt;视图定义子句&gt; | &lt;授权定义子句&gt;]\n\n2. 删除模式\nSQL 中删除模式的语句为\n\nDROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;;\n\n\n其中 CASCADE 和 RESTRICT 两者必选其一\n选择了 CASCADE（级联），表示在删除模式的同时把该模式中所有的数据库对象全部删除\n选择了 RESTRICT （限制），表示如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。仅当该模式中没有任何下属的对象时才能执行 DROP SCHEMA 语句\n\n\n\n3.2.2 基本表的定义、删除与修改1. 定义基本表SQL 中定义基本表的格式为\nCREATE TABLE &lt;表名&gt;      (&lt;列名&gt; &lt;数据类型&gt; [&lt;列级完整性约束条件&gt;]      [,&lt;列名&gt; &lt;数据类型&gt;[&lt;列级完整性约束条件&gt;]]    \t\t…      [,&lt;表级完整性约束条件&gt;]);\n\n\n&lt;表名&gt;：所要定义的基本表的名字\n&lt;列名&gt;：组成该表的各个属性（列）\n&lt;列级完整性约束条件&gt;：涉及相应属性列的完整性约束条件\n&lt;表级完整性约束条件&gt;：涉及一个或多个属性列的完整性约束条件 \n如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级\n\n2. 数据类型\nSQL 中域的概念用数据类型来实现\n定义表的属性时需要指明其数据类型及长度 \n一个属性选用哪种数据类型一般从取值范围和要做哪些运算两方面来考虑\n\n3. 修改基本表SQL 中修改基本表的格式为\nALTER TABLE &lt;表名&gt;[ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]][ADD &lt;表级完整性约束&gt;][DROP [COLUMN] &lt;列名&gt; [CASCADE | RESTRICT]][DROP CONSTRAINT &lt;完整性约束名&gt; [RESTRICT | CASCADE]][ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;];\n\n\n&lt;表名&gt;是要修改的基本表\n\nADD 子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件\n\nDROP COLUMN 子句用于删除表中的列\n\n如果指定了 CASCADE 短语，则自动删除引用了该列的其他对象\n\n如果指定了 RESTRICT 短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列\n\n\n\nDROP CONSTRAINT 子句用于删除指定的完整性约束条件\n\nALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型\n\n\n4. 删除基本表SQL 删除基本表的格式为\nDROP TABLE &lt;表名&gt; [RESTRICT| CASCADE];\n\n\n若选择 RESTRICT，则删除表是有限制的：欲删除的基本表不能被其他表的约束所引用，如果存在依赖该表的对象，则此表不能被删除\n若选择 CASCADE，删除该表没有限制：在删除基本表的同时，相关的依赖对象一起删除\n\n3.2.3 索引的建立和删除\n建立索引的目的：加快查询速度\n\n由数据库管理员或表的拥有者建立\n由关系数据库管理系统自动完成维护\n关系数据库管理系统自动使用合适的索引作为存取路径，用户不必也不能显式地选择索引\n\n\n关系数据库管理系统中常见索引：\n\n顺序文件上的索引\nB+树索引\n散列索引\n位图索引\n\n\n\n1. 建立索引建立索引的语句格式为\nCREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;次序&gt;] [,&lt;列名&gt; [&lt;次序&gt;]]…);\n\n\n&lt;表名&gt;：要建索引的基本表的名字\n索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔\n&lt;次序&gt;：指定索引值的排列次序，升序为 ASC，降序为 DESC，缺省值为 ASC\nUNIQUE：此索引的每一个索引值只对应唯一的数据记录\nCLUSTER：表示要建立的索引是聚簇索引\n\n2. 修改索引对于以建立的索引，如果需要对其重新命名，语句格式为\nALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;\n\n3. 删除索引删除索引的语句格式为\nDROP INDEX &lt;索引名&gt;;\n\n3.2.4 数据字典\n数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有定义信息：\n\n关系模式定义\n视图定义\n索引定义\n完整性约束定义\n各类用户对数据库的操作权限\n统计信息等\n\n\n关系数据库管理系统在执行 SQL 的数据定义语句时，实际上就是在更新数据字典表中的相应信息\n\n\n3.3 数据查询SQL 提供了 SELETE 语句进行数据查询，该语句具有灵活的使用方式和丰富的功能，其一般格式为\nSELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [,&lt;目标列表达式&gt;] …FROM &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;…] | (SELECT语句) [AS] &lt;别名&gt;[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名2&gt; [ASC | DESC]];\n\n\nSELECT 子句：指定要显示的属性列\nFROM 子句：指定查询对象（基本表或视图）\nWHERE 子句：指定查询条件\nGROUP BY 子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。\nHAVING 短语：只有满足指定条件的组才予以输出\nORDER BY 子句：对查询结果表按指定列值的升序或降序排序\n\n以下例子均来源于下图的学生-课程数据库\n\n3.3.1 单表查询1. 选择表中的若干列（1）查询指定列\n\n例：查询全体学生的学号与姓名\n\nSELECT Sno, SnameFROM Student; \n\n（2）查询全部列\n\n例：查询全体学生的详细记录\n\nSELECT  *FROM Student;\n\n（3）查询经过计算的值\n\n例：查询全体学生的姓名、出生年份和所在的院系，要求用小写字母表示系名，且使用列别名改变查询结果的列标题\n\nSELECT Sname NAME, 'Year of Birth:' BIRTH, 2014-Sage BIRTHDAY, LOWER(Sdept) DEPARTMENTFROM Student;\n\n查询结果为：（当前年为2014年）\n\n\n\nNAME\nBIRTH\nBIRTHDAY\nDEPARTMENT\n\n\n\n李勇\nYear of Birth:\n1994\ncs\n\n\n刘晨\nYear of Birth:\n1995\ncs\n\n\n王敏\nYear of Birth:\n1996\nma\n\n\n张立\nYear of Birth:\n1995\nis\n\n\n2. 选择表中的若干元组（1）消除取值重复的行\n\n例：查询选修了课程的学生学号\n\nSELECT DISTINCT SnoFROM SC; \n\n（2）查询满足条件的元组\n\n例：查询计算机系年龄在20岁以下的学生姓名\n\nSELECT SnameFROM  StudentWHERE Sdept = 'CS' AND Sage &lt; 20;\n\n3. ORDER BY 子句\n例：查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列\n\nSELECT  *FROM  StudentORDER BY Sdept, Sage DESC;  \n\n4. 聚集函数\n例：计算1号课程的学生平均成绩\n\nSELECT AVG(Grade)FROM    SCWHERE Cno= ' 1 ';\n\n5. GROUP BY 子句\n例：查询平均成绩大于等于90分的学生学号和平均成绩\n\nSELECT  Sno, AVG(Grade)FROM  SCGROUP BY SnoHAVING AVG(Grade) &gt;= 90;\n\n3.3.2 连接查询1. 等值与非等值连接查询\n例：查询每个学生及其选修课程的情况\n\nSELECT  Student.*, SC.*FROM    Student, SCWHERE   Student.Sno = SC.Sno;\n\n2. 自身连接\n例：查询每一门课的间接先修课（即先修课的先修课）\n\nSELECT  FIRST.Cno, SECOND.CpnoFROM  Course  FIRST, Course  SECOND #为Course表取两个别名，一个是FIRST，另一个是SECONDWHERE FIRST.Cpno = SECOND.Cno;\n\n3. 外连接\n例：查询每个学生及其选修课程的情况，保留没有选课的学生\n\nSELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,GradeFROM  Student  LEFT OUT JOIN SC ON (Student.Sno=SC.Sno); \n\n4. 多表连接\n例：查询每个学生的学号、姓名、选修的课程名及成绩\n\nSELECT Student.Sno, Sname, Cname, GradeFROM    Student, SC, CourseWHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno;\n\n3.3.3 嵌套查询\n一个 SELECT-FROM-WHERE 语句称为一个查询块\n\n将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为嵌套查询\n\n子查询不能使用 ORDER BY 子句\n\n不相关子查询：子查询的查询条件不依赖于父查询\n\n由里向外，逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。\n\n\n相关子查询：子查询的查询条件依赖于父查询\n\n首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表\n然后再取外层表的下一个元组\n重复这一过程，直至外层表全部检查完为止\n\n\n\n1. 带有 IN 谓词的子查询\n例：查询选修了课程名为“信息系统”的学生学号和姓名\n\nSELECT  Sno,Sname                 FROM    Student                          WHERE Sno  IN\t\t\t(SELECT Sno                     \t\t\t FROM    SC                      \t\t\t WHERE  Cno IN\t\t\t\t\t\t(SELECT Cno            \t\t\t\t\t\t FROM Course          \t\t\t\t\t\t WHERE Cname= '信息系统'\t\t\t\t\t\t)\t\t\t);\n\n2. 带有比较运算符的子查询\n例：找出每个学生超过他选修课程平均成绩的课程号\n\nSELECT  Sno, CnoFROM    SC  xWHERE Grade &gt;= (SELECT AVG（Grade） \t\t            FROM  SC y\t\t            WHERE y.Sno=x.Sno);\n\n3. 带有 ANY（SOME）或 ALL 谓词的子查询\n例：查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄\n\nSELECT  Sname,SageFROM    StudentWHERE   Sage &lt;ANY (SELECT  Sage                   FROM    Student                   WHERE   Sdept= ' CS ')AND Sdept &lt;&gt; ‘CS ‘ ;/*注意这是父查询块中的条件 */\n\n4. 带有 EXISTS 谓词的子查询\n例：查询所有选修了1号课程的学生姓名\n\nSELECT SnameFROM   StudentWHERE  EXISTS       (SELECT *        FROM SC        WHERE Sno=Student.Sno AND Cno= '1');\n\n3.3.4 集合查询\n集合操作主要包括并操作 UNION、交操作 INTERSECT 和差操作 EXCEPT\n参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同\n\n\n例：查询选修了课程1或者选修了课程2的学生\n\nSELECT SnoFROM SCWHERE Cno = '1'UNIONSELECT SnoFROM SCWHERE Cno = '2';\n\n\n例：查询计算机科学系的学生与年龄不大于19岁的学生的交集（MySQL目前不支持交操作）\n\nSELECT *FROM StudentWHERE Sdept = 'CS' INTERSECTSELECT *FROM StudentWHERE Sage &lt;= 19 \n\n实际上就是查询计算机科学系中年龄不大于19岁的学生\nSELECT *FROM StudentWHERE Sdept = 'CS' AND Sage &lt;= 19;\n\n\n例：查询计算机科学系的学生与年龄不大于19岁的学生的差集（MySQL目前不支持差集操作）\n\nSELECT *FROM StudentWHERE Sdept='CS'EXCEPTSELECT  *FROM StudentWHERE Sage &lt;=19;\n\n实际上是查询计算机科学系中年龄大于19岁的学生\nSELECT *FROM StudentWHERE Sdept = 'CS' AND Sage &gt; 19;\n\n3.3.5 基于派生表的查询\n子查询不仅可以出现在 WHERE 子句中，还可以出现在 FROM 子句中，这时子查询生成的临时派生表成为主查询的查询对象\n如果子查询中没有聚集函数，派生表可以不指定属性列，子查询 SELECT 子句后面的列名为其默认属性\n通过 FROM 子句生成派生表时，AS 关键字可以省略，但必须为派生关系指定一个别名\n\n\n例：找出每个学生超过他自己选修课程平均成绩的课程号\n\nSELECT Sno, CnoFROM SC, (SELECT Sno, Avg(Grade)           FROM SC    \t\t  GROUP BY Sno)          AS Avg_sc(avg_sno,avg_grade)WHERE SC.Sno = Avg_sc.avg_sno and SC.Grade &gt;= Avg_sc.avg_grade\n\n3.3.6 SELECT 语句的一般格式SELECT 语句的一般格式为\nSELECT [All|DISTINCT] &lt;目标表达式&gt; [别名] [,&lt;目标表达式&gt;[别名]]…FROM &lt;表名或视图名&gt; [别名] [,&lt;表名或视图名&gt; [别名]] … | (&lt;SELECT&gt;) [AS] &lt;别名&gt;[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名2&gt; [ASC|DESC]]\n\n\n目标列表达式的可选格式\n\n*\n&lt;表名&gt;. *\nCOUNT ([DISTINCT|ALL])\n&lt;表名或视图名&gt; [别名] [,&lt;表名或视图名&gt; [别名]] …\n\n\n聚集函数的一般格式\n\n\nMissing or unrecognized delimiter for \\left \\left{ \\begin{aligned}[l] &amp; \\mathrm{COUNT} \\ &amp; \\mathrm{SUM}\\ &amp; \\mathrm{AVG}\\ &amp; \\mathrm{MAX}\\ &amp; \\mathrm{MIN} &amp; \\end{aligned} \\right} \\ ([\\mathrm{DISTINCT,  |,  ALL}] \\ \\mbox{&lt;列名&gt;}) \n\nWHERE 子句的条件表达式的可选格式\n\nMissing or unrecognized delimiter for \\left \\mbox{&lt;属性列名&gt;} \\uptheta\\left{ \\begin{aligned}[l] &amp; \\mbox{&lt;属性列名&gt;} &amp;\\ &amp; \\mbox{&lt;常量&gt;} \\ &amp; [\\mathrm{ANY} , |, \\mathrm{ALL}]\\ (\\mathrm{SELECT}, \\mbox{语句}) \\end{aligned} \\right} \n\nMissing or unrecognized delimiter for \\left \\mbox{&lt;属性列名&gt;} \\mathrm{[NOT]\\ BETWEEN}\\left{ \\begin{aligned}[l] &amp; \\mbox{&lt;属性列名&gt;} &amp;\\ &amp; \\mbox{&lt;常量&gt;} \\ &amp; (\\mathrm{SELECT}, \\mbox{语句}) \\end{aligned} \\right} \\ \\mathrm{AND}\\  \\left{ \\begin{aligned}[l] &amp; \\mbox{&lt;属性列名&gt;} &amp;\\ &amp; \\mbox{&lt;常量&gt;} \\ &amp; (\\mathrm{SELECT}, \\mbox{语句}) \\end{aligned} \\right} \n\n$$\\mbox{&lt;属性列名&gt;} \\mathrm{[NOT]\\ IN}\\left{\\begin{aligned}[l]&amp; (\\mbox{&lt;值1&gt; \\ [,&lt;值2&gt; …]}) \\\n&amp; (\\mathrm{SELECT}, \\mbox{语句})\\end{aligned}\\right}$$\n\n&lt;属性列名&gt; [NOT] LIKE &lt;匹配串&gt;\n\n&lt;属性列名&gt; IS [NOT] NULL\n\n[NOT] EXISTS (SELECT语句)\n\nMissing or unrecognized delimiter for \\left \\mbox{&lt;条件表达式&gt;} \\left{ \\begin{aligned}[l] &amp;\\mathrm{AND}  \\ &amp;\\mathrm{OR} \\end{aligned} \\right}\\ \\mbox{&lt;条件表达式&gt;} \\left( \\left{ \\begin{aligned}[l] &amp;\\mathrm{AND}  \\ &amp;\\mathrm{OR} \\end{aligned} \\right}\\mbox{&lt;条件表达式&gt;}… \\right) \n\n\n\n\n3.4 数据更新3.4.1 插入数据1. 插入元组插入元组的 INSERT 语句的格式为\nINSERTINTO &lt;表名&gt; [(&lt;属性列1&gt;[,&lt;属性列2&gt; …)]VALUES (&lt;常量1&gt;[,&lt;常量2&gt;] …);\n\n\n对于INTO 子句\n\n指定要插入数据的表名及属性列\n属性列的顺序可与表定义中的顺序不一致\n没有指定属性列时，表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致\n指定部分属性列时，插入的元组在其余属性列上取空值\n\n\n对于 VALUES 子句，提供的值的个数和值的类型必须与 INTO 子句匹配\n\n\n\n例：将一个新学生元组插入到 Student 表中\n\nINSERTINTO  Student (Sno,Sname,Ssex,Sdept,Sage)VALUES ('201215128','陈冬','男','IS',18);\n\n2. 插入子查询结果插入子查询结果的 INSERT 语句格式为\nINSERT INTO &lt;表名&gt; [(&lt;属性列1&gt; [,&lt;属性列2&gt;…)]子查询;\n\n\n例：对每一个系，求学生的平均年龄，并把结果存入数据库\n\n首先在数据库中建立一个新表，其中一列存放系名，另一列存放相应的学生平均年龄\nCREATE TABLE Dept_age            (Sdept CHAR(15)                                      Avg_age SMALLINT)\n\n然后对 Student 按系分组求平均年龄，再把系名和平均年龄存入新表中\n3.4.2 修改数据修改操作又称为更新操作，其语句的一般格式为\nUPDATE &lt;表名&gt;SET &lt;列名&gt; = &lt;表达式&gt;[,&lt;列名&gt; = &lt;表达式&gt;]…[WHERE &lt;条件&gt;];\n\n\n其功能是修改指定表中满足 WHERE 子句条件的元组\nSET 子句给出&lt;表达式&gt;的值用于取代相应的属性列\n如果省略 WHERE 子句，表示要修改表中的所有元组\n\n\n例：将计算机科学系全体学生的成绩置零\n\nUPDATE SCSET Grade=0WHERE Sno IN\t\t (SELETE Sno      FROM Student      WHERE Sdept = 'CS');\n\n3.4.3 删除数据删除语句的一般格式为\nDELETEFROM &lt;表名&gt;[WHERE &lt;条件&gt;];\n\n\nDELETE 语句的功能是从指定表中删除满足 WHERE 子句条件的所有元组\n如果省略 WHERE 语句则表示删除表中的所有元组，但表的定义仍在字典中\nDELETE 语句删除的是表中的数据，而不是关于表的定义\n\n\n例：删除计算机科学系所有学生的选课记录\n\nDELETEFROM SCWHERE Sno IN\t\t\t(SELETE  Sno\t\t\tFROM  Student\t\t\tWHERE Sdept = 'CS');\n\n3.5 空值的处理\n空值就是“不知道”或“不存在”或“无意义”的值\n\nSQL 语言允许某些元组的某些属性在一定情况下取空值，一般有以下几种情况：\n\n该属性应该有一个值，但目前不知道它的具体值\n该属性不应该有值\n由于某种原因不便于填写\n\n\n空值是一个很特殊的值，含有不确定性。对关系运算带来特殊的问题，需要做特殊的处理\n\n\n1.空值的产生\n\n例：向SC表中插入一个元组，学生号是“201215126”，课程号是”1”，成绩为空\n\nINSERT INTO SC(Sno,Cno,Grade)VALUES('201215126', '1', NULL);   \n\n2.空值的判断\n\n例：从Student表中找出漏填了数据的学生信息\n\nSELECT  *FROM StudentWHERE Sname IS NULL OR Ssex IS NULL OR Sage IS NULL OR Sdept IS NULL;\n\n3.空值的约束条件\n属性定义（或者域定义）中有 NOT NULL 约束条件的不能取空值，加了 UNIQUE 限制的属性不能取空值，码属性不能取空值\n4.空值的算数运算、比较运算和逻辑运算\n\n空值与另一个值（包括另一个空值）的算术运算的结果为空值\n\n空值与另一个值（包括另一个空值）的比较运算的结果为 UNKNOWN\n\n有 UNKNOWN 后，传统二值（TRUE，FALSE）逻辑就扩展成了三值逻辑\n\n\n\n\n\n在查询语句中，只有使 WHERE 和 HAVING 子句的选择条件为 TRUE 的元组才被选出作为输出结果\n\n\n例：选出选修1号课程的不及格的学生以及缺考的学生\n\nSELECT SnoFROM SCWHERE Cno = '1' AND (Grade &lt; 60 OR Grade IS NULL);/*或者*/SELECT SnoFROM SCWHERE Grade &lt; 60 AND Cno = '1'UNIONSELECT SnoFROM SCWHERE Grade IS NULL AND Cno = '1'\n\n3.6 视图\n视图是从一个或几个基本表（或视图）导出的虚表\n数据库中只存放视图的定义，而不存放视图对应的数据\n一旦基表中的数据发生变化，从视图中查询出的数据也随之改变\n\n3.6.1 定义视图3.6.1.1 建立视图SQL 语言用 CREATE VIEW 命令建立视图，其一般格式为\nCREATE VIEW &lt;视图名&gt; [(&lt;列名&gt; [,&lt;列名&gt;]…)]AS &lt;子查询&gt;[WITH CHECK OPTION];\n\n\n子查询可以是任意的 SELECT 语句，是否可以含有 ORDER BY 子句和 DISTINCT 短语，则取决于具体系统的实现\nWITH CHECK OPTION 表示对视图进行 UPDATE，INSERT 和 DELETE 操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）\n组成视图的属性列名或者全部省略或者全部指定\n如果省略了视图的各个属性列名，则隐含该视图由子查询中 SELECT 子句目标列中的诸字段组成\n下列情况必须指定组成视图的所有列名\n某个目标列是聚集函数或列表达式\n多表连接时选出了几个同名列作为视图的字段\n需要在视图中为某个列启用新的更合适的名字\n\n\n\n\n例：建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生\n\nCREATE VIEW IS_StudentAS SELECT Sno, Sname, SageFROM  StudentWHERE  Sdept = 'IS'WITH CHECK OPTION;\n\n3.6.1.2 删除视图删除视图的语句格式为\nDROP VIEW &lt;视图名&gt;[CASCADE];\n\n\n该语句从数据字典中删除指定的视图定义\n如果该视图上还导出了其他视图，使用 CASCADE 级联删除语句，把该视图和由它导出的所有视图一起删除 \n删除基表时，由该基表导出的所有视图定义都必须显式地使用 DROP VIEW 语句删除\n\n3.6.2 查询视图关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表、视图等是否存在。如果存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后在执行修正了的查询。这一转换过程称为视图消解。\n\n例：查询选修了1号课程的信息系学生\n\nSELECT IS_Student.Sno,SnameFROM IS_Student,SCWHERE IS_Student.Sno = SC.Sno AND SC.Cno = '1';\n\n3.6.3 更新视图\n由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换成对基本表的更新\n像查询视图一样，对视图的更新操作也是通过视图消解，转换为对基本表的更新操作\n一般地，行列子集视图是可更新的\n对其他类型视图的更新不同系统有不同限制。一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新\n\n\n例：将信息系学生视图 IS_Student 中学号“201215122”的学生姓名改为”刘辰”\n\nUPDATE IS_StudentSET Sname= '刘辰'WHERE Sno = '201215122';\n\n转换后的更新语句为：\nUPDATE StudentSET Sname = '刘辰'WHERE Sno = '201215122' AND Sdept = 'IS';\n\n3.6.4 视图的作用\n视图能够简化用户的操作\n视图使用户能以多种角度看待同一数据，适应数据库共享的需要\n视图对重构数据库提供了一定程度的逻辑独立性\n视图能够对机密数据提供安全保护\n适当的利用视图可以更清晰的表达查询\n\n","categories":["数据库"]},{"title":"第三章 程序的机器级表示","url":"/2022/06/06/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/","content":"第三章 程序的机器级表示计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码。GCC C语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。\n3.1 程序编码\n假设一个C程序，有两个文件p1.c和p2.c。用Unix命令行编译这些代码：\nlinux&gt; gcc -0g -o p p1.c p2.c\n\n\n\n命令gcc指的就是GCC C编译器。因为这是Linux上默认的编译器，也可以简单地用cc来启动它。\n编译选项-0g告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。\n实际中，从得到的程序的性能考虑，较高级别的优化（例如，以选项-01或-02指定）被认为是较好的选择。\n\n实际上gcc命令调用了一整套的程序，将源代码转化为可执行代码：\n\n首先， C预处理器扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏。\n其次，编译器产生两个源文件的汇编代码，名字分别为p1.s和p2.s。\n接下来，汇编器会将汇编代码转化成二进制目标代码文件p1.o和p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。\n最后，链接器将两个目标代码文件与实现库函数（例如printf）的代码合并，并产生最终的可执行代码文件p（由命令行指示符-o p指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。\n\n\n\n3.1.1 机器级代码对于机器级编程来说，其中两种抽象尤为重要：\n\n由指令集体系结构或指令集架构（Instruction Set Architecture, ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA, 包括x86-64, 将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。\n机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。\n\nx86-64的机器代码中一些通常对C语言程序员隐藏的处理器状态都是可见的：\n\n程序计数器（通常称为“PC”，在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址。\n整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于C语言中的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。\n条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，例如用来实现if和while语句。\n一组向量寄存器可以存放一个或多个整数或浮点数值。\n\n机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。\n程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用malloc库函数分配的）。程序内存用虚拟地址来寻址。\n3.1.2 代码示例1. 编译器\nC语言代码文件mstore.c中包含如下的函数定义\nlong mult2(long, long);void multstore(long x,long y,long *dest){  long t = mult2(x,y);  *dest = t;}\n\n\n在命令行上运行linux&gt; gcc -0g -S mstore.c产生一个汇编文件mstore.s：\n         .file   \"010-mstore.c\"         .text            .globl  multstore         .type   multstore,@fuctionmultstore:                  pushq   %rbx         movq    %rbx, %rbx         call    mult2         movq    %rax, (%rbx)         popq    %rbx         ret         .size   multstore, .-multstore         .ident  \"GCC:(Ubuntu 4.8.1-2ubuntu1~12.04)4.8.1\"         .section       .note.GNU-stack,\"\",@progbits     \n\n\n所有以“.”开头的行都是指导汇编器和连接器工作的伪指令，通常可以忽略这些行。为了更清楚地说明汇编代码，用这样一种格式来表示汇编代码，它省略了大部分伪指令，但包括行号和解释性说明。对于本例该代码如下：\nvoid multstore(long x, long y, long *dest)x in %!r(MISSING)di, y in %!r(MISSING)si, dest in %!r(MISSING)dxmultstore:    pushq     %rbx             Save %!r(MISSING)bx    moveq     %rbx, %rbx       Copy dest to %!r(MISSING)bx    call      mult2            Call mult2(x,y)    movq      %rax, (%rbx)     Store result at *dest    popq      %rbx             Restore %!r(MISSING)bx    ret                        Return\n\n\n汇编代码相比C语言有以下特点：\n\n有许多不同类型的整型数据类型，它们存储时不区分符号和无符号\n指针是以简单的数字的形式保存在计算机中的\n浮点数以和整型数据完全不同的方式进行处理，并且使用完全不同的寄存器组\n程序本身是一系列字节\n机器级别并不存在类似数组和结构这样的基本数据类型，它们是由编译器构成的\n汇编语言中的每条语言能做的都非常有限\n变量所有名称在汇编代码级别完全丢失了，变成了寄存器和内存中的某个位置\n\n2.汇编器\n运行gcc -Og -c mstore.c来进行编译和汇编，会生成二进制文件mstore.o，它是对一系列指令的编码，机器直接执行这些字节序列，而对源代码一无所知。\n可以通过反汇编器来将机器代码转化为类似汇编代码的格式，在Linux中，运行objdump -d mstore.o，可以得到：\nDisassembly of function multstore in binary file mstore.o0000000000000000 &lt;multstore&gt;Offset   Byte                     Equivalent assembly language    0:   53                       push      %rbx    1:   48 89 d3                 move      %rbx, %rbx    4:   e8 00 00 00 00           callq     9 &lt;multstore+0x9&gt;    9:   48 89 03                 mov       %rax, (%rbx)    c:   5b                       pop      %rbx    d:   c3                       retq\n\n\n最左侧一栏是对应的字节地址，中间是每个指令的编码，右侧是等价的汇编语言。其中一些关于机器代码和它的反汇编表示的特性值得注意：\n\nx86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。\n设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq  %rbx是以字节值53开头的。\n反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。\n反汇编器使用的指令命名规则与GCC 生成的汇编代码使用的有些细微的差别。在示例中，它省略了很多指令结尾的‘q’。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call和ret指令添加了‘q’后缀，同样，省略这些后缀也没有问题。\n\n3.链接器\n生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数。假设在文件main.c中有下面这样的函数：\n#include &lt;stdio.h&gt;void multstore(long, long ,long*)int main(){  long d;  multstore(2, 3, &amp;d);  printf(\"2 * 3 --&gt; %ld\\n\",d);  return 0;}long mult2(long a, long b){  long s = a * b;  return s;} \n\n\n然后运行命令linux&gt; gcc -0g -o prog main.c mstore.c将main.c和mstore.c链接起来，并添加启动和终止程序的代码，以及用来与操作系统交互的代码生成可执行代码，最终生成可执行文件prog。通过对其反汇编，可以得到如下内容：\nDisassembly of function sum multstore binary file prog0000000000400540 &lt;multstore&gt;400540:   53                       push      %rbx400541:   48 89 d3                 move      %rbx, %rbx400544:   e8 42 00 00 00           callq     40058b &lt;mult2&gt;400549:   48 89 03                 mov       %rax, (%rbx)40054c:   5b                       pop       %rbx40054d:   c3                       retq40054e:   90                       nop40054f:   90                       nop\n\n\n可以看出，这段代码与mstore.c反汇编产生的代码的区别有：\n\n左边列出的地址不同，链接器将这段代码的地址移到了一段不用的地址范围中\n链接器填上了callq指令调用函数mult2需要使用的地址（第5行）。链接器的任务之一就是为函数调用找到匹配的函数可执行代码的位置。\n多了两行代码（第9和10行）。插入这些指令是为了使函数代码变为16字节，使得就存储器系统性能而言，能更好地放置下一个代码块。\n\n3.2 数据格式\n\n大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种：movb（传送字节）、movw（传送字）、movl（传送双字）和movq（传送四字）。注意，汇编代码使用后缀‘l’来表示4字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。\n3.3 访问信息\n一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器。这些寄存器都用来存储整数数据和指针，名字都以%r开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。\n\n\n当指令以寄存器作为目标时，对于生成小于8字节结果的指令，对于寄存器中剩下的字节会怎么样有两条规则：生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0。\n有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。\n3.3.1 操作数指示符大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据可以以常数形式给出，或是从寄存器或内存中读出，结果可以存放在寄存器或内存中。\n\n各种不同的操作数的可能性被分为三种类型：\n1.立即数（immediate），用来表示常数值。书写方式是‘$’后跟一个用标准C表示法的整数。不同指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。\n2.寄存器（register），表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数。用符号表示任意寄存器，用引用表示它的值。\n3.内存（memory）引用，根据计算出来的地址（通常称为有效地址）访问某个内存位置。用符号表示对存储在内存中从地址开始的个字节值的引用，通常省去下标。\n有多种不同的寻址模式，允许不同形式的内存引用。是最常用的形式。这个引用有四个组成部分：一个立即数偏移，一个基址寄存器，一个变址寄存器和一个比例因子且必须是1、2、4或8。基址和变址寄存器都必须是64位寄存器。有效地址被计算为。其他形式都是这种通用形式的特殊情况。\n3.3.2 数据传送指令最频繁的指令是将数据从一个位置复制到另一个位置的指令。\n\n\n源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。\n大多数情况中， MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。\n在下面的MOV指令示例中，第一个是源操作数，第二个是目的操作数。\nmovl $0x4050,%eax                Immediate--Register, 4 bytesmovw %bp,%sp                     Register--Register,  2 bytesmovb (%rbi,%rcx),%al             Memory--Register,    1 bytemovb $-17,(%rsp)                 Immediate--Memory,   1 bytemovq %rax,-12(%rbp)              Register--Memory,    8 bytes\n\n\nmovabsq是处理64位立即数数据的。常规的movq指令只能以表示32位补码数字的立即数作为源操作数，然后将其符号拓展为64位放到目的位置。而movabsq能以64位立即数为源操作数，并且只能以寄存器作为目的。\n下图的数据移动指令在将较小的源值复制到较大的目的时使用。每条指令的最后两个字符都是大小指示符：第一个字符指定源的大小，第二个指明目的的大小。\n\n\n3.3.3 数据传送示例对于下面的C代码\nlong exchange(long *xp, long y){   long x = *xp;   *xp = y;   return x;}\n\n\n对应的汇编代码如下，其中寄存器%rdi和%rsi分别存放参数xp和y\nlong exchange(long *xp, long y)xp in %!r(MISSING)di, y in %!r(MISSING)siexchage:   movq     (%rdi), %rax            Get x at xp. Set as return value.   movq     %rsi, (%rdi)            Store y at xp.   ret                              Return.\n\n\n关于这段汇编代码有两点值得注意：\n\nC语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。\n像x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。\n\n3.4.4 压入和弹出栈数据栈是一种数据结构，可以添加或者删除值，不过要遵循“后进先出”的原则。通过push操作把数据压入栈中，通过pop操作删除数据；它具有一个属性：弹出的值永远是最近被压入而且仍然在栈中的值。\n\n\n栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为栈顶。\npushq指令的功能是把数据压入到栈上，而popq指令是弹出数据。这些指令都只有一个操作数一一压入的数据源和弹出的数据目的。\n将一个四字值压人栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此，指令pushq %rbp的行为等价于下面两条指令：\nsubq $8, %rsp               Decrement stack pointermovq %rbp, (%rsp)           Store %!r(MISSING)bp on stack\n\n\n弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8。因此，指令popq %rax等价于下面两条指令：\n\n\n图中前两栏给出的是，当%rsp为0x108，%rax为0x123时，执行指令pushq %rax的效果。首先%rsp会减8，得到0x100，然后会将0x123存放到内存地址0x100处。第三栏说明的是在执行完pushq后立即执行指令popq %rdx的效果。先从内存中读出值0x123，再写到寄存器%rdx中，然后，寄存器%rsp的值将增加回到0x108。如图中所示，值0x123仍然会保持在内存位置0xl00中，直到被覆盖（例如被另一条入栈操作覆盖）。无论如何，%rsp指向的地址总是栈顶。\n3.4 算术和逻辑操作\n下图中的指令类（除leaq外）有各种带不同大小操作数的变种。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。\n\n\n3.4.1 加载有效地址加载有效地址指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。这条指令可以为后面的内存引用产生指针，也可以简洁地描述普通的算术操作，例如：\nlong scale(long x, long y, long z){  long t = x + 4 * y + 12 * z;  return t;} \n\n\n编译时，该函数的算术运算以三条leap指令实现：\n  long scale(long x, long y, long z)  x in %!r(MISSING)di, y in %!r(MISSING)si, z in %!r(MISSING)dxscale:  leaq    (%rdi,%rsi,4), %rax       x + 4*y  leaq    (%rdx,%rdx,2), %rdx       z + 2*z = 3*z  leaq    (%rax,%rdx,4), %rax       (x+4*y) + 4*(3*z) = x + 4*y + 12*z  ret\n\n\nleaq指令能执行加法和有限形式的乘法，在编译如上简单的算术表达式时，是很有用处的。\n3.4.2 一元和二元操作对于一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。例如incq(%rsp)会使栈顶的8字节元素加1。\n而二元操作中，第二个操作数既是源又是目的。这种语法类似于C语言中的x-=y，不过源操作数是第一个，目的操作数是第二个。第一个操作数可以是立即数、寄存器或内存位置，第二个操作数可以是寄存器或内存位置。注意，当第二个操作数为内存地址时，处理器必须从内存中读出值，执行操作，再把结果写回内存。\n例：假设下面的值存放在指定的内存地址和寄存器中：\n\n\n给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值：\n\n\n\n地址\n目的\n值\n\n\n\naddq %rcx, (%rax)\n0x100\n0x100\n\n\nsubq %rdx, 8(%rax)\n0x108\n0xA8\n\n\nimulq $16, (%rax,%rdx,8)\n0x118\n0x110\n\n\nincq 16(%rax)\n0x110\n0x14\n\n\ndecq %rcx\n%rcx\n0x0\n\n\nsubq %rdx, %rax\n%rax\n0xFD\n\n\n3.4.3 移位操作移位操作首先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器%cl中（只允许这个特定的寄存器作为操作数）。\n例如，下面的C语言代码：\nlong shift_left4_rightn(long x, long n){  x &lt;&lt;= 4;  x &gt;&gt;= n;  return x;}  \n\n\n其对应的汇编代码为：\n  long shift_left4_rightn(long x, long n)  x in %!r(MISSING)di, n in %!r(MISSING)sishift_left4_rightn:  movq      %rdi, %rax      Get x  salq      $4, %rax        x &lt;&lt;= 4  movl      %esi, %ecx      Get x (4 bytes)  sarq      %cl, %rax       x &gt;&gt;= n \n\n\n3.4.4 算术操作示例C语言代码：\nlong arith(long x, long y, long z){  long t1 = x ^ y;  long t2 = z * 48;  long t3 = t1 &amp; 0x0F0F0F0F;  long t4 = t2 - t3;  return t4;\n\n\n汇编代码：\nlong arith(long x, long y, long z)x in %!r(MISSING)di, y in %!r(MISSING)si, z in %!r(MISSING)dxarith:  xorq     %rsi, %rdi                 t1 = x ^ y  leaq     (%rdx, %rdx, 2), %rax      3 * z  salq     $4, %rax                   t2 = 16 * (3*z) = 48*z  andl     $252645135, %edi           t3 = t1 &amp; 0x0F0F0F0F  subq     %rdi, %rax                 Return t2 - t3  ret  \n\n\n3.4.5 特殊的算术操作两个64位有符号或无符号整数相乘得到的乘积需要128位来表示，x86-64指令集对128位（16字节，8字）数的操作提供有限的支持。\n\n\nimulq可以用于两个不同的乘法的操作，其中一种是从两个64位操作数产生64位乘积的双操作数指令；另一种是计算两个64位的全128位补码乘积的单操作数指令。\n例如，在小端机器上运行下面的C代码：\n#include &lt;inttypes.h&gt;typedef unsigned __int128 uint128_t;void store_uprod(uint128_t *dest, uint64_t x, uint64_t y){  *dest = x * (uint128_t) y;}\n\n\nGCC生成的汇编代码为：\nvoid store_uprod(uint128_t *dest, uint64_t x, uint64_t y)dest in %!r(MISSING)di, x in %!r(MISSING)si, y in %!r(MISSING)dxstore_uprod:    movq        %rsi, %rax            Copy x to multiplicand    mulq        %rdx                  Multiply by y    movq        %rax, (%rdi)          Store lower 8 bytes at dest    movq        %rdx, 8(%rdi)         Store upper 8 bytes at dest+8    ret \n\n\n对于除法和取模操作，由单操作数除法指令提供。有符号除法指令idivl将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器%rax中，将余数存储在寄存器%rdx中。\n对于更普遍的64位的被除数除法而言，被除数被存放在%rax中，%rdx的位应全设置为0（无符号运算）或者%rax的符号位（有符号运算）。后面这个操作可以用指令cqto完成，这个指令不需要操作数，它隐含读出%rax的符号位，并将它复制到%rdx的所有位。\n例如下面计算两个64位有符号数的商和余数的C语言代码：\nvoid remdiv(long x, long y, long *qp, long *rp){  long q = x/y;  long r = x%y;  *qp = q;  *rp = r;} \n\n\n汇编代码为：\nvoid remdiv(long x, long y, long *qp, long *rp)x in %!r(MISSING)di, y in %!r(MISSING)si, qp in %!r(MISSING)dx, rp in %!r(MISSING)cxremdiv:  movq       %rdx, %r8           Copy qp  movq       %rdi, %rax          Move x to lower 8 bytes of dividend  cqto                           Sign-extend to upper 8 bytes of dividend  idivq      %rsi                Divide by y  movq       %rax, (%r8)         Store quotient at qp  movq       %rdx, (%rcx)        Store remainder at rp  ret        \n\n\n在上述代码中，必须首先把参数qp保存到另一个寄存器中（第4行），因为除法操作要使用参数寄存器%rdx。接下来，第5~6行准备被除数，复制并符号扩展x。除法之后，寄存器%rax中的商被保存在qp（第8行），而寄存器%rdx中的余数被保存在rp（第9行）。\n3.5 控制\n机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。\n与数据相关的控制流是实现有条件行为的更一般和更常见的方法。\n用jump指令可以改变一组机器代码指令的执行顺序，jump指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。编译器必须产生构建在这种低级机制基础之上的指令序列，来实现C语言的控制结构。\n3.5.1 条件码除了整数寄存器，CPU还维护一组单个位的条件码寄存器，最常用的条件码有：\n\nCF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。\nZF：零标志。最近的操作得出的结果为0。\nSF：符号标志。最近的操作得到的结果为负数。\nOF：溢出标志。最近的操作导致一个补码溢出（正溢出或负溢出)。\n\n除了leaq之外，图3-10（3.4节首图）中列出的所有指令都会设置条件码。对于逻辑操作，进位标志和溢出标志会设置成0。对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为0。INC和DEC指令会设置溢出和零标志，但不会改变进位标志。\n除了上述指令，还有如下图所示的两类指令，它们只设置条件码而不改变任何其他寄存器\n\n\nCMP和SUB指令、TEST和AND指令行为一样，除了只设置条件码而不更新寄存器。对于CMP指令，如果两个数一样，会将零标志设置为1；对于TEST指令的典型用法是检查数字的正负（testq %rax, %rax），或其中一个操作数是一个掩码，用来指示哪些位应该被测试。\n3.5.2 访问条件码常用的条件码使用功能有3种：\n\n可以根据条件码的某种组合，将一个字节设置为0或者1\n可以条件跳转到程序的某个其他的部分\n可以有条件地传送数据\n\n对于第一种情况，由下图中的SET指令实现\n\n\n一个计算C语言表达式a &lt; b的典型指令序列为：（这里a和b都是long类型）\nint comp(data_t a, data_t b)a in %!r(MISSING)di, b in %!r(MISSING)sicomp:  cmpq     %rsi, %rdi       Compare a:b  注意比较顺序  setl     %al              Set low-order byte of %!e(MISSING)ax to 0 or 1  movzbl   %al, %eax        Clear reset of %!e(MISSING)ax (and rest of %!r(MISSING)ax)  movzbl指令不光会把%!e(MISSING)ax的高3个字节清零，还会把整个寄存器%!r(MISSING)ax的高4个字节都清零。  ret\n\n\n3.5.3 跳转指令\n\njmp指令是无条件跳转。可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。\n汇编语言中，直接跳转是给出一个编号作为跳转目标，例如jmp .L1，间接跳转是“*”后面跟一个操作数指示符，例如jmp *%rax用寄存器%rax中的值作为跳转目标，jmp *(%rax)以%rax中的值作为读地址，从内存中读出跳转目标。\n其他跳转指令都是有条件的——它们根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。\n3.5.4 跳转指令的编码跳转指令最常用的编码是PC相对的，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之差作为编码。\n下面是一个PC相对寻址的例子：\n  movq          %rdi, %rax  jmp           .L2.L3:  sarq          %rax.L2:  testq         %rax, %rax  jg            .L3  rep; ret\n\n\n汇编器产生的反汇编版本为：\n0:     48 89 f8         mov      %rdi, %rax3:     eb 03            jmp      8 &lt;loop+0x8&gt;5:     48 d1 f8         sar      %rax8:     48 85 c0         test     %rax, %raxb:     7f f8            jg       5 &lt;loop+0x5&gt;d:     f3 c3            repz retq\n\n\n右边反汇编器产生的注释中，第2行中跳转指令的跳转目标指明为0x8，第5行中跳转指令的跳转目标是0x5（反汇编器以十六进制格式给出所有的数字）。不过，观察指令的字节编码，会看到第一条跳转指令的目标编码（在第二个字节中）为0x03。把它加上0x5，也就是下一条指令的地址，就得到跳转目标地址0x8，也就是第4行指令的地址。\n类似地，第二个跳转指令的目标用单字节、补码表示编码为0xf8（-8）。将这个数加上0xd（13）即第6行指令的地址，得到0x5, 即第3行指令的地址。\n当执行PC相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。\n例1 下面je指令的目标是什么\n4003fa: 74 02           je     XXXXXX     //0x4003fc + 0x02 = 0x4003fe4003fc: ff d0           callq  *%rax\n\n\n例2 下面je指令的目标是什么\n40042f: 74 f4           je XXXXXX        //0x400431 + 0xf4 (-12) = 0x400425400431: 5d              \n\n\n例3 ja和pop指令的地址是多少\nX1: 77 02           ja   400547         //X1 + 2 = X2,             X1=400543X2: 5d              pop  %rbp           //X2 + 0x02 = 0x400547,    X2=400545\n\n\n3.5.5 用条件控制来实现条件分支","categories":["CSAPP笔记"]},{"title":"第二章 信息的表示和处理","url":"/2022/06/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","content":"第二章 信息的表示和处理2.1 信息存储\n大多数计算机使用8 位的块，或者字节 （byte）, 作为最小的可寻址的内存单位。\n机器级程序将内存视为一个非常大的字节数组，称为虚拟内存 （virtual memory） 。\n内存的每个字节都由一个唯一的数字来标识，称为它的地址 （address）。\n所有可能地址的集合就称为虚拟地址空间 （virtual address space），这个虚拟地址空间只是一个展现给机器级程序的概念性映像。\n2.1.1 十六进制表示法十六进制表示、十六进制和十进制的互相转换。\n2.1.2 字数据大小每台计算机都有一个字长 （word size）， 指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为位的机器而言，虚拟地址的范围为，程序最多访问个字节。\n32 位字长限制虚拟地址空间为4 千兆字节（写作4GB，1G=）, 也就是说，刚刚超过字节。扩展到64 位字长使得虚拟地址空间为16EB, 大约是字节。\n\n可移植性： 许多程序员假设一个声明为int 类型的程序对象能被用来存储一个指针。这在大多数32 位的机器上能正常工作，但是在一台64 位的机器上却会导致问题。\n2.1.3 寻址和字节顺序对于跨越多字节的程序对象，必须建立两个规则：这个对象的地址是什么 ，以及在内存中如何排列这些字节 。\n在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。\n某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，称为小端法 （little endian）；而另一些机器则按照从最高有效字节到最低有效字节的顺序存储，称为大端法 （big endian）。\n以int类型的变量x为例，假设其位于地址0x100处，它的16进制值为0x01234567。地址范围0x100~0x103的字节顺序依赖于机器的类型：\n\n\n在有些时候，字节顺序会成为问题：\n\n是在不同类型的机器之间通过网络传送二进制数据时， 一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关千字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。\n\n当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在阅读由反汇编器生成的机器级代码时。\n\n当编写规避正常的类型系统的程序时。\n\n\n打印程序对象的字节表示： \n#include &lt;stdio.h&gt;typedef unsigned char *byte_pointer;//用typedef将数据类型byte_pointer定义为一个指向类型为unsigned char的对象的指针void show_bytes(byte_pointer start,size_t len){//输入参数是一个字节序列的地址，用一个字节指针和一个字节数来表示。  size_t i;  for(i = 0;i &lt; len;i++){    printf(\"%.2x\",start[i]);//表示整数必须用至少两个数字的十六进制格式输出。  }  printf(\"\\n\");}//打印出每个以十六进制表示的字节。void show_int(int x){//&amp;x被强制类型转换为\"unsigned char *\"，即把这个指针看成指向一个字节序列的对象  show_bytes((byte_pointer) &amp;x,sizeof(int));//使用sizeof增加可移植性}void show_float(float x){  show_bytes((byte_pointer) &amp;x,sizeof(float));}void show_pointer(void *x){  show_bytes((byte_pointer) &amp;x,sizeof(void *));}void test_show_bytes(int val){  int ival = val;  float fval = (float) ival;  int *pval = &amp;ival;  show_int(ival);  show_float(fval);  show_pointer(pval);} \n\n\n2.1.4 表示字符串C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。\n在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。\n\n2.1.5 表示代码对于下面的C函数\nint sum(int x,int y){  return x+y;}\n\n\n在不同机器上生成的字节表示的机器代码是不同的：\nLinux 32    55 89 e5 8b 45 0c 03 45 08 c9 c3Windows     55 89 e5 8b 45 0c 03 45 08 5d c3Sum         81 c3 e0 08 90 02 00 09Linux 64    55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3\n\n\n不同的机器类型使用不同的且不兼容的指令和编码方式，二进制代码是不兼容的。\n计算机系统的一个基本概念是，从机器的角度来看，程序仅仅只是字节序列。\n2.1.6 布尔代数简介\n2.1.7 C语言中的位运算C语言使用的符号和布尔运算中使用的符号相同：|就是或，&amp;就是与，~就是取反，^就是异或\n位级运算的一个常见用法就是实现掩码 运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。例如：掩码0xFF（最低的8 位为1）表示一个字的低位字节。位级运算x&amp;0xFF生成一个由x的最低有效字节组成的值，而其他的字节就被置为0 。比如，对于x=0x89ABCDEF其表达式将得到0x000000EF\n2.1.8 C语言中的逻辑运算C语言中的逻辑运算符||、&amp;&amp;和!分别对应于命题逻辑中的OR、AND和NOT运算。\n逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。它们返回1或0，分别表示结果为TRUE或者FALSE。例如：\n\n\n2.1.9 C语言中的移位运算对于一个位表示为的操作数\n左移运算： x&lt;&lt;k生成位表示为的值。即向左移动位，丢弃最高的位，并在右端补个0。\n右移运算： x&gt;&gt;k，分为逻辑右移 和算术右移 。逻辑右移在左端补个0，得到结果是；算术右移在左端补个最高有效位的值，得到的结果是。\n\n\nC 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移，但是，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多程序员也都假设机器会使用这种右移。\nJava对于如何进行右移有明确的定义，x&gt;&gt;k会将x进行算术右移，而x&gt;&gt;&gt;k会对x进行逻辑右移。\n对于一个由位组成的数据类型，当移动位时，实际位移量是通过计算得到的。例如，假设数据类型int为\nint      lval = 0xFEDCBA98  &lt;&lt; 32; //0xFEDCBA98int      aval = 0xFEDCBA98  &lt;&lt; 36; //0xFFEDCBA9unsigned uval = 0xFEDCBA98u &gt;&gt; 40; //0x00FEDCBA\n\n\n2.2 整数表示\n\n2.2.1 整数数据类型\n\n\nC数据类型\n32位\n64位\n\n\n\n[signed]char\n\n\n\n\nunsigned char\n\n\n\n\nshort\n\n\n\n\nunsigned short\n\n\n\n\nint\n\n\n\n\nunsigned long\n\n\n\n\nlong\n\n\n\n\nunsigned long\n\n\n\n\nint32_t\n\n\n\n\nuint_t\n\n\n\n\nint64_t\n\n\n\n\nuint64_t\n\n\n\n\nC和C++都支持有符号数（默认）和无符号数，Java只支持有符号数。\n2.2.2 无符号数的编码无符号数编码的定义： 对于向量：\n\n位所能表示的值的范围为：最小是0，最大是\n2.2.3 补码编码补码编码的定义： 对于向量：\n\n位所能表示的值的范围为：最小是，最大是\n\n2.2.4 有符号数和无符号数之间的转换补码转换为无符号数： 对满足的有：\n\n无符号数转换为补码： 对满足的有：\n\n的表示可以通过把 的反码加1得到，即“ 取反加1 ”。 （无论是负数转换为无符号数，还是无符号转换为负数都适用）\n2.2.5 C语言中的有符号数与无符号数显式强制类型转换：\nint tx,ty;unsigned ux,uy;tx = (int) ux;uy = (unsigned) ty;\n\n\n隐式类型转换：\nint tx,ty;unsigned ux,uy;tx = ux; //转换为有符号数uy = ty; //转换为无符号数\n\n\n在32位机器上运行以下代码： \nint x = -1;//1111 1111 1111 1111 1111 1111 1111 1111,0xFFFF FFFFunsigned u = 2147483648; //2^31,1000 0000 0000 0000 0000 0000 0000 0000,0x8000 0000printf(\"x = %u = %d\\n\",x,x); //x = 429497295 = -1printf(\"u = %u = %d\\n\",u,u); //u = 2147483648 = -2147483648\n\n\n2.2.6 拓展一个数字的位表示无符号数的零拓展： 定义宽度为的位向量和宽度为的位向量，其中。则。\n补码数的符号拓展： 定义宽度为的位向量和宽度为的位向量，其中。则。\n2.2.7 截断数字int x = 53191; //0000 0000 0000 0000 1100 1111 1100 0111short sx = (short) x; //-12345int y = sx; //-12345    12345-&gt;0011 0000 0011 1001\n\n\n截断无符号数： 令等于位向量，而是将其截断为位的结果：。令,。则。\n截断补码数值： 令等于位向量，而是将其截断为位的结果：。令,。则。\n2.2.8 关于有符号数与无符号数的建议**/* WARNING: This is buggy code. */** float sum_elements(float a[],unsigned length){  int i;  float result = 0;    for(i = 0;i &lt;= lenght-1;i++){    result += a[i];  }  return result;}\n\n\n当参数length等于0时，运行上面的代码应该返回0.0，可实际上运行时会遇到一个内存错误。\n因为参数length是无符号的，计算0-1将使用无符号运算，这等价于模数加法。结果得到。同样使用无符号数比较，而因为任何数都小于等于，所以总是为真，因此代码将试图访问数组a的非法元素。\n2.3 整数运算\n2.3.1 无符号加法无符号数加法（ ）： 对满足的和有：正常溢出\n检测无符号数加法中的溢出： 对在范围中的和，令。则对计算，当且仅当（或等价地）时，发生了溢出。\n无符号数求反：对满足的任意，其位的无符号逆元由下式给出：\n\n2.3.2 补码加法补码加法： 对满足的整数和，有：\n正溢出正常负溢出\n\n\n检测补码加法中的溢出： 对满足的和，令。当且仅当，但时，计算发生了正溢出。当且仅当，但时，计算发生了负溢出。\n2.3.3 补码的非补码的非： 对满足的，其补码的非由下式给出\n\n补码非的位级表示： （1）对每一位求补，再对结果加1（取反加1）\n\n\n（2）设是最右边的1的位置（从右往左数的第一个1），因而的位级表示形如，这个值的非写成二进制格式就是。也就是对位左边的所有位取反。\n2.3.4 无符号乘法无符号数乘法： 对满足的和有：\n\n2.3.5 补码乘法补码乘法： 对满足的和有：\n\n无符号和补码乘法的位级等价性： 给定长度为的位向量和，用补码形式的位向量表示来定义整数和：。用无符号形式的位向量表示来定义非负整数和：。则\n\n2.3.6 乘以常数乘以2的幂： 设为位模式表示的无符号整数。那么，对于任何，都认为给出了的位的无符号表示，这里右边增加了个\n与2的幂相乘的无符号乘法： C变量x和k有无符号数值和，且，则C表达式x&lt;&lt;k产生数值。\n与2的幂相乘的补码乘法： C变量x和k有补码值和无符号数值，且，则C表达式x&lt;&lt;k产生数值。\n由于整数乘法比移位和加法的代价要大得多，许多C语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况。例如对于表达式x*14，编译器会将其重写为(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)或(x&lt;&lt;4)-(x&lt;&lt;1)。\n2.3.7 除以2的幂除以2的幂的无符号除法： C变量x和k有无符号数值和，且，则C表达式x&gt;&gt;k产生数值。\n\n除以2的幂的补码除法，向下舍入： C变量x和k有补码值和无符号数值，且，则当执行算术移位时，C表达式x&gt;&gt;k产生数值。\n\n除以2的幂的补码除法，向上舍入： C变量x和k有补码值和无符号数值，且，则当执行算术移位时，C表达式(x+(1&lt;&lt;k)-1)&gt;&gt;k产生数值。\n\n对于使用算术右移的补码机器，C表达式(x&lt;0 ? x+(1&lt;&lt;k)-1 : x) &gt;&gt; k将会计算数值。\n\n写一个函数div16，对于整数参数x返回x/16的值。函数中不能使用除法、模运算、乘法、任何条件语句、任何比较运算符或任何循环。假设数据类型int是32位长，使用补码表示，右移是算术右移。\n\n/* 利用表达式x&gt;&gt;31产生一个字，如果x是负数，这个字为全1，否则为全0。   通过掩码屏蔽掉适当的位就可以得到期望的偏置值 */int div16(int x){  /* Compute bias to be either 0(x &gt;=0) or 15(x &lt; 0) */  int bias = (x&gt;&gt;31) &amp; 0xF;  return (x+bias) &gt;&gt;4;}\n\n\n2.4 浮点数\n浮点数对形如的有理数进行编码。\n2.4.1 二进制小数考虑一个形如\n\n的表示法，其中每个二进制数字，或者称为位，的取值范围是0和1，如下图所示。这种表示方法表示的数定义如下：\n\n\n\n2.4.2 IEEE浮点表示IEEE浮点数标准用的形式来表示一个数：\n\n符号： 决定这数是负数（）还是正数（），而对于数值0的符号位解释作为特殊情况处理\n\n尾数： 是一个二进制小数，它的范围是，或者是\n\n阶码： 的作用是对浮点数加权，这个权重是2的次幂（可能是负数）\n\n\n将浮点数的位表示划分为三个字段，分别对这些值进行编码：\n\n一个单独的符号位直接编码符号\n\n位的阶码字段exp=编码阶码\n\n位小数字段frac=编码尾数，但是编码出来的值也依赖于阶码字段的值是否等于0\n\n\n在单精度浮点格式中，s、exp和frac字段分别为位、 位和 位 ，得到一个32位的表示。在双精度浮点格式中，s、exp和frac字段分别为位、 位和 位 ，得到一个64位的表示。\n\n\n给定位表示，根据exp的值，被编码的值可以分成三种不同的情况：\n\n\n情况1：规格化的值 \n当exp的位模式既不全为0，又不全为1时，都属于这类情况。在这种情况中，阶码字段被解释为以偏置形式表示的有符号整数。也就是说，阶码的值是，其中是无符号数，其位表示为，而是一个等于（单精度是127，双精度是1023） 的偏置量。由此产生指数的取值范围，对于单精度是 ，而对于双精度是 。\n小数字段frac被解释为描述小数值，其中，其二进制表示为，也就是二进制小数点在最高有效位的左边。尾数定义为。这种方式也叫隐含的以1开头 的表示，因为可以把看成一个二进制表达式为的数字。实际上是用23位来表示一个24位的数字。\n情况2：非规格化的值 \n当阶码域全为0时，所表示的数是非规格化的形式。在这种情况下， 阶码值是（单精度是 ，双精度是 ），而尾数的值是，也就是小数字段的值，没有隐含的开头的1。\n情况3：特殊值 \n这一类数值是当阶码域全为1时出现的。当小数域全为0时，得到的值表示无穷，当时是正无穷，当时是负无穷。当小数域为非0时，表示。\n2.4.3 数字示例\n\n2.4.4 舍入\n向偶数舍入也被称为向最接近的值舍入，是默认的方式，试图找到一个最接近的匹配值。它将数字向上或者向下舍入，使得结果的最低有效数字是偶数。\n其他三种方式产生实际值的确界。向零舍入方式把正数向下舍入，把负数向上舍入，得到值，使得。向下舍入方式把正数和负数都向下舍入，得到值，使得。向上舍入方式把正数和负数都向上舍入，得到值，满足。\n对于向偶数舍入来讲，它最大的作用是在统计时使用。向偶数舍入可以让我们在统计时，将舍入产生的误差平均，从而尽可能的抵消 。而其它三种方式在这方面都是有一定缺陷的，向上和向下舍入会造成值的偏大或偏小。而对于向零舍入来讲，如果全是正数的时候则会造成结果偏小，全是负数的时候则会造成结果偏大。\n向偶数舍入规则 ：例如有效数字超出规定数位的多余数字是1001，它大于超出规定最低位的一半（即0.5），故最低位进1。如果多余数字是0111，它小于最低位的一半，则舍掉多余数字（截断尾数）即可。对于多余数字是1000（正好是最低位一半）的特殊情况，若最低位为0则舍掉多余位，最低为1则进位1，使得最低位仍为0（偶数）。 \n\n\n\n舍入前\n舍入后（舍入到最接近的二分之一）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.4.5 浮点运算\n浮点加法不具有结合性。 例如，(3.14+1e10)-1e10结果为0.0，而3.14+(1e10-1e10)结果为3.14。\n\n浮点加法满足单调性： 如果，那么对于任何及的值，除了，都有。无符号或补码加法不具有这个性质。\n\n浮点乘法是可交换的，不具有结合性，在加法上不具有分配性，满足单调性，且只要 ，就有 。\n\n\n2.4.6 C语言中的浮点数\n所有的C语言版本提供了两种不同的浮点数据类型：float和double。在支持IEEE浮点格式的机器上，这些数据类型就对应于单精度和双精度浮点。\n\n这类机器使用向偶数舍入的舍入方式。\n\n因为C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍入方式或者得到诸如、、或者之类的特殊值。\n\n可以通过引入库函数math.h定义程序常数INFINITY和NAN。\n\n从float或double转换成int时，值会向零舍入。进一步来说，值可能会溢出。C语言标准没有对这种情况指定固定的结果。与Intel兼容的微处理器指定位模式（字长为时的）为整数不确定值。一个从浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生这样一个值。因此(int) 1e10会得到-2147483648，即从一个正值变为一个负值。\n\n\n2.5 小结\n计算机将信息编码为位（比特），通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。\nC语言的设计可以包容多种不同字长和数字编码的实现。64位字长的机器逐渐普及，并正在取代统治市场长达30多年的32位机器。由于64位机器也可以运行为32位机器编译的程序，我们的重点就放在区分32位和64位程序，而不是机器本身。64位程序的优势是可以突破32位程序具有的4GB地址限制。\n大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码。在位级上理解这些编码，并且理解算术运算的数学特性，对于想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。\n在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现遵循的原则是底层的位模式不变。在补码机器上，对于一个位的值，这种行为是由函数和来描述的。C语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误。\n由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于, 从而转换成零时，也会下溢。\n和大多数其他程序语言一样， C语言实现的有限整数运算和真实的整数运算相比，有一些特殊的属性。例如，由于溢出，表达式x*x 能够得出负数。但是，无符号数和补码的运算都满足整数运算的许多其他属性，包括结合律、交换律和分配律。这就允许编译器做很多的优化。例如，用(x&lt;&lt;3)-x取代表达式7*x时，我们就利用了结合律、交换律和分配律的属性，还利用了移位和乘以2 的幂之间的关系。\n我们已经看到了几种使用位级运算和算术运算组合的聪明方法。例如，使用补码运算， ~x+1等价于-x。另外一个例子，假设我们想要一个形如的位模式，由个后面紧跟着个组成。这些位模式有助于掩码运算。这种模式能够通过C表达式(1&lt;&lt;k)-1生成，利用的是这样一个属性，即我们想要的位模式的数值为。例如，表达式(1&lt;&lt;8)-1将产生位模式0xFF。\n浮点表示通过将数字编码为的形式来近似地表示实数。最常见的浮点表示方式是由IEEE标准754定义的。它提供了几种不同的精度，最常见的是单精度（32位）和双精度（64位）。IEEE浮点也能够表示特殊值、和 。\n必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且并不遵守普遍的算术属性，比如结合性。\n","categories":["CSAPP笔记"]},{"title":"第五章 运输层","url":"/2022/06/06/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/","content":"第五章 运输层5.1 运输层协议概述5.1.1 进程之间的通信\n物理层、数据链路层以及网络层共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信\n但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程\n如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议\n\n\n\n\n运输层有一个很重要的功能——复用（multiplexing）和分用（demultiplexing）\n“复用“是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据\n“分用”是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程\n\n\n运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道\n\n\n\n5.1.2 运输层的两个主要协议TCP/IP 运输层的两个主要协议都是互联网的正式标准，即\n\n用户数据报协议 UDP（User Datagram Protocol）\nUDP 在传送数据之前不需要先建立连接\n远地主机的运输层在收到 UDP 报文后，不需要给出任何确认\n虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。\n\n\n传输控制协议 TCP（Transmission Control Protocol）\nTCP 则提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接\nTCP 不提供广播或多播服务\n由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源\n\n\n\n\n\n使用 UDP 和 TCP 协议的各种应用和应用层协议\n\n\n\n应用\n应用层协议\n运输层协议\n\n\n\n名字转换\nDNS（域名系统）\nUDP\n\n\n文件传送\nTFTP（简单文件传送协议）\nUDP\n\n\n路由选择协议\nRIP（路由信息协议）\nUDP\n\n\nIP 地址配置\nDHCP（动态主机配置协议）\nUDP\n\n\n网络管理\nSNMP（简单网络管理协议）\nUDP\n\n\n远程文件服务器\nNFS（网络文件系统）\nUDP\n\n\nIP 电话\n专用协议\nUDP\n\n\n流式多媒体通信\n专用协议\nUDP\n\n\n多播\nIGMP（网际组管理协议）\nUDP\n\n\n电子邮件\nSMTP（简单邮件传送协议）\nTCP\n\n\n远程终端接入\nTELNET（远程终端协议）\nTCP\n\n\n万维网\nHTTP（超文本传送协议）\nTCP\n\n\n文件传送\nFTP（文件传送协议）\nTCP\n\n\n5.1.3 运输层的端口\n在单个计算机中的进程是用进程标识符 PID 来标志的\n因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符\n为了使运行不同操作系统的计算机的应用进程能够互 相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志\nTCP/IP 体系的运输层使用端口号来区分应用层的不同应用进程\n端口号用16比特表示，取值范围为 \n熟知端口号：数值为 ，IANA 把这些端口号指派给了 TCP/IP 体系中最重要的一些应用程序\n登记端口号：数值为 ，为没有熟知端口号的应用程序使用，使用这类端口号必须在 IANA 按照规定的手续登记，以防止重复\n短暂端口号：数值为 ，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚才已使用过的客户端口号就不复存在，这个端口号就可以供其他客户进程使用\n\n\n端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中，不同计算机中的相同端口号是没有联系的\n\n\n\n常用的熟知端口号：\n\n\n\n应用程序\nFTP\nTELNET\nSMTP\nDNS\nTFTP\nHTTP\nSNMP\nSNMP（trap）\nHTTPS\n\n\n\n端口号\n21\n23\n25\n53\n69\n80\n161\n162\n443\n\n\n5.2 用户数据报协议UDP5.2.1 UDP概述UDP 的主要特点是：\n\nUDP 是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延\nUDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表\nUDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层，这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文\n\n\n\n\nUDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的\nUDP 支持一对一、一对多、多对一和多对多的交互通信\nUDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短\n\n5.2.2 UDP的首部格式用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段很简单，只有 8 个字节，由四个字段组成，每个字段的长度都是两个字节。各字段意义如下：\n\n源端口：源端口号。在需要对方回信时选用。不需要时可用全0\n目的端口：目的端口号。这在终点交付报文时必须使用\n长度：UDP用户数据报的长度，其最小值是8（仅有首部）\n检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃\n\n\n\nUDP 用户数据报首部中检验和的计算方法\n\n在计算检验和时，要在 UDP 用户数据报之前增加 12 个字节的伪首部\n\n所谓“伪首部”是因为这种伪首部并不是 UDP 用户数据报真正的首部。只是在计算检验和时，临时添加在 UDP 用户数据报前面，得到一个临时的 UDP 用户数据报\n\n检验和就是按照这个临时的 UDP 用户数据报来计算的\n\n伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和\n\nUDP 计算检验和的方法和计算 IP 数据报首部检验和的方法相似。但不同的是：IP 数据报的检验和只检验 IP 数据报的首部，但 UDP 的检验和是把首部和数据部分一起都检验\n\n\n5.3 传输控制协议TCP概述5.3.1 TCP最主要的特点\nTCP 是面向连接的运输层协议。这就是说，应用程序在使用TCP协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接\n每一条 TCP 连接只能有两个端点（endpoint），每一条 TCP 连接只能是点对点的\nTCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达\nTCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据\n面向字节流。虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。TCP 并不知道所传送的字节流的含义。TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样\n\n\n5.3.2 TCP的链接\nTCP 把连接作为最基本的抽象\nTCP 连接的端点叫做套接字（socket）或插口。根据 RFC 793 的定义：端口号拼接到（concatenated with)）IP 地址即构成了套接字，即\n\n套接字地址端口号\n\n每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：\n\n连接\n5.4 TCP报文段的首部格式TCP 报文段首部的前 20 个字节是固定的，后面有  字节是根据需要而增加的选项，因此 TCP 首部的最小长度是 20 字节\n\n首部固定部分各字段的意义如下：\n（1）源端口和目的端口\n各占 2 字节（16 位），分别写入源端口号和目的端口号\n（2）序号\n\n占 4 字节，取值范围是 ，序号增加到  后，下一个序号就又回到 0\n用来指出本 TCP 报文段数据载荷的第一个字节的序号\n\n（3）确认号\n\n占 4 字节，取值范围是 ，确认号增加到  后，下一个确认号就又回到 0，\n用来指出期望收到对方下一个 TCP 报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。\n若确认号，则表明到序号  为止的所有数据都已正确接收，期望接收序号为  的数据\n\n（4）数据偏移\n\n占 4 位，并且以 4 字节为单位\n用来指出 TCP 报文段的数据载荷部分的起始处距离 TCP 报文段的起始处有多远\n这个字段实际上是指出了 TCP 报文段的首部长度\n首部固定长度为 20 字节，因此数据偏移字段的最小值为 \n首部最大长度为 60 字节，因此数据偏移字段的最大值为 \n\n\n\n（5）保留\n占 6 位，保留为今后使用，但目前应置为 0\n（6）紧急 URG（urgent）\n\n当 URG = 1 时，表明紧急指针字段有效\n\n它告诉系统此报文段中有紧急数据，应尽快传送，而不要按原来的排队顺序来传送\n\n\n（7）确认 ACK（acknowledge）\n\n仅当 ACK = 1 时确认号字段才有效；当 ACK = 0 时，确认号无效\n\nTCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1\n\n\n（8）推送 PSH（push）\n接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付\n（9）复位 RST（reset）\n\n当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接\nRST 置 1 还用来拒绝一个非法的报文段或拒绝打开一个连接\n\n（10）同步 SYN（synchronization）\n在 TCP 连接建立时用来同步序号\n（11）终止 FIN（finish）\n用来释放 TCP 连接\n（12）窗口\n\n占 2 字节，以字节为单位，指出发送本报文的一方的接受窗口\n窗口值作为接收方让发送方设置其发送窗口的依据\n这是以接收方的接收能力来控制发送方的发送能力，称为流量控制\n\n（13）检验和\n\n占 2 字节，检查范围包括 TCP 报文段的首部和数据载荷两部分\n在计算检验和前，要在 TCP 报文段的首部加上 12 字节的伪首部\n\n（14）紧急指针\n占 2 字节。紧急指针仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数\n（15）选项\n长度可变，最长可达 40 字节。\n5.5 TCP可靠传输的实现5.5.1 以字节为单位的滑动窗口假定现在 A 收到了 B 发来的确认报文段，其中窗口是 20 字节，确认号是 31，根据这两个数据，A 构造出自己的发送窗口如下\n\n\n发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用\n现在假定 A 发送了序号为  的数据。这时，发送窗口位置并未改变， 但发送窗口内靠后面有 11 个字节（灰色小方框表示）表示已发送但未收到确认。而发送窗口内靠前面的 9 个字节是允许发送但尚未发送的\n\n假设 B 收到了序号为 32 和 33 的数据。这些数据没有按序到达，因为序号为 31 的数据没有收到（也许丢失了，也许滞留在网络中的某处），因此 B 向 A 发送确认号为 31 的确认报文段\n\n现在假定 B 收到了序号为 31 的数据，并把序号为  的数据交付主机，然后 B 删除这些数据。接着把接收窗口向前移动 3 个序号，同时给 A 发送确认，其中窗口值仍为 20，但确认号是 34\nA 收到 B 的确认后，就可以把发送窗口向前滑动 3 个序号\n\nA在继续发送完序号  的数据后，发送窗口内的序号都已用完，但还没有再收到确认，由于 A 的发送窗口已满，可用窗口已减小到零，因此必须停止发送\n\nA 在经过一段时间后（由超时计时器控制）重传这部分数据，重新设置超时计时器，直到收到 B 的确认为止。如果 A 收到确认号落在发送窗口内，那么 A 就可以使发送窗口继续向前滑动，并发送新的数据\n根据上面所讨论的例子，还有以下三点需要注意：\n\n虽然 A 的发送窗口是根据 B 的接收窗口设置的，但在同一时刻，A 的发送窗口并不总是和 B 的接收窗口一样大\n这是因为通过网络传送窗口值需要经历一定的时间滞后\n另外发送方 A 还可能根据网络当时的拥塞情况适当减小自己的发送窗口数值\n\n\n对于不按序到达的数据应如何处理，TCP 标准并无明确规定\n如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利\n因此 TCP 通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程\n\n\nTCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上\n接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源\nTCP 标准规定，确认推迟的时间不应超过 0.5 秒\n若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认\n\n\n捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据\n\n\n\n5.5.2 超时重传时间的选择\nTCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT \nTCP 保留了 RTT 的一个加权平均往返时间 \n每当第一次测量到 RTT 样本时， 值就取为所测量到的 RTT 样本值。但以后每测量到一个新的 RTT 样本，就按下式重新计算一次 ：\n\n新的旧的新的样本\n\nRFC 6298 推荐  的取值为 0.125\n显然，超时计时器设置的超时重传时间 RTO 应略大于上面得出的加权平均往返时间 。RFC 6298 建议使用下式计算 RTO：\n\n\n\n 是 RTT 的偏差的加权平均值，它与  和新的 RTT 样本之差有关。RFC 6298 建议计算 ：当第一次测量时， 值取为测量到的 RTT 样本值的一半，在以后的测量中，则使用下式计算加权平均的 （其中  的建议取值为 0.25）：\n\n新的旧的新的样本\n对于上面的算法若发生超时重传则会出现问题，如何判定此确认报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认？\n\n\n\n若收到的确认是对重传报文段的确认，但却被源主机当成是对原来的报文段的确认， 则这样计算出的  和超时重传时间 RTO 就会偏大\n若收到的确认是对原来的报文段的确认，但被当成是对重传报文段的确认，则 由此计算出的 和 RTO 都会偏小\n\n对此，Karn 提出了一个算法：在计算加权平均  时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均  和 RTO 就较准确\n但是，这又引起新的问题。设想出现这样的情况：报文段的时延突然增大了很多。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新\n因此要对 Karn 算法进行修正。方法是：报文段每重传一次，就把超时重传时间 RTO 增大一些。典型的做法是取新的重传时间为旧的重传时间的 2 倍。当不再发生报文段的重传时，才根据上面的式子计算超时重传时间\n5.6 TCP的流量控制流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收\n\n注：下图中起始时 B 的接收窗口为 400 字节，图中未直接画出\n\n\n现在考虑这样一种情况，上图中 B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。然而这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去\n为了解决这个问题，TCP 为每一个连接设有一个持续计时器（persistence timer）。只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。\n5.7 TCP的拥塞控制\n在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞（congestion）\n\n若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降\n\n\n\n\nTCP 进行拥塞控制的算法有四种， 即慢开始（slow-start） 、拥塞避免（congestionavoidance）、快重传（fast retransmit）和快恢复（fast recovery）\n为了集中精力讨论拥塞控制，下面假定：\n\n数据是单方向传送的，对方只传送确认报文\n接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定\n\n1. 慢开始和拥塞避免\n发送方维护一个叫做拥塞窗口 cwnd 的状态变量，其值取决于网络的拥塞程度，并且动态变化\n拥塞窗口 cwnd 的维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些；但只要网络出现拥塞，拥塞窗口就减小一些\n判断发生网络拥塞的依据：没有按时收到应当到达的确认报文（即发生超时重传）\n\n\n发送方将拥塞窗口作为发送窗口 swnd，即 swnd = cwnd\n维护一个慢开始门限 ssthresh 状态变量：\n当 cwnd &lt; ssthresh 时，使用慢开始算法\n当 cwnd &gt; ssthresh 时，停止使用慢开始算法，而改用拥塞避免算法\n当 cwnd = ssthresh 时，既可以使用慢开始算法，也可以使用拥塞避免算法\n\n\n\n慢开始算法的思路是：当主机开始发送数据时，由于并不清楚网络的负荷情况，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值\n慢开始规定，在每收到一个对新报文段的确认后，可以把拥塞窗口增加最多一个 SMSS（发送方最大报文段）的数值，如下面例子所示\n\n注：下图中以报文段的个数作为窗口大小的单位，以传输轮次作为时间单位。一个传输轮次所经历的时间是往返时间 RTT，使用“传输轮次”是为了强调把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认\n\n\n\n拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加1，而不是像慢开始阶段那样加倍增长\n\n2. 快重传和快恢复\n慢开始和拥塞避免算法是 1988 年提出的 TCP 拥塞控制算法（TCP Tahoe 版本）\n\n1990 年又增加了两个新的拥塞控制算法（改进 TCP 的性能），这就是快重传和快恢复（TCP Reno 版本）\n\n有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞\n这将导致发送方超时重传，并误认为网络发生了拥塞\n发送方把拥塞窗口 cwnd 又设置为最小值 1，并错误地启动慢开始算法，因而降低了传输效率\n\n\n\n\n采用快重传算法就可以让发送方尽早知道发生了个别报文段的丢失\n\n\n所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传\n\n要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认\n即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认\n发送方一旦收到 3 个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传\n对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口 cwnd 为1）。使用快重传可以使整个网络的吞吐量提高约 20%\n\n\n\n发送方一旦收到 3 个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法\n\n发送方将慢开始门限 ssthresh 值和拥塞窗口 cwnd 值调整为当前窗口的一半，开始执行拥塞避免算法\n也有的快恢复实现是把快恢复开始时的拥塞窗口 cwnd 值再增大一些，即等于新的 ssthresh + 3\n既然发送方收到 3 个重复的确认，就表明有 3 个数据报文段已经离开了网络\n这 3 个报文段不再消耗网络资源而是停留在接收方的接收缓存中\n可见现在网络中不是堆积了报文段而是减少了 3 个报文段，因此可以适当把拥塞窗口扩大些\n\n\n\n5.8 TCP的运输连接管理在 TCP 连接建立过程中要解决以下三个问题：\n\n要使每一方能够确知对方的存在。\n要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）\n能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配\n\nTCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户（client），而被动等待连接建立的应用进程叫做服务器（server）\n5.8.1 TCP的连接建立\n开始时，B 的 TCP 服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求。然后服务器进程就处于 LISTEN（收听）状态，等待客户的连接请求。如有，即作出响应。\nA 的 TCP 客户进程也是首先创建传输控制模块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN = 1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态\nB 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务器进程进入 SYN-RCVD（同步收到）状态\nTCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态\n当 B 收到 A 的确认后，也进入 ESTABLISHED 状态\nA 最后还要发送一次确认的原因：主要为了防止已失效的连接请求报文段突然又传送到了 B，因而产生错误，即下图所示情况\n\n5.8.2 TCP的连接释放\n数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于 ESTABLISHED 状态\nA 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP连接。A把连接释放报文段首部的终止控制位 FIN 置1，其序号 seq = u，它等于前面已传送过的数据的最后一个字节的序号加 1。这时 A 进入 FIN-WAIT-1（终止等待 1）状态，等待 B 的确认。请注意，TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号\nB 收到连接释放报文段后即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v，等于 B 前面已传送过的数据的最后一个字节的序号加 1。然后 B 就进入 CLOSE- WAIT（关闭等待）状态。\nTCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间\nA 收到来自 B 的确认后，就进入 FIN-WAIT-2（终止等待 2）状态，等待 B 发出的连接释放报文段\n若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。现假定 B 的序号为 w （在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入**LAST-ACK(最后确认)**状态，等待 A 的确认\nA 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号是 seq = u + 1，然后进入到 TIME-WAIT（时间等待）状态\n现在 TCP 连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT timer）设置的时间 2MSL 后，A 才进入到 CLOSED 状态\n\n时间 MSL 叫做最长报文段寿命（Maximum Segment Lifetime），RFC 793 建议设为 2 分钟。但这完全是从工程上来考虑的，对于现在的网络，MSL = 2 分钟可能太长了一些。因此 TCP 允许不同的实现可根据具体情况使用更小的 MSL 值\n\nB 只要收到了 A 发出的确认，就进入 CLOSED 状态\nA 在 TIME-WAIT 状态必须等待 2MSL 时间的原因：\n\n防止下图所示情况的出现\n\n\n\n防止“已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现旧的连接请求报文段\n\n\n\nTCP 服务器进程每收到一次 TCP 客户进程的数据，就重新设置并启动保活计时器（2小时定时）\n若保活计时器定时周期内未收到 TCP 客户进程发来的数据，则当保活计时器到时后，TCP 服务器进程就向 TCP 客户进程发送一个探测报文段，以后则每隔 75 秒钟发送一次。若一连发送 10 个探测报文段仍无 TCP 客户进程的相应，TCP 服务器进程就认为 TCP 客户进程所在主机出了故障，接着就关闭这个连接\n\n5.8.3 TCP的有限状态机\n","categories":["计算机网络"]},{"title":"第六章 应用层","url":"/2022/06/06/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/","content":"第六章 应用层\n应用层协议应当定义：\n\n应用进程交换的报文类型，如请求报文和响应报文\n各种报文类型的语法，如报文中的各个字段及其详细描述\n字段的语义，即包含在字段中的信息的含义\n进程何时、如何发送报文，以及对报文进行响应的规则\n\n应用层的许多协议都是基于客户服务器方式。即使是 P2P 对等通信方式，实质上也是一种特殊的客户服务器方式\n\n客户和服务器都是指通信中所涉及的两个应用进程\n\n客户服务器方式所描述的是进程之间服务和被服务的关系\n\n这里最主要的特征就是：客户是服务请求方，服务器是服务提供方\n\n\n6.1 域名系统DNS6.1.1 域名系统概述\n域名系统 DNS（Domain Name System）是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址\n\n互联网的域名系统 DNS 被设计成为一个联机分布式数据库系统，并采用客户服务器方式\n\nDNS 使大多数名字都在本地进行解析（resolve），仅少量解析需要在互联网上通信，因此 DNS 系统的效率很高\n\n域名到 IP 地址的解析是由分布在互联网上的许多域名服务器程序（可简称为域名服务器）共同完成的\n\n域名到 IP 地址的解析过程的要点如下：\n\n当某一个应用进程需要把主机名解析为 IP 地址时，该应用进程就调用解析程序（resolver），并成为 DNS 的一个客户，把待解析的域名放在 DNS 请求报文中，以 UDP 用户数据报方式发给本地域名服务器（使用 UDP 是为了减少开销）\n本地域名服务器在查找域名后，把对应的 IP 地址放在回答报文中返回。应用进程获得目的主机的 IP 地址后即可进行通信\n若本地域名服务器不能回答该请求，则此域名服务器就暂时成为 DNS 中的另一个客户，并向其他域名服务器发出查询请求。这种过程直至找到能够回答该请求的域名服务器为止\n\n\n\n6.1.2 互联网的域名结构\n因特网采用层次树状结构的域名结构\n\n域名的结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名三级域名二级域名顶级域名\n\n每一级的域名都由英文字母和数字组成，不超过 63 个字符，不区分大小写字母\n级别最低的域名写在最左边，而级别最高的顶级域名写在最右边\n完整的域名不超过 255 个字符\n\n\n域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思\n\n各域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构 ICANN 进行管理\n\n顶级域名 TLD（top level domain）分为以下三类：\n\n国家顶级域名 nTLD：采用 ISO 3166 的规定，如 cn 表示中国，us 表示美国，uk 表示英国等\n通用顶级域名 gTLD：最常见的通用顶级域名有七个，即 com（公司企业）、net（网络服务机构）、org（非营利性组织）、int（国际组织）、edu（美国教育机构）、gov（美国政府部门）、mil（美国军事部门）\n基础结构域名（infrastructure domain）：这种域名只有一个，即 arpa，用于反向域名解析，因此又称为反向域名\n\n\n在国家顶级域名下注册的二级域名均由该国家自行确定。例如，顶级域名为 jp 的日 本，将其教育和企业机构的二级域名定为 ac 和 co，而不用 edu 和 com\n\n我国将二级域名划分为以下两类：\n\n类别域名：共七个，ac（科研机构）、com（工、商、金融等企业）、edu（教育机构）、gov（政府部门）、net（提供网络服务的机构）、mil（军事机构）和org（非营利性组织）\n行政区域名：共 34 个，适用于我国的各省、自治区和直辖市\n\n\n\n\n\n6.1.3 域名服务器\n\n\n\n\n域名和 IP 地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS 使用分布在各地的域名服务器来实现域名到 IP 地址的转换\n\n域名服务器可以划分为以下四种不同的类型：\n\n根域名服务器：根域名服务器是最高层次的域名服务器。每个根域名服务器都知道所有的顶级域名服务器的域名及其 IP 地址。因特网上共有 13 个不同 IP 地址的根域名服务器，尽管我们将这 13 个根域名服务器中的每一个都视为单个的服务器，但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。当本地域名服务器向根域名服务器发出查询请求后时，路由器就把查询请求报文转发到离这个 DNS 客户最近到一个根域名服务器。这就加快了 DNS 的查询过程，同时也更合理地利用了因特网的资源。根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的 IP 地址\n顶级域名服务器：这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）\n权限域名服务器：这些域名服务器负责管理某个区的域名。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其所管辖的域名与 IP 地址的映射关系。另外，权限域名服务器还知道其下级域名服务器的地址\n本地域名服务器：本地域名服务器并不属于上述域名服务器层次结构。当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离。本地域名服务器的 IP 地址需要直接配置在需要域名解析的主机中\n\n\n\n域名解析的过程：\n\n主机向本地域名服务器的查询一般都是采用递归查询\n本地域名服务器向根域名服务器的查询通常是采用迭代查询\n\n\n\n为了提高 DNS 查询效率，并减轻根域名服务器的负荷和减少互联网上的 DNS 查询报文数量，在域名服务器中广泛地使用了高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。\n由于域名到 IP 地址的绑定并不是永久不变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如，每个项目只存放两天）\n不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多主机在启动时从本地域名服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。同样地，主机也需要维护高速缓存的正确性\n\n6.2 文件传送协议6.2.1 FTP概述\n将某台计算机中的文件通过网络传送到可能相距很远的另一台计算机中，是一项基本的网络应用，即文件传输\n文件传输协议 FTP（file transfer protocol）是因特网上使用最广泛的文件传送协议\nFTP 提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用 ASCII 码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）\nFTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件\n\n\n在互联网发展的早期阶段，用 FTP 传送文件约占整个互联网的通信量的三分之一，而由电子邮件和域名系统所产生的通信量还小于 FTP 所产生的通信量。只是到了 1995 年， WWW 的通信量才首次超过了 FTP\n基于 TCP 的 FTP 和基于 UDP 的简单文件传送协议 TFTP，都是复制整个文件，其特点是：若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点\n文件共享协议中的另一大类是联机访问，意味着允许多个程序同时对一个文件进行存取，由操作系统提供对远地共享文件进行访问的服务。属于文件共享协议的有网络文件系统 NFS。\n\n6.2.2 FTP的基本工作原理\n6.2.3 简单文件传送协议TFTPTFTP 的主要特点是：\n\n每次传送的数据报文中有 512 字节的数据，但最后一次可不足 512 字节\n数据报文按序编号，从 1 开始\n支持 ASCII 码或二进制传送\n可对文件进行读或写\n使用很简单的首部\n\nTFTP 的工作很像停止等待协议\n\n发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号\n发完数据后在规定时间内收不到确认就要重发数据 PDU\n发送确认 PDU 的一方若在规定时间内收不到下一个文件块，也要重发确认 PDU\n这样就可保证文件的传送不致因某一个数据报的丢失而失败\n\n在一开始工作时。TFTP 客户进程发送一个读请求报文或写请求报文给 TFTP 服务器进程，其熟知端口号码为 69。TFTP 服务器进程要选择一个新的端口和 TFTP 客户进程进行通信\n若文件长度恰好为 512 字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据报文。若文件长度不是 512 字节的整数倍，则最后传送数据报文中的数据字段一定不满 512 字节，这正好可作为文件结束的标志\n6.3 远程终端协议TELNETTELNET 又称为终端仿真协议，是一个简单的远程终端协议\n用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一台主机上（使用主机名或 IP 地址）。TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上\n为了适应不同计算机和操作系统的差异，TELNET 定义了数据和命令应怎样通过互联网。这些定义就是所谓的网络虚拟终端 NVT \n\n\n\n客户软件把用户的击键和命令转换成 NVT 格式，并送交服务器。服务器软件把收到的数据和命令从 NVT 格式转换成远地系统所需的格式\n\n向用户返回数据时，服务器把远地系统的格式转换为 NVT 格式，本地客户再从 NVT 格式转换到本地系统所需的格式\n\nNVT 的格式定义很简单，所有的通信都使用 8 位一个字节\n\n在运转时，NVT 使用 7 位 ASCII 码传送数据，而当高位置 1 时用作控制命令\nASCII 码共有 95 个可打印字符和 33 个控制字符。所有可打印字符在 NVT 中的意义和在 ASCII 码中一样\n但 NVT 只使用了 ASCII 码的控制字符中的几个\n此外，NVT 还定义了两字符的 CR-LF 为标准的行结束控制符\n\n\n\n6.4 万维网WWW6.4.1 万维网概述万维网WWW（world wide web）是一个大规模的、 联机式的信息储藏所。万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。\n\n\n万维网是一个分布式的超媒体（hypermedia）系统，它是超文本（hypertext）系统的扩充\n\n超文本是指包含指向其他文档的链接的文本，一个超文本由多个信息源链接成，而这些信息源可以分布在世界各地，并且数目也是不受限制的\n超媒体与超文本的区别是文档内容不同。超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画以及视频图像等\n\n万维网需要解决的问题及解决方式\n\n怎样标志分布在整个互联网上的万维网文档：使用统一资源定位符 URL（Uniform Resource Locator）来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符 URL\n用什么样的协议来实现万维网上的各种链接：万维网客户程序与万维网服务器程序之间的交互遵守超文本传送协议 HTTP（HyperText Transfer Protocol）\n怎样使不同作者创作的不同风格的万维网文档，都能在互联网上的各种主机上显示出来，同时使用户清楚地知道在什么地方存在着链接：万维网使用超文本标记语言 HTML（HyperText Markup Language），使得万维网页面的设计者可以很方便地用链接从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的主机屏幕上将这些页面显示出来\n怎样使用户能够很方便地找到所需的信息：用户可使用搜索工具在万维网上方便地查找所需的信息\n\n6.4.2 统一资源定位符URL1. URL的格式URL 的一般形式由以下四个部分组成：协议主机端口路径\n\n&lt;协议&gt;就是指出使用什么协议来获取该万维网文档\n第二部分&lt;主机&gt;指出这个万维网文档是在哪一台主机上，这里的&lt;主机&gt;就是指该主机在互联网上的域名\n再后面是第三和第四部分&lt;端口&gt;和&lt;路径&gt;，有时可省略\n\n2. 使用HTTP的URL对于万维网的网点的访问要使用 HTTP 协议。HTTP 的 URL 的一般形式是：\n主机端口路径\nHTTP 的默认端口号是 80，通常可省略。若再省略文件的&lt;路径&gt;项，则 URL 就指到互联网上的某个主页（home page），主页可以是以下几种情况之一：\n\n一个 WWW 服务器的最高级别的页面\n某一个组织或部门的一个定制的页面或目录。从这样的页面可链接到互联网上的与本组织或部门有关的其他站点\n由某一个人自己设计的描述他本人情况的 WWW 页面\n\nURL 里面的字母不分大小写，但为了便于阅读，有时故意使用一些大写字母\n6.4.3 超文本传送协议HTTP1. HTTP的操作过程\nHTTP 协议定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器\n从层次的角度看，HTTP 是面向事务的（transaction- oriented）应用层协议，它是万维网上能够可靠地交换文件的重要基础\n\n\n\n\nHTTP 使用了面向连接的 TCP 作为运输层协议，保证了数据的可靠传输。HTTP 不必考虑数据在传输过程中被丢弃后又怎样被重传。但是，HTTP 协议本身是无连接的。这就是说，虽然 HTTP 使用了 TCP 连接，但通信的双方在交换 HTTP 报文之前不需要先建立 HTTP连接\nHTTP 协议是无状态的。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同\nHTTP/1.0 采用非持续连接方式。在该方式下，每次浏览器要请求一个文件都要与服务器建立 TCP 连接，当收到相应后就立即关闭连接\n每请求一个文档就要有两倍的 RTT 的开销，若一个网页上有很多引用对象，那么请求每一个对象都需要花费 2RTT 的时间\n为了减小时延，浏览器通常会建立多个并行的 TCP 连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重\n\n\n\n\n\n\nHTTP/1.1 采用持续连接的方式。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户和该服务器可以继续在这条连接上传送后续的 HTTP 请求和响应报文。这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行\n为了进一步提高效率，HTTP/1.1 的持续连接还可以使用流水线方式工作，即浏览器在收到 HTTP 的响应报文之前就能连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文。这样就节省了很多个 RTT 的时间，使 TCP 连接中的空闲时间减少，提高了下载文档的效率\n\n\n\n2. 代理服务器\n代理服务器（proxy server）是一种网络实体，它又称为万维网高速缓存（Web cache）\n代理服务器把最近的一些请求和响应暂存在本地磁盘中\n当新请求到达时，若代理服务器发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源\n代理服务器可在客户端或服务器端工作，也可在中间系统上工作\n\n\n\n3. HTTP的报文结构HTTP 有两类报文：\n\n请求报文：从客户向服务器发送请求报文\n响应报文：从服务器到客户的回答\n\n\n由于 HTTP 是面向文本的（text-oriented），因此在报文中的每一个字段都是一些 ASCII 码串，因而各个字段的长度都是不确定的\nHTTP 请求报文和响应报文都是由三个部分组成的：\n\n开始行，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行（Request-Line），而在响应报文中的开始行叫做状态行（Status-Line）。在开始行的三个字段之间都以空格分隔开，最后的 “CR ”和 “LF”分别代表“回车”和“换行”\n\n请求报文的第一行“请求行”只有三个内容，即方法，请求资源的 URL，以及 HTTP 的版本\n\n“方法”是面向对象技术中使用的专门名词，对所请求的对象进行的操作，实际上也就是一些命令，请求报文中常用的几种方法如下\n\n\n\n\n方法（操作）\n意义\n\n\n\nOPTION\n请求一些选项的信息\n\n\nGET\n请求读取由 URL 所标志的信息\n\n\nHEAD\n请求读取由 URL 所标志的信息的首部\n\n\nPOST\n给服务器添加信息（例如注释）\n\n\nPUT\n在指明的 URL 下存储一个文档\n\n\nDELETE\n删除指明的 URL 所标志的资源\n\n\nTRACE\n用来进行环回测试的请求报文\n\n\nCONNECT\n用于代理服务器\n\n\n\nHTTP 请求报文请求行的格式\n\nGET http://www.nju.edu.cn/main.htm HTTP/1.1\n\n响应报文的状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语\n\n状态码都是三位数字的，分为 5 大类，这 5 大类状态码都是以不同的数字开头的\n1xx 表示通知信息，如请求收到了或正在进行处理\n2xx 表示成功，如接受或知道了\n3xx 表示重定向，如要完成请求还必须采取进一步的行动\n4xx 表示客户的差错，如请求中有错误的语法或不能完成\n5xx 表示服务器的差错，如服务器失效无法完成请求\n\n\n下面三种状态行在响应报文中是经常见到的\n接受 HTTP/1.1 202 Accepted\n错误的请求 HTTP/1.1 400 Bad Request\n找不到 HTTP/1.1 404 Not Found\n\n\n\n\n\n\n首部行，用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开\n\n实体主体（entity body），在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段\n\n\n4. 在服务器上存放用户的信息\n\n早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态文档，因此 HTTP 被设计为一种无状态的协议，这样可以简化服务器的设计\n现在，用户可以通过万维网实现各种复杂的应用，如网上购物，电子商务等，这些应用往往需要万维网服务器能够识别用户\nCookie 提供了一种机制使得万维网服务器能够“记住”用户，而无需用户主动提供用户标识信息，也就是说，Cookie 是一种对无状态的 HTTP 进行状态化的技术\n\n6.4.4 万维网的文档\nHTML，超文本标记语言（hypertext markup language），使用多种标签来描述网页的内容和结构\nCSS，层叠样式表（cascading style sheet），从审美的角度来描述网页的样式\nJavaScript，一种脚本语言，控制网页的行为\n\n6.5 电子邮件6.5.1 电子邮件概述\n电子邮件是因特网上最早流行的一种应用，并且仍然是当今因特网上最重要、最实用的应用之一\n传统的电话通信属于实时通信，存在以下两个缺点：\n电话通信的主叫和被叫双方必须同时在场\n一些不是十分紧迫的电话也常常没必要打断人们的工作和休息\n\n\n电子邮件与邮政系统的寄信类似\n发件人将邮件发送到自己使用的邮件服务器\n发件人的邮件服务器将收到的邮件按其目的地址转发到收件人邮件服务器中的收件人邮箱\n收件人在方便的时候访问收件人邮件服务器中自己的邮箱，获取收到的电子邮件\n\n\n电子邮件使用方便、传递迅速而且费用低廉。它不仅可以传送文字信息，而且还可附上声音和图像\n\n\n\n电子邮件系统的三个主要组成构件：用户代理、邮件服务器和电子邮件所需的协议\n\n用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件\n邮件服务器是电子邮件系统的基础设施。因特网上所有的 ISP 都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱\n协议包括邮件发送协议（例如 SMTP）和邮件读取协议（例如 POP3，IMAP）\n\n6.5.2 简单邮件传送协议SMTP\n6.5.3 电子邮件的信息格式一个电子邮件分为信封和内容两大部分\n在RFC 5322文档中只规定了邮件内容中的首部格式，而对邮件的主体部分则让用户自由撰写。用户写好首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上。所以用户不需要填写电子邮件信封上的信息\n6.5.4 邮件读取协议POP3和IMAP常用的邮件读取协议有以下两个：\n\n邮局协议 POP（post office protocol），POP3 是其第三个版本，是因特网正式标准\n非常简单、功能有限的邮件读取协议。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。不允许用户在邮件服务器上管理自己的邮件。\n\n\n因特网邮件访问协议 IMAP（Internet Message Access Protocol），IMAP4 是其第四个版本\n功能比 POP3 强大的邮件读取协议。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此 IMAP 是一个联机协议\n\n\nPOP3 和 IMAP4 都采用基于 TCP 连接的客户/服务器方式。POP3 使用熟知端口号 110，IMAP4 使用熟知端口 143\n\n6.5.5 基于万维网的电子邮件\n通过浏览器登录邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与 IMAP 很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器\n邮件服务器网站通常都提供非常强大和方便的邮件管理功能，用户可以在邮件服务器网站上管理和处理自己的邮件，而不需要将邮件下载到本地进行管理\n\n6.5.6 通用互联网邮件扩充MIME\nSMTP 协议只能传送 ASCII 码文本数据，不能传送可执行文件和其他的二进制对象\nSMTP 不能满足传送多媒体邮件的需要，并且许多其他非英语国家的文字也无法用 SMTP 传送\n为解决 SMTP 传送非 ASCII 码文本的问题，提出了多用途因特网邮件拓展 MIME（Multipurpose Internet Mail Extension）\n增加了 5 个新的邮件首部字段，这些字段提供了有关邮件主体的信息\nMIME-Version：标志 MIME 的版本。现在的版本号是 1.0，若无此行，则为英文文本\nContent-Description：这是可读字符串，说明此邮件主体是否是图像、音频或视频\nContent-Id：邮件的唯一标识符\nContent-Transfer-Encoding：在传送时邮件的主体是如何编码的\nContent-Type：说明邮件主体的数据类型和子类型\n\n\n定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化\n定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变\n\n\n实际上，MIME 不仅仅用于 SMTP，也用于后来的同样面向 ASCII 字符的 HTTP\n\n\n\n6.6 动态主机配置协议DHCP互联网现在广泛使用的是动态主机配置协议 DHCP（Dynamic Host Configuration Protocol），它提供了一种机制，称为即插即用连网（plug-and-play networking）。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与\n为了避免需要在每一个网络上都设置一个 DHCP 服务器，需要每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。当 DHCP 中继代理收到主机 A 以广播形式发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再把此提供报文发回给主机 A\n\n\n下图是 DHCP 协议的工作过程\n\n\nDHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文\n\nDHCP 客户从 UDP 端口 68 发送 DHCP 发现报文\n\n凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客户可能收到多个 DHCP 提供报文\n\nDHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文。\n\n被选择的 DHCP 服务器发送确认报文 DHCP ACK。从这时起，DHCP 客户就可以使用这个 IP 地址了。这种状态叫做已绑定状态，因为在 DHCP 客户端的 IP 地址和硬件地址已经完成绑定，并且可以开始使用得到的临时 IP 地址了\nDHCP 客户现在要根据服务器提供的租用期  设置两个计时器，它们的超时时间分别是  和 。当超时时间到了就要请求更新租用期\n\n租用期过了一半时，DHCP 发送请求报文 DHCP REQUEST 要求更新租用期\n\nDHCP 服务器若同意，则发回确认报文 DHCP ACK。DHCP 客户得到了新的租用期，重新设置计时器\n\nDHCP 服务器若不同意，则发回否认报文 DHCP NACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤 2）\n若 DHCP 服务器不响应步骤 6 的请求报文 DHCP REQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCP REQUEST（重复步骤 6），然后又继续后面的步骤。\n\nDHCP 客户可以随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCP RELEASE 即可\n\n\n","categories":["计算机网络"]},{"title":"第三章 数据链路层","url":"/2022/06/06/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","content":"第三章 数据链路层数据链路层使用的信道主要有以下两种类型：\n\n点对点信道：使用一对一的点对点通信方式\n广播信道：使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送\n\n下图表示两台主机通过互联网进行通信时数据链路层所处的地位\n\n\n3.1 使用点对点信道的数据链路层3.1.1 数据链路和帧\n链路（link）就是从一个结点到相邻结点的一段物理线路（有线或无线），而中间没有任何其他的交换结点\n数据链路（data link）是把实现通信协议的硬件和软件加到链路上，就构成了数据链路\n数据链路层以帧为单位传输和处理数据\n点对点信道的数据链路层在进行通信时的主要步骤如下：\n结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧\n结点 A 把封装好的帧发送给结点 B 的数据链路层\n若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧\n\n\n\n\n\n3.1.2 三个基本问题数据链路层协议有许多种，但有三个基本问题则是共同的：封装成帧、透明传输和差错检测\n1.封装成帧\n封装成帧（framing）就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。\n接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束\n首部和尾部的一个重要作用就是进行帧定界（即确定帧的界限），此外，首部和尾部还包括许多必要的控制信息\n为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度\n每一种链路层协议都规定了所能传送的帧的数据部分长度上限—最大传送单元 MTU （Maximum Transfer Unit）\n\n\n\n\n当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符，图中 SOH 和 EOT 都是控制字符的名称\n\n\n\n\n当数据在传输中出现差错时，帧定界符的作用更加明显\n假定发送端在尚未发送完一个帧时突然出故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧\n由于使用了帧定界符，接收端就知道前面收到的数据是个不完整的帧，必须丢弃\n而后面收到的数据有明确的帧定界符，因此这是一个完整的帧，应当收下\n\n\n\n2.透明传输\n透明传输是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样\n\n当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数据部分显然不会出现像 SOH 或 EOT 这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输\n\n当数据部分是非 ASCII 码的文本文件时（如二进制代码的计算机程序或图像等），如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 这种控制字符一样，数据链路层就会错误地“找到帧的边界”，把部分帧收下，而把剩下的那部分数据丢弃\n\n\n\n面向字节的物理链路使用字节填充的方法实现透明传输：在 EOT 、 SOH 和 ESC 前添加转义字符 ESC\n\n\n面向比特的物理链路使用比特填充的方式实现透明传输：每 5 个连续的比特 1 后面插入一个比特 0\n\n\n\n\n3.差错检测\n实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1 可能会变成 0，而 0 也可能变成 1，这称为比特差错\n在一段时间内，传输错误的比特所占传输比特总数的比率称为误码率 BER（bit error rate）\n使用差错检测码来检查数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一\n检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误\n要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错，但纠错码的开销比较大，在计算机网络中较少使用\n循环冗余校验 CRC 有很好的检错能力（漏检率非常低），虽然计算比较复杂，但非常易于用硬件实现，因此被广泛应用于数据链路层\n在计算机网络中通常采用检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务\n\n\n\n3.2 可靠传输3.2.1 可靠传输的基本概念\n使用差错检测技术（例如循环冗余校验 CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特错误）\n数据链路层向上层提供的服务类型\n不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做\n可靠传输服务：想办法实现发送端发送什么， 接收端就收到什么\n\n\n一般情况下， 有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理\n无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务\n比特差错只是传输差错中的一种\n从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序以及分组重复\n分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层\n可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输\n可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需求\n\n3.2.2 停止-等待协议SW\n\n\n接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送 NAK 分组\n为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号\n为了让发送方能够判断所收到的 ACK 分组是否是重复的，需要给 ACK 分组编号，所用比特数量与数据分组编所用比特数量一样。数据链路层一般不会出现 ACK 分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给 ACK 分组编号\n超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”\n在数据链路层点对点的往返时间比较确定，重传时间比较好设定\n然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易\n\n\n\n\n\n令 ​​​​ 表示 A 发送分组需要的时间，​​​ ​表示 B 发送确认分组所需要的时间，​​ ​​​​表示往返时间，则停止-等待协议的信道利用率 ​​​​ 为为了提高传输效率，发送方可以不使用低效率的停止-等待协议，而是采用流水线传输\n\n\n3.2.3 回退N帧协议GBN\n\n发送方：\n\n发送窗口尺寸  的取值范围是 ，其中，​​ 是构成分组序号的比特数量\n当  时，即为停止-等待协议\n当  时，接收方无法分辨新、旧数据分组\n\n\n发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去\n发送方只有收到对已发送数据分组的确认时，发送窗口才能向前相应滑动\n发送方收到多个重复确认时，可在重传计时器超时前尽早开始重传，由具体实现决定\n发送方发送窗口内某个已发送的数据分组产生超时重发时，其后续在发送窗口内且已发送的数据分组也必须全部重传，这就是回退N帧协议名称的由来\n\n接收方：\n\n接收方的接收窗口尺寸  的取值范围是 ​​，因此接收方只能按序接收数据分组\n接收方只接收序号落在接收窗口内且无误码的数据分组，并且将接收窗口向前滑动一个位置，与此同时给发送方发回相应的确认分组。为了减少开销，接收方不一定每收到一个按序到达且无误码的数据分组就给发送方发回一个确认分组\n而是可以在连续收到好几个按序到达且无误码的数据分组后（由具体实现决定），才针对最后一个数据分组发送确认分组，这称为累积确认\n或者可以在自己有数据分组要发送时才对之前按序接收且无误码的数据分组进行捎带确认\n\n\n接收方收到未按序到达的数据分组，除丢弃外，还要对最近按序接收的数据分组进行确认\n\n回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续 ARQ 协议\n\n在协议的工作过程中，发送窗口和接受窗口不断向前滑动，因此这类协议又称为滑动窗口协议\n由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高\n\n3.2.4 选择重传协议SR\n\n发送方：\n\n发送窗口尺寸  的取值范围是 ，其中，​ 是构成分组序号的比特数量\n\n当  时，即为停止-等待协议\n当  时，接收方无法分辨新、旧数据分组\n\n\n发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去\n\n发送方只有按序收到对已发送数据分组的确认时，发送窗口才能向前相应滑动；若收到未按序到达的确认分组时，对其进行记录，以防止其相应数据分组的超时重发，但发送窗口不能向前滑动\n\n\n接收方：\n\n接收窗口尺寸 ​​ 的取值范围是 \n当  时，即为回退N帧协议\n当 时，无意义\n\n\n接收方可接收未按序到达但没有误码并且序号落在接收窗口内的数据分组\n为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的数据分组进行逐一确认\n\n\n接收方只有在按序接收数据分组后，接收窗口才能向前相应滑动\n\n\n\n\n\n3.3 点对点协议PPP点对点协议 PPP （Point-to-Point Protocol）是目前使用得最广泛的数据链路层协议\n\n\n3.3.1 PPP协议的特点1.PPP协议应满足的要求\n简单\n封装成帧\n透明性\n多种网络层协议\n多种类型链路\n差错检测\n检测连接状态\n最大传输单元\n网络层地址协商\n数据压缩协商\n\n2.PPP协议的组成\n封装成帧：对各种协议数据报的封装方法\n链路控制协议 LCP：用于建立、配置以及测试数据链路的连接\n一套网络控制协议NCPs：其中的每一个协议支持不同的网络层协议\n\n3.3.2 PPP协议的帧格式1.各字段的意义\n\n\n标志（Flag）字段：PPP 帧的定界符，取值为0x7E\n地址（Address）字段：取值为0xFF，预留（目前没有什么作用）\n控制（Control）字段：取值为0x03，预留（目前没有什么作用）\n协议（Protocol）字段：指明帧的数据部分送交给哪个协议处理\n取值为0x0021表示：帧的数据部分为 IP 数据报\n取值为0xC021表示：帧的数据部分为 LCP 分组\n取值为0x8021表示：帧的数据部分为 NCP 分组\n\n\n帧检验序列（Frame Check Sequence）字段：CRC 计算出的校验位\n\n2.字节填充\n\n\n\n发送方的处理：\n\n出现的每一个7E（PPP 帧定界符）字节转变成2字节序列：7D5E\n出现的每一个7D（转义字符）字节转变成2字节序列：7D5D\n出现的每一个 ASCII 码控制字符（数值小于0x20的字符）则在该字符前插入一个7D字节，同时将该字符的编码加上0x20\n\n3.零比特填充\n\n3.3.3 PPP协议的工作状态\n\n\nPPP 链路的起始和终止状态永远是“链路静止”（Link Dead）状态，这时在用户个人电脑和 ISP 的路由器之间并不存在物理层的连接\n\n当用户个人电脑通过调制解调器呼叫路由器时，路由器就能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后， PPP 就进入“链路建立”（Link Establish）状态，其目的是建立链路层的 LCP 连接\n\n这时 LCP 开始协商一些配置选项，即发送 LCP 的配置请求帧（Configure-Request）。这是 个 PPP 帧，其协议字段置为 LCP 对应的代码，而信息字段包含特定的配置请求。链路的另一端可以发送以下几种响应中的一种：\n\n配置确认帧（Configure-Ack）：所有选项都接受\n配置否认帧（Configure-Nak）：所有选项都理解但不能接受\n配置拒绝帧（Configure-Reject）：选项有的无法识别或不能接受，需要协商\n\n\nLCP 配置选项包括链路上的最大帧长、所使用的鉴别协议（authentication protocol）的规约，以及不使用 PPP 帧中的地址和控制字段\n\n协商结束后双方就建立了 LCP 链路，接着就进入“鉴别”（Authenticate）状态。在这一状态，只允许传送 LCP 协议的分组、鉴别协议的分组以及监测链路质量的分组\n\n若使用口令鉴别协议 PAP （Password Authentication Protocol），则需要发起通信的一方发送身份标识符和口令。系统可允许用户重试若干次\n如果需要有更好的安全性，则可使用更加复杂的口令握手鉴别协议 CHAP（Challenge-Handshake Authentication Protocol）\n若鉴别身份失败，则转 到“链路终止”（Link Terminate）状态。若鉴别成功，则进入“网络层协议”（Network-Layer Protocol）状态\n\n\n在“网络层协议”状态，PPP 链路的两端的网络控制协议 NCP 根据网络层的不同协议互相交换网络层特定的网络控制分组\n\n当网络层配置完毕后，链路就进入可进行数据通信的“链路打开”（Link Open）状态。链路的两个 PPP 端点可以彼此向对方发送分组。两个 PPP 端点还可发送回送请求 LCP 分组 （Echo-Request）和回送回答 LCP 分组（Echo-Reply），以检查链路的状态\n\n数据传输结束后，可以由链路的一端发出终止请求 LCP 分组（Terminate-Request）请求终止链路连接，在收到对方发来的终止确认 LCP 分组Terminate-Ack）后，转到“链路终止”状态。如果链路出现故障，也会从“链路打开”状态转到“链路终止”状态。当调制解调器的载波停止后，则回到“链路静止”状态\n\n\n\n\n3.4 使用广播信道的数据链路层3.4.1 局域网的数据链路层\n局域网的主要优点：\n\n具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源\n\n便于系统的扩展和逐渐演变，各设备的位置可灵活调整和改变\n\n提高了系统的可靠性（reliability）、可用性（availability）和生存性（survivability）\n\n\n\n\n\n\n\n共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体对占用，即媒体接入控制 MAC（medium access control）。这在技术上有两种方法：\n静态划分信道，如频分复用、时分复用、波分复用和码分复用等。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价较高，不适合于局域网使用\n动态媒体接入控制，它又称为多点接入（multiple access），其特点是信道并非在用户通信时固定分配给用户。这里又分为以下两类：\n随机接入：特点是所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞（即发生了冲突），使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议\n受控接入：特点是用户不能随机地发送信息而必须服从一定的控制。这类的典型代表有分散控制的令牌环局域网和集中控制的多点线路探询（polling）， 或称为轮询。受控接入目前在局域网中使用得较少\n\n\n\n\n\n\n\n3.4.2 CSMA/CD协议\nCSMA/CD，意思是载波监听多点接入/碰撞检测（Carrier Sense Multiple Access with Collision Detection）\n\n多点接入：说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上，竞争使用总线\n载波监听：每个站在发送帧之前先要检测一下总线上是否有其他站点在发送帧（“先听后说”）\n若检测到总线空闲96比特时间，则发送这个帧\n若检测到总线忙，则继续检测并等待总线转为空闲96比特时间，然后发送这个帧\n\n\n碰撞检测：每一个正在发送帧的站边发送变检测碰撞（“边说边听”）\n一旦发现总线上出现碰撞，则立即停止发送，退避一段随机事件后再次发送（“一旦冲突，立即停说，等待时机，重新再说”）\n\n\n\n\n争用期（碰撞窗口）：将总线上的单程端到端传播时延记为  ，端到端往返传播时延即为 \n\n\n\n主机最多经过 （即 ）的时长就可检测到本次发送是否遭受了碰撞\n以太网的端到端往返传播时延  称为争用期或碰撞窗口\n经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发送碰撞\n每个主机在自己发送帧之后的一小段时间内，存在着遭遇碰撞的可能性。这一小段时间是不确定的，它取决于另一个发送帧的主机到本主机的距离，但不会超过总线的端到端往返传播时延，即一个争用期时间\n显然，在以太网中发送帧的主机越多，端到端往返传播时延越大，发生碰转的概率就越大。因此，共享式以太网不能连接太多的主机，使用的总线也不能太长\n\n\n以太网规定最小帧长为64字节，即512比特（512比特时间即为争用期）\n\n如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节\n\n\n以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞\n\n如果在争用期（共发送64字节）没有检测到碰撞，那么后续发送到数据就一定不会发生碰撞\n如果在争用期内检测到碰撞，就立即中止发送，这时已发送出去的数据一定小于64字节，因此，凡长度小于64字节的帧都是由于碰撞而异常中止的无效帧\n\n\n以太网使用截断二进制指数退避（truncated binary exponential backoff）算法来确定碰撞后重传的时机\n\n退避时间基本退避时间随机数\n基本退避时间为争用期 \n随机数  从离散的整数集合  中随机选出一个数， 重传次数\n\n\n若连续发生多次碰撞，就表明可能有较多的主机参与竞争信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为动态退避），因而减小碰撞的概率，有利于整个系统的稳定\n当重传达16次仍不能成功时，表示同时打算发送帧的主机太多，以至于连续发生碰撞，则丢弃该帧，并向高层报告\n\n\n以太网还采取一种强化碰撞的机制：当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送32比特或48比特的人为干扰信号（jamming signal），以便让所有用户都知道现在已经发生了碰撞\n\n\n\n\nCSMA/CD 协议的要点归纳如下：\n\n准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中。但在发送之前，必须先检测信道。\n\n检测信道：若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。\n\n在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里只有两种可能性:\n\n发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到1\n发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待  倍 512 比特时间后，返回到步骤2，继续检测信道。但若重传达16次仍不能成功，则停止重传而向上报错\n\n\n\n以太网每发送完一帧，一定要把已发送的帧暂时保留一下。如果在争用期内检测出发生了碰撞，那么还要在推迟一段时间后再把这个暂时保留的帧重传一次。\n帧发送流程：\n\n帧接收流程：\n\n3.4.3 使用集线器的星形拓扑\n\n集线器（hub）的一些特点如下：\n\n使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是 CSMA/CD 协议（更具体些说，是各站中的适配器执行 CSMA/CD 协议）。网络中的各站必须竞争对传输媒体的控制，并且在同一时刻至多只允许一个站发送数据\n一个集线器有许多接口，每个接口通过 RJ-45 插头用两对双绞线与一台计算机上的适配器相连，一个集线器很像一个多接口的转发器\n集线器工作在物理层，它的每个接口仅仅简单地转发比特，不进行碰撞检测\n集线器一般都有少量的容错能力和网络管理功能。例如，若网络中某个网卡出了故障，不停地在发送帧，此时集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍能正常工作\n\n3.4.4 以太网的信道利用率\n\n考虑上图的以太网信道被占用的情况\n\n一个站在发送帧时出现碰撞，经过一个争用期  后，可能又出现了碰撞，这样经过若干个争用期后，一个站发送成功了\n假定发送帧需要的时间是  ，等于帧长除以发送速率\n考虑在最极端情况下，发送站在传输媒体的一端，当发送站发送完最后一个比特是，这个比特在在以太网上传播需要的时间为  \n所以必须在经过时间  后以太网的媒体才完全进入空闲状态，允许其他站发送数据\n\n定义参数  为以太网单程端到端时延  与帧的发送时间  之比\n\n参数  越大，表明争用期所占的比例越大，这就使得每发生一次碰撞就浪费了不少的信道资源，使得信道利用率明显降低\n当数据率一定时，以太网的连线的长度受到限制，同时以太网的帧长不能太短\n\n以太网极限信道利用率  为\n\n只有当参数  远小于 1 才能得到尽可能高的极限信道利用率\n\n3.4.5 以太网的MAC层1. MAC层的硬件地址\n当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址\n\n在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体介入控制 MAC（media access control），因此这类地址被称为 MAC 地址\n\nMAC 地址一般被固化在网卡（网络适配器）的电可擦可编程只读存储器 EEPROM 中，因此 MAC 地址也被称为硬件地址\nMAC 地址有时也被称为物理地址，但这并不意味着 MAC 地址属于网络体系结构中的物理层\n\n\n一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡）。每个网络适配器都有一个全球唯一的 MAC 地址。而交换机和路由器往往拥有更多的网络接口，所以会有更多的 MAC 地址。所以，严格来说，MAC 地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。\n\nIEEE 802 局域网的 MAC 帧格式\n\n\nIEEE 的注册管理机构 RA（Registration Authority）是局域网全球地址的法定管理机构，负责分配地址字段的 6 个字节中的前三个字节（即高位 24 位）。世界上凡要生产局域网适配器的厂家都必须向 IEEE 购买由这三个字节构成的地址块，称为组织唯一标识符 OUI（organizationally unique identifier）\n地址字段中的后三个字节（即低位 24 位）则由厂家自行指派，称为扩展标识符（extended identifier），只要保证生产出的适配器没有重复地址即可\n地址字段的第一字节的最低位为 I/G（Individual/Group）位，当 I/G 位为 0 时，地址字段表示一个单个站地址；当 I/G 位为 1 时表示组地址，用来进行多播\n地址字段第 1 字节的最低第二位规定为 G/L（Global/Local） 位。当 G/L 位为 0 时是全球管理（保证 在全球没有相同的地址），厂商向 IEEE 购买的 OUI 都属于全球管理。当地址字段的 G/L 位为 1 时是本地管理，这时用户可任意分配网络上的地址\n\n\n\n2. MAC帧的格式\n\n\n以太网 V2的 MAC 帧格式为\n\n前两个字段分别为6字节长的目的地址和源地址字段\n第三个字端是 2 字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议\n第四个字段是数据字段，其长度在 46 到 1500 字节之间（最小长度 64 字节减去 18 字节的首部和尾部就得出数据字段的最小长度 46 字节）\n最后一个字段是 4 字节的帧检验序列 FCS（使用 CRC 检验）\n\n\n在以太网 V2 的 MAC 帧格式中，其首部并没有一个帧长度（或数据长度）字段。那么，MAC 子层又怎样知道从接收到的以太网帧中取出多少字节的数据交付上一层协议呢？\n\n曼彻斯特编码的 一个重要特点就是：在曼彻斯特编码的每一个码元（不管码元是 1 或 0）的正中间一定有一 次电压的转换（从高到低或从低到高）。当发送方把一个以太网帧发送完毕后，就不再发送其他码元了（既不发送 1，也不发送 0）。因此，发送方网络适配器的接口上的电压也就不再变化了。这样，接收方就可以很容易地找到以太网帧的结束位置。在这个位置往前数 4 字节（FCS 字段长度是 4 字节），就能确定数据字段的结束位置\n\n\n当数据字段的长度小于 46 字节时，MAC 子层就会在数据字段的后面加入一个整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节\n\n上层协议如何知道填充字段的长度呢：当上层使用 IP 协议时，其首部就有一个“总长度”字段。因此，“总长度”加上填充字段的长度，应当等于 MAC 帧数据字段的长度。例如，当 IP 数据报的总长度为 42 字节时，填充字段共有 4 字节。当 MAC 帧把 46 字节的数据上交给 IP 层后，IP 层就把其中最后 4 字节的填充字段丢弃\n\n\n\n3.5 拓展的以太网3.5.1 在物理层拓展以太网如果使用多个集线器，就可以连接成覆盖更大范围的多级星形结构的以太网\n\n\n3.5.2 在数据链路层拓展以太网1. 以太网交换机的特点\n以太网交换机实质上就是一个多接口的网桥，每个接口都可以直接与一台主机或另一个以太网交换机相连，一般都工作在全双工方式\n以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，相互通信的主机都是独占传输媒体，无碰撞地传输数据（不使用 CSMA/CD 协议）\n以太网交换机一般都具有多种速率的接口，例如10Mb/s、100Mb/s、1Gb/s和10Gb/s接口的多种组合\n以太网交换机工作在数据链路层（也包括物理层），它收到帧后，在帧交换表中查找帧的目的 MAC 地址所对应的接口号，然后通过该接口转发帧\n以太网交换机是一种即插即用设备，其内部的帧交换表是通过自学习算法自动地逐渐建立起来的\n帧的转发方式\n大多以太网交换机采用存储转发方式\n一些交换机采用直通交换的方式：采用基于硬件的交叉矩阵，交换时延非常小，但不检查帧是否有差错\n\n\n\n\n2. 以太网交换机的自学习功能\n\n以上图为例说明以太网交换机是怎样进行自学习的\n\nA 先向 B 发送一帧，从接口1进入到交换机。交换机收到帧后，先查找交换表，没有查到应从哪个接口转发这个帧\n接着，交换机把这个帧的源地址 A 和接口1写入交换表中，并向除接口1以外的所有接口广播这个帧\nC 和 D 将丢弃这个帧，因为目的地址不对。只 B 才收下这个目的地址正确的帧。这也称为过滤\n假定接下来 B 通过接口3向 A 发送一帧。交换机查找交换表，发现交换表中的 MAC 地址有 A。表明要发送给 A 的帧应从接口 1 转发\n于是就把这个帧传送到接口 1 转发给 A\n考虑到有时可能要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间，过期的项目就自动被删除。用这样的方法保证交换表中的数据都符合当前网络的实际状况。\n\n\n例：为简单起见，主机 A、B、C、D、E、F、G、H 的 MAC 地址与其主机名称相同，主机间依次入如下通信：B → C、D → A、G → D、E → H、C → B 和 F → G。请给出以太网交换机1，2，3的自学习过程以及各自最终的帧交换表的内容\n\n\n自学习过程如下：\n\n\n\n通信过程\n以太网交换机1\n以太网交换机2\n以太网交换机3\n\n\n\nB → C\n登记，盲目转发\n登记，盲目转发\n登记，盲目转发\n\n\nD → A\n登记，盲目转发\n登记，盲目转发\n登记，盲目转发\n\n\nG → D\n收不到\n登记，明确转发\n登记，明确转发\n\n\nE → H\n登记，盲目转发\n登记，盲目转发\n登记，盲目转发\n\n\nC → B\n登记，明确转发\n收不到\n收不到\n\n\nF → G\n收不到\n收不到\n登记，明确转发\n\n\n最终的帧交换表如下：\n\n\n有时为了增加网络的可靠性，在使用以太网交换机组网时，往往会增加一些冗余的链路\n但是冗余链路会形成网络环路，造成广播风暴，主机收到重复的广播帧以及交换机的帧交换表震荡（漂移）等问题\n\n\n\n\n以太网交换机使用生成树协议 STP（spanning tree protocol），可以在增加冗余链路来提高网络可靠性的同时又避免网络环路带来的各种问题\n不论交换机之间采用怎样的物理连接，交换机都能自动计算并构建一个逻辑上没有环路的网络，其拓扑结构必须是树形的\n最终生成的树形拓扑结构要确保连通整个网络\n当首次连接交换机或网络物理拓扑发生变化时（有可能是人为改变或故障），交换机都将进行生成树的重新计算\n\n\n\n3.5.3 虚拟局域网\n虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机属于哪一个 VLAN\n虚拟局域网只是局域网给用户提供的一种服务，而并不是一种新型局域网\n\n\n\n\n在虚拟局域网上的每一个站都可以收到同一个虚拟局域网上的其他成员所发出的广播\n\n当  向工作组内成员发送数据时，计算机  和  将会收到广播的信息，虽然它们没有和  连在同一个以太网交换机上\n当  向工作组内成员发送数据时，计算机 ， 和  都不会收到  发出的广播信息，虽然它们都与  连接在同一个以太网交换机上\n\n\n虚拟局域网限制了接收广播信息的计算机数，使得网络不会因传播过多的广播信息（即所谓的“广播风暴”）而引起性能恶化\n\n\n\n\n\n虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记，用来指明发送该帧的计算机属于哪一个虚拟局域网\n插入 VLAN 标记得出的帧称为 802.1Q 帧\nVLAN 标记字段的长度是 4 字节，插入在以太网 MAC 帧的源地址字段和类型字段之间\nVLAN 标记的前两个字节总是设置为 0x8100，称为 IEEE 802.1Q 标记类型\n当数据链路层检测到 MAC 帧的源地址字段后面的两个字节的值是 0x8100 时，就知道现在插入了 4 字节的 VLAN 标记。于是就接着检查后面两个字节的内容。在后面的两个字节中，前 3 位是用户优先级字段，接着的一位是规范格式指示符 CFI（Canonical Format Indicator），最后的12位是该虚拟局域网VLAN标识符VID，它唯一地标志了这个以太网帧属于哪一个 VLAN\n由于用于 VLAN 的以太网帧的首部增加了 4 个字节，因此以太网的最大帧长从原来的 1518 字节（1500 字节的数据加上 18 字节的首部）变为 1522 字节\n\n","categories":["计算机网络"]},{"title":"第四章 网络层","url":"/2022/06/06/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/","content":"第四章 网络层4.1 网络层提供的两种服务\n面向连接的虚电路服务\n\n可靠通信由网络来保证\n必须建立网络层的连接——虚电路 VC（virtual circuit）\n通信双方沿着已建立的虚电路发送分组\n目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号（构成虚电路的每一段链路都有一个虚电路编号）\n这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复）\n通信结束后，需要释放之前所建立的虚电路\n很多广域分组交换网都使用面向连接的虚电路服务。例如，曾经的 X.25 和逐渐过时的帧中继 FR、异步传输模式 ATM 等\n\n\n无连接的数据报服务\n\n可靠通信应当由用户主机来保证\n不需要建立网络层连接\n每个分组可走不同的路径\n每个分组的首部必须携带目的主机的完整地址\n这种通信方式所传送的分组可能误码、丢失、重复和失序\n由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网交换机相比较）\n因特网采用了这种设计思想，也就是将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心\n\n\n\n\n\n虚电路服务与数据报功能的比较\n\n\n\n对比的方面\n虚电路服务\n数据报服务\n\n\n\n思路\n可靠通信应当由网络来保证\n可靠通信应当由用户主机来保证\n\n\n连接的建立\n必须建立网络连接\n不需要建立网络连接\n\n\n终点地址\n仅在连接建立阶段使用，每个分组使用短的虚电路号\n每个分组都有终点的完整地址\n\n\n分组的转发\n属于同一条虚电路的分组均按照同一路由进行转发\n每个分组独立选择路由进行转发\n\n\n当结点出故障时\n所有通过出故障的结点的虚电路均不能工作\n出故障的结点可能会丢失分组，一些路由可能会发生变化\n\n\n分组的顺序\n总是按发送顺序到达终点\n到达终点的时间不一定按发送顺序\n\n\n端到端的差错处理和流量控制\n可以由网络负责，也可以由用户主机负责\n由用户主机负责\n\n\n由于 TCP/IP 体系结构的因特网的网际层提供的是简单灵活的、无连接的、尽最大努力交付的数据报服务，因此本章主要围绕网际层如何传送 IP 数据报这个主题进行讨论\n4.2 网际协议IP网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，与 IP 协议配套使用的还有三个协议\n\n地址解析协议 ARP（Address Resolution Protocol）\n网际控制报文协议 ICMP（Internet Control Message Protocol）\n网际组管理协议 IGMP（Internet Group Management Protocol）\n\n\n\n4.2.1 虚拟互连网络\n下图（a）表示有许多计算机网络通过一些路由器进行互连。由于参加互连的计算机网络都使用相同的网际协议 IP，因此可以把互连以后的计算机网络看成如图（b）所示的一个虚拟互连网络\n虚拟互连网络也就是逻辑互连网络，就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络\n当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节\n\n\n\n\n\n只从网络层考虑问题，IP 数据报在下图中的传播路径为\n4.2.2 分类的IP地址1. IP地址及其表示方法IP 地址的编址方法共经过了三个历史阶段\n\n分类的 IP 地址。这是最基本的编址方法，在1981年就通过了相应的标准协议\n\n子网的划分。这是对最基本的编址方法的改进，其标准 RFC950 在 1985 年通过\n\n构成超网。这是比较新的无分类编址方法。1993年提出后很快就得到推广应用\n\n\n本节只讨论最基本的分类的 IP 地址：\n所谓“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中第一个字段是网络号（net-id），它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。第二个字段是主机号（host-id），它标志该主机（或路由器）。这种两级的 IP 地址可以记为地址网络号主机号\n\nA 类、B 类和 C 类地址的网络号字段分别为 1 个、2 个 和 3 个字节长，而在网络号字段的最前面有 13 位的类别位，其数值分别规定为 0，10 和 110\n\nA 类、B 类和 C 类地址的主机号字段分别为 3 个、2 个和 1 个字节长\n\nD 类地址（前 4 位是 1110）用于多播\n\nE 类地址（前 4 位是 1111 ）保留为以后使用\n\n只有 A 类、B 类和 C 类地址可以分配给网络中的主机或路由器的各接口\n\n主机号为“全 0”的地址是网络地址，表示该 IP 地址是“本主机”所连接到的单个网络地址，不能分配给主机或路由器的各接口\n\n主机号为“全 1”的地址是广播地址，表示该网络上的所有主机，不能分配给主机或路由器的各接口\n\n\n2. 常用的三种类别的IP地址\n\n\nA 类地址的网络号字段占 1 个字节，只有 7 位可供使用（该字段的第一位已固定为0）\n网络号字段为全 0（00000000）表示“本网络”，为保留字段，不指派\n网络号为 127（01111111）保留作为本地软件环回测试本主机的进程之间的通信，不指派\n最小的本地环回测试地址为 127.0.0.1\n最大的本地环回测试地址为 127.255.255.254\n\n\n最后一个可指派的网络号为 126，网络地址为 126.0.0.0\n可指派的网络数量为 \n减 2 的原因是去掉最小网络号 0 和最大网络号 127\n\n\n每个网络中分配的 IP 地址数量为 \n减 2 的原因是去掉主机号全 0 的网络地址和主机号全 1 的广播地址\n\n\n\n\n\n\n\n\nB 类地址的网络号字段有 2 个字节，但前面两位（10）已经固定了，只剩下14位可以进行分配\n最小网络号也是第一个可指派的网络号为 128.0，网络地址为 128.0.0.0\n最大网络号也是最后一个可指派的网络号为 191.255，网络地址为 191.255.0.0\n可指派的网络数量为 \n每个网络中分配的 IP 地址数量为 \n减 2 的原因是去掉主机号全 0 的网络地址和主机号全 1 的广播地址\n\n\n\n\n\n\n\n\nC 类地址有 3 个字节的网络号字段，最前面的 3 位是（110），还有21位可以进行分配\n最小网络号也是第一个可指派的网络号为 192.0.0，网络地址为 192.0.0.0\n最大网络号也是最后一个可指派的网络号为 223.255.255，网络地址为 223.255.255.0\n可指派的网络数量为 \n每个网络中分配的 IP 地址数量为 \n减 2 的原因是去掉主机号全 0 的网络地址和主机号全 1 的广播地址\n\n\n\n\n\nIP 地址的指派范围为\n\n\n\n网络类别\n最大可指派的网络数\n第一个可指派的网络号\n最后一个可指派的网络号\n每个网络中的最大主机数\n\n\n\nA\n126（）\n1\n126\n16777214\n\n\nB\n16384（）\n128.1\n191.255\n65534\n\n\nC\n2097152（）\n192.0.1\n223.255.255\n254\n\n\n一般不使用的特殊 IP 地址为\n\n\n\n网络号\n主机号\n源地址使用\n目的地址使用\n代表的意思\n\n\n\n0\n0\n可以\n不可\n在本网络上的本主机\n\n\n0\nhost-id\n可以\n不可\n在本网络上的某台主机 host-id\n\n\n全 1\n全 1\n不可\n可以\n只在本网络上进行广播（各路由器均不转发）\n\n\nnet-id\n全 1\n不可\n可以\n对 net-id 上的所有主机进行广播\n\n\n127\n非全 0 或全 1 的任何数\n可以\n可以\n用于本地软件环回测试\n\n\nIP 地址具有以下一些重要特点\n\n每一个 IP 地址都由网络号和主机号两部分组成，IP 地址是一种分等级的地址结构\n\nIP 地址管理机构在分配 IP 地址时只分配网络号（第一级），而剩下的主机号（第二级）则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理\n路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间以及查找路由表的时间\n\n\nIP 地址是标志一台主机（或路由器）和一条链路的接口\n\n一个网络是指具有相同网络号 net-id 的主机的集合，因此，用转发器或网桥连接起来的若干个局域网仍为一个网络\n\n在 IP 地址中，所有分配到网络号的网络都是平等的。所谓平等，是指互联网同等对待每一个 IP 地址。\n\n\n\n\n4.2.3 IP地址与硬件地址\n\n\n数据包转发过程中源 IP 地址和目的 IP 地址保持不变\n数据包转发过程中源 MAC 地址和目的 MAC 地址逐个链路（或逐个网络）改变\n\n4.2.4 地址解析协议ARP\n地址解析协议 ARP 用来解决已经知道一个机器（主机或路由器）的 IP 地址，需要找出其相应的硬件地址的问题\n地址解析协议 ARP 解决这个问题的方法是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或超时删除）\n每一台主机都设有一个 ARP 高速缓存（ARP cache），里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表\n\nARP 映射表的构造过程如下：\n\n\n\n当主机 A 要向本局域网上的某台主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就在 ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址\n\n也有可能查不到主机 B 的 IP 地址的项目。这可能是主机 B 才入网，也可能是主机 A 刚刚加电，其高速缓存还是空的。在这种情况下，主机 A 就自动运行 ARP，然后按以下步骤找出主机 B 的硬件地址：\n\nARP 进程在本局域网上广播发送一个ARP 请求分组，其主要内容是：“我的 IP 地址是 209.0.0.5，硬件地址是 00-00-C0-15-AD-18。我想知道 IP 地址为 209.0.0.6 的主机的硬件地址。”\n在本局域网上的所有主机上运行的 ARP 进程都收到此 ARP 请求分组\n主机 B 的 IP 地址与 ARP 请求分组中要查询的 IP 地址一致，就收下这个 ARP 请求分组，并向主机 A 发送 ARP 响应分组（单播），其主要内容是：“我的 IP 地址是 209.0.0.6，我的硬件地址是 08-00-2B-00-EE-0A。”，同时将主机 A 的地址映射关系写入自己的 ARP 高速缓存中。其余的所有主机的 IP 地址都与 ARP 请求分组中要查询的 IP 地址不一致，因此都不理睬这个 ARP 请求分组\n主机 A 收到主机 B 的 ARP 响应分组后，就在其 ARP 高速缓存中写入主机 B 的 IP 地址到硬件地址的映射\n\n\nARP 对保存在高速缓存中的每一个映射地址项目都设置生存时间，凡超过生存时间的项目就从高速缓存中删除掉\n\n\n使用 ARP 的四种典型情况：\n\n\n\n发送方是主机（如 ），要把 IP 数据报发送到同一个网络上的另一台主机（如 ）。这时  发送 ARP 请求分组（在网 1 上广播），找到目的主机  的硬件地址。\n发送方是主机（如 ），要把 IP 数据报发送到另一个网络上的一台主机（如  或 ）。这时  发送 ARP 请求分组（在网 1 上广播），找到网 1 上的一个路由器  的硬件地址。剩下的工作由路由器  来完成。 要做的事情是下面的3或4。\n发送方是路由器（如 ），要把 IP 数据报转发到与  连接在同一个网络（网 2）上的主机（如 ）。这时  发送 ARP 请求分组（在网 2 上广播），找到目的主机  的硬件地址。\n发送方是路由器（如 ），要把 IP 数据报转发到网 3 上的一台主机（如 ）。 与  不是连接在同一个网络上。这时  发送 ARP 请求分组（在网 2 上广播），找到连接在网 2 上的一个路由器  的硬件地址。剩下的工作由这个路由器  来完成。\n\n4.2.5 IP数据报的格式\n1. IP数据报首部的固定部分中的各字段（1）版本占 4 比特，表示 IP 协议的版本，通信双方使用的 IP 协议的版本必须一致，目前广泛使用的 IP 协议版本号为4（即 IPv4）\n（2）首部长度占 4 比特，表示 IP 数据报首部的长度，该字段所表示数的单位是 32 位字（即 4 字节）\n\n最小十进制取值为 5，表示 IP 数据报首部只有 20 字节固定部分\n最大十进制取值为 15，表示 IP 数据报首部包含 20 字节固定部分和最大 40 字节的可变部分\n\n（3）区分服务\n占 8 比特，用来获得更好的服务。\n这个字段在旧标准中叫做服务类型， 但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务 DS（Differentiated Services）\n只有在使用区分服务时，这个字段才起作用。在一般的情况下都不使用这个字段\n\n（4）总长度占 16 比特，表示 IP 数据报的总长度，即 IP 数据报首部长度和数据载荷长度之和\n（5）标识（identification）占 16 比特，属于同一个数据报的各分片数据报应该具有相同的标识。IP 软件维持一个计数器，每产生一个数据报，计数器值加 1 ，并将此值赋值给标识字段\n（6）标志（flag）占 3 比特，但目前只有两位有意义\n\n标志字段中的最低位记为MF（More Fragment）。 即表示后面“还有分片” 的数据报。 表示这已是若干数据报片中的最后一个\n标志字段中间的一位记为 DF（Don’t Fragment），意思是“不能分片”。只有当  时才允许分片\n\n（7）片偏移占 13 位。片偏移指出:较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位。这就是说，每个分片的长度一定是 8 字节（64 位）的整数倍\n\n例：对 IPv4 数据报进行分片\n一数据报的总长度为 3820 字节，其数据部分为 3800 字节长（使用固定首部），需要分片为长度不超过 1420 字节的数据报片\n\n\n\n\n\n\n总长度\n标识\nMF\nDF\n片偏移\n\n\n\n原始数据报\n3820\n12345\n0\n0\n0\n\n\n数据报片1\n1420\n12345\n1\n0\n0\n\n\n数据报片2\n1420\n12345\n1\n0\n175\n\n\n数据报片3\n1020\n12345\n0\n0\n350\n\n\n\n现假定数据报片2经过某个网络时还需要再进行分片，即划分为数据报片2-1（携带数据800字节）和数据报片2-2（携带数据600字节）\n\n\n\n\n\n总长度\n标识\nMF\nDF\n片偏移\n\n\n\n原始数据报\n3820\n12345\n0\n0\n0\n\n\n数据报片2-1\n820\n12345\n1\n0\n175\n\n\n数据报片2-2\n620\n12345\n1\n0\n275\n\n\n（8）生存时间TTL\n占 8 比特。最初以秒为单位，最大生存周期为 255 秒。路由器转发 IP 数据报时，将 IP 数据报首部中的该字段的值减去 IP 数据报在本路由器上所耗费的时间，若不为 0 则转发，否则就丢弃\n\n现在以“跳数”为单位，路由器转发 IP 数据报时，将 IP 数据报首部中的该字段的值减 1，若不为 0 就转发，否则就丢弃\n\n\n（9）协议占 8 比特，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理\n（10）首部检验和\n占 16 比特，用来检验首部在传输过程中是否有差错。比 CRC 校验码简单，称为因特网检验和\nIP 数据报每经过一个路由器，路由器都要重新计算一下首部检验和，这是因为某些字段（生存时间、标志、片偏移等）的取值可能发生会发生变化\n由于 IP 层本身并不提供可靠传输服务，且计算首部检验和是一项耗时的操作，因此在 IPv6 中，路由器不再计算首部检验和，从而更快转发 IP 数据报\n\n\n\n（11）源地址占 32 比特\n（12）目的地址占 32 比特\n2. IP数据报首部的可变部分\nIP 数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施\n此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目\n增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长 度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。\n为了确保首部长度为 4 字节的整数倍，有时需要用全 0 的填充字段将其补齐\n\n4.2.6 IP层转发分组的流程\n\n分组转发算法如下:\n\n从数据报的首部提取目的主机的 IP 地址 , 得出目的网络地址为 。\n若  就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址  转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行 3。\n若路由表中有目的地址为  的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 4。\n若路由表中有到达网络  的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 5。\n若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 6。\n报告转发分组出错。\n\n4.3 划分子网和构造超网4.3.1 划分子网1. 从两级 IP 地址到三级 IP 地址划分子网的基本思路为：\n\n一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网。划分子网纯属一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成， 因为这个单位对外仍然表现为一个网络。\n\n划分子网的方法是从网络的主机号借用若干位作为子网号，于是两级 IP 地址在本单位内部就变为三级 IP 地址:网络号、 子网号和主机号。也可以用以下记法来表示：\n\n\n地址网络号，子网号，主机号\n\n凡是从其他网络发送给本单位某台主机的 IP 数据报，仍然是根据 IP 数据报的目的 网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络 号和子网号找到目的子网，把 IP 数据报交付目的主机。\n\n2. 子网掩码32 比特的子网掩码可以表明分类 IP 地址的主机号部分被借用了几个比特作为子网号\n\n子网掩码使用连续的比特1来对应网络号和子网号\n子网掩码使用连续的比特0来对应主机号\n将划分子网的IPv4地址与其相应的子网掩码进行逻辑与运算就可得到IPv4地址所在子网的网络地址\n\n\n\n默认的子网掩码是指在未划分子网的情况下使用的子网掩码\n\n\n\n例：已知某个网络的地址为 218.75.230.0，使用子网掩码 255.255.255.128 对其进行子网划分，请给出划分细节\n\n\n\n\n网络号\n子网号\n主机号\n具体含义\n\n\n\n218.75.230\n0\n000 0000\n子网0的网络地址 218.75.230.0\n\n\n218.75.230\n0\n000 0001\n可分配的最小地址 218.75.230.1\n\n\n……\n……\n……\n……\n\n\n218.75.230\n0\n111 1110\n可分配的最大地址 218.75.230.126\n\n\n218.75.230\n0\n111 1111\n子网0的广播地址 218.75.230.127\n\n\n218.75.230\n1\n000 0000\n子网1的网络地址 218.75.230.128\n\n\n218.75.230\n1\n000 0001\n可分配的最小地址 218.75.230.129\n\n\n……\n……\n……\n……\n\n\n218.75.230\n1\n111 1110\n可分配的最大地址 218.75.230.254\n\n\n218.75.230\n1\n111 1111\n子网1的广播地址 218.75.230.255\n\n\n\n例：已知 IP 地址是 141.14.72.24，子网掩码是 255.255.192.0，求网络地址\n\n\n\n4.3.2 使用子网时分组的转发在划分子网的情况下，路由器转发分组的算法如下：\n\n从收到的数据报的首部提取目的 IP 地址 。\n先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和  逐位相“与”，看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付（当然还需要把  转换成物理地址，把数据报封装成帧发送出去），转发任务结束。否则就是间接交付，执行3。\n若路由表中有目的地址为  的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行4。\n对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和  逐位相“与”，其结果为 。若  与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行5。\n若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行6。\n报告转发分组出错。\n\n\n例：源主机  向目的主机  发送分组。试讨论  收到  向  发送的分组后查找路由表的过程\n\n\n\n源主机  把本子网的“子网掩码 255.255.255.128”与目的主机  的“IP 地址 128.30.33.138”逐位相“与”，得出 128.30.33.128，它不等于  的 网络地址（128.30.33.0）。这说明  与 不在同一个子网上。因此  不能把分组直接交付 ，而必须交给子网上的默认路由器 ，由  来转发。\n路由器  在收到一个分组后，就在其路由表中逐行寻找有无匹配的网络地址。\n先看  路由表中的第一行。用这一行的“子网掩码 255.255.255.128”和收到的分组的 “目的地址 128.30.33.138”逐位相“与”，得出 128.30.33.128。然后和这一行给出的目的网络地址 128.30.33.0 进行比较。但比较的结果不一致（即不匹配）。\n用同样方法继续往下找第二行。用第二行的“子网掩码 255.255.255.128”和该分组的 “目的地址 128.30.33.138”逐位相“与”，结果也是 128.30.33.128。这个结果和第二行的目的网络地址 128.30.33.128 相匹配，说明这个网络就是收到的分组所要寻找的目的网络。于是不需要再继续查找下去。 把分组从接口 1 直接交付主机 。\n4.3.3 无分类编址CIDR（构造超网）1. 网络前缀\n划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的 C 类网因为其地址空间太小并没有得到充分使用，而因特网的 IP 地址仍在加速消耗，整个 IPv4 地址空间面临全部耗尽的威胁\n为此，因特网工程任务组 IETF 又提出了采用无分类编制的方法来解决 IP 地址紧张的问题，同时还专门成立 IPv6 工作组负责研究新版本 IP 以彻底解决 IP 地址耗尽的问题\n1993年，IETF 发布了无分类域间路由选择 CIDR（classless inter-domain routing）的 RFC 文档 RFC 1517 1519和1520\nCIDR 消除了传统的 A 类、B 类和 C 类地址，以及划分子网概念\nCIDR 可以更加有效地分配 IPv4 的地址空间，并且可以在新的 IPv6 使用之前允许因特网的规模继续增长\n\n\nCIDR 使用“斜线记法”或称为 CIDR 记法，即在 IPv4 地址后面加上斜线“/”，在斜线后面写上网络前缀所占的比特数量\n例如 128.14.35.7/20 表示网络前缀所占用的比特数量为 20，主机编号所占用的比特数量为 12\n\n\nCIDR 实际上是将网络前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”\n\n\n例：请给出 CIDR 地址块128.14.35.7/20 的全部细节\n\n\n\n2. 最长前缀匹配\n在使用 CIDR 时，由于采用了网络前缀这种记法，因此在路由表中的项目需要改变为由“网络前缀”和 “下一跳地址”组成。但是在查找路由表时可能会得到不止一个匹配结果\n对于这种情况，应当从匹配结果中选择具有最长网络前缀的路由。这叫做最长前缀匹配（longest-prefix matching）\n这是因为网络前缀越长，其地址块就越小，因而路由就越具体\n\n\n\n例如，对于上图中假定 ISP 收到一个数据报，其目的地址 IP 为 ，把  分别和路由表中的大学（206.0.68.0/22）和四系（206.0.71.128/25）的子网掩码诸位相“与”，发现均匹配，但根据最长前缀原则，应该选择后者（四系）\n4.4 网际控制报文协议ICMP\n为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP（Internet Control Message Protocol）\nICMP 报文被封装在 IP 数据报中发送\n\n\n\n4.4.1 ICMP报文的种类ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文\n\nICMP 差错报告报文共有以下五种：\n终点不可达：当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。具体可再根据 ICMP 的代码字段细分为目的网络不可达、目的主机不可达、目的端口不可达、目的网络未知、目的主机未知等13种错误\n源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢\n时间超过：当路由器收到一个目的 IP 地址不是自己的 IP 数据报，会将其生存时间 TTL 字段的值减 1，若结果不为 0，则将该 IP 数据报转发出去；若结果为 0，除丢弃该 IP 数据报外，还要向源点发送时间超过报文。另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超过报文\n参数问题：当路由器或目的主机收到 IP 数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文\n改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）\n\n\n以下情况下不应发送 ICMP 差错报告报文：\n对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文\n对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 差错报告报文\n对具有多播地址的数据报，都不发送 ICMP 差错报告报文\n对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报，不发送 ICMP 差错报告报文\n\n\n常用的 ICMP 询问报文有两种：\n回送请求和回答： ICMP 回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。\n时间戳请求和回答： ICMP 时间戳请求报文是请某台主机或路由器回答当前的日 期和时间。在 ICMP 时间戳回答报文中有一个 32 位的字段，其中写入的整数代表从 1900 年 1 月 1 日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。\n\n\n\n4.4.2 ICMP的应用举例\n分组网间探测 PING（Packet InterNet Groper）\n用来测试主机和路由器间的连通性\n应用层直接使用网际层的 ICMP（没有通过运输层的 TCP 或 UDP）\n使用 ICMP 回送请求和回答报文\n使用命令为 ping hostname\n\n\n跟踪路由（traceroute）\n用来测试 IP 数据报从源主机到达目的主机需要经过哪些路由器\nWindows 版本\ntracert 命令\n应用层直接使用网际层 ICMP\n使用了 ICMP 回送请求和回答报文以及差错报告报文\n\n\nUnix 版本\ntraceroute 命令\n在运输层使用 UDP 协议\n仅使用 ICMP 差错报告报文\n\n\n\n\n\n4.5 互联网的路由选择协议4.5.1 有关路由选择协议的几个基本概念1. 理想的路由算法一个理想的路由算法应具有如下的一些特点\n\n算法必须是正确的和完整的\n算法在计算上应简单\n算法应能适应通信量和网络拓扑的变化\n算法应具有稳定性\n算法应是公平的\n算法应是最佳的\n\n倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即静态路由选择策略与动态路由选择策略\n\n静态路由选择\n由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由\n这种人工配置方式简单、开销小，但不能及时适应网络状态（流量、拓扑等）的变化\n一般只在小规模网络中采用\n\n\n动态路由选择\n路由器通过路由选择协议自动获取路由信息\n比较复杂、开销比较大，能较好地适应网络状态的变化\n适用于大规模网络\n\n\n\n2. 分层次的路由选择协议互联网采用分层次的路由选择协议，因此可以把整个互联网划分为许多较小的自治系统 AS（autonomous system）。自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略\n\n\n互联网将路由选择协议划分为两大类，即：\n\n内部网关协议 IGP（Interior Gateway Protocol）：即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议\n外部网关协议 EGP（External Gateway Protocol）：若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4（BGP-4）\n\n\n4.5.2 内部网关协议RIP1. 工作原理\n路由信息协议 RIP（routing information protocol）是内部网关协议 IGP 中最先得到广泛使用的协议之一，其相关标准文档为 RFC 1058\n\nRIP 要求自治系统 AS 内的每一个路由器都要维护从它自己到 AS 内其他每一个网络的距离记录。这是一组距离，称为距离向量 D-V（distance vector）\n\nRIP 使用跳数（hop count）作为度量（metric）来衡量到达目的网络的距离\n\n路由器到直连网络的距离定义为 1\n路由器到非直连网络的距离定义为所经过的路由器数加 1\n允许一条路径最多只能包含 15 个路由器。“距离”等于 16 时相当于不可达。因此 RIP 只适用于小型互联网\n\n\nRIP 认为好的路由就是“距离短”的路由，也就是所通过路由器数量最少的路由\n\n当到达同一目的网络有多条“距离相等”的路由时，可以进行等价负载均衡\n\nRIP 包含以下三个要点：\n\n和谁交换信息：仅和相邻路由器交换信息\n交换什么信息：当前本路由器所知道的全部信息，即自己现在的路由表\n在什么时候交换信息：按固定的时间间隔周期性交换（例如每 30 秒）\n\n\n路由器在刚刚开始工作时，它的路由表是空的。然后路由器就得出到直接相连的几个网络的距离（这些距离定义为 1）。接着，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。但经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址\n\n\n2. 距离向量算法对每一个相邻路由器发送过来的 RIP 报文，进行以下步骤：\n\n对地址为  的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把“下一跳”字段中的地址都改为 ，并把所有的“距离”字段的值加 1。每一个项目都有三个关键数据，即：到目的网络 ，距离是 ，下一跳路由器是 \n对修改后的 RIP 报文中的每一个项目，进行以下步骤： \n若原来的路由表中没有目的网络 ，则把该项目添加到路由表中\n否则（即在路由表中有目的网络 ，这时就再查看下一跳路由器地址）\n若下一跳路由器地址是 ，则把收到的项目替换原路由表中的项目 \n否则（即这个项目是:到目的网络 ，但下一跳路由器不是 ）\n若收到的项目中的距离  小于路由表中的距离，则进行更新\n否则什么也不做\n\n\n\n\n\n\n若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路路由器，即把距离置为 16（距离为 16 表示不可达）\n返回\n\n\n已知路由器  有下表所示的路由表。现在收到相邻路由器  发来的路由更新信息，如下表所示。试更新路由器  的路由表\n\n路由器  的路由表（表1）\n\n\n\n目的网络\n距离\n下一跳路由器\n\n\n\nNet 2\n3\n\n\n\nNet 3\n4\n\n\n\n……\n……\n……\n\n\n 发来的路由更新信息（表2）\n\n\n\n目的网络\n距离\n下一跳路由器\n\n\n\nNet 1\n3\n\n\n\nNet 2\n4\n\n\n\nNet 3\n1\n直接交付\n\n\n首先先把表2中的距离都加1，并把下一跳路由器都改为 ，得出表3\n\n\n\n目的网络\n距离\n下一跳路由器\n\n\n\nNet 1\n4\n\n\n\nNet 2\n5\n\n\n\nNet 3\n2\n\n\n\n把表3和的每一行和表1进行比较\n\n第一行在表1中没有，因此要把这一行添加到表1中。\n第二行的 Net 2 在表1中有，且下一跳路由器也是 。因此要更新（最新消息）\n第三行的 Net 3 在表1中有，但下一跳路由器不同。于是就要比较距离。新的路由信息的距离是 2，小于原来表中的 4，因此要更新。\n\n得出更新后的 R6 的路由表如下表所示。\n\n\n\n目的网络\n距离\n下一跳路由器\n\n\n\nNet 1\n4\n\n\n\nNet 2\n5\n\n\n\nNet 3\n2\n\n\n\n……\n……\n……\n\n\n3. RIP协议的报文格式\n\n\nRIP 存在”坏消息传播得慢“的问题，即当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器\n”坏消息传播得慢“又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。可以采取多种措施减少出现该问题的概率或减小该问题带来的危害\n限制最大路径距离为 15（16表示不可达）\n当路由表发生变化时就立即发送更新报文（即”触发更新“），而不仅是周期性发送\n让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即”水平分割“）\n\n\n\n\n\n\n现在假定路由器  到网 1 的链路出了故障， 无法到达网 1。于是路由器  把到网 1 的距离改为 16（表示到网 1 不可达），因而在  的路由表中的相应项目变为“1, 16, 直接”\n但是，很可能要经过 30 秒钟后  才把更新信息发送给 。然而  可能已经先把自己的路由表发送给了 ，其中有“1, 2, ”这一项\n 收到  的更新报文后，误认为可经过  到达网 1，于是把收到的路由信息“1, 2, ”修改为：“1, 3, ”，表明“我到网1的距离是3，下一跳经过”，并把更新后的信息发送给 \n同理， 接着又更新自己的路由表为“1, 4, ”，以为“我到网1距离是4，下一跳经过 ”。\n这样的更新一直继续下去，直到  和  到网 1 的距离都增大到 16 时， 和  才知道原来网 1 是不可达的\n\n4.5.3 内部网关协议OSPF1. OSPF协议的基本特点\n开放最短路径优先 OSPF（Open Shortest Path First）是为克服 RIP 的缺点在 1989 年开发出来的\n\n“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的\n“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF\n\n\nOSPF 与 RIP 工作要点的对比\n\n采用洪泛法（flooding）向本自治系统中所有路由器发送信息；而 RIP 仅仅向自己相邻的几个路由器发送信息\n发送的信息是与本路由器相邻的所有路由器的链路状态，“链路状态”指的是本路由器都和哪些路由器相邻，以及相应链路的代价（cost）；而 RIP 发送的信息是到所有网络的距离和下一跳路由器\n只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息；而 RIP不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息\n\n\n由于各路由器之间频繁地交换链路状态信息（link-state advertisement，LSA），因此所有的路由器最终都能建立一个链路状态数据库（link-state database，LSDB），这个数据库实际上就是全网的拓扑结构图，每一个路由器使用链路状态数据库中的数据，构造出自己的路由表\n\n\n为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做区域（area）。划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信量\n\n\n对于上图，则有\n\n区域内路由器 IR（internal router）：，，，\n区域边界路由器 ABR（area border router）：，，\n主干路由器 BBR（backbone router）：，，，，\n自治系统边界路由器 ASBR（AS border router）：\n\n2. OSPF的基本工作原理\nOSPF 共有 5 种分组类型\n\n类型 1，问候（Hello）分组，用来发现和维持邻站的可达性\n类型 2，数据库描述（Database Description）分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息\n类型 3，链路状态请求（Link State Request）分组，向对方请求发送某些链路状态项目的详细信息\n类型 4，链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态，路由器使用这种分组将其链路状态通知给邻站\n类型 5，链路状态确认（Link State Acknowledgment）分组，对链路更新分组的确认\n\n\n\n\n\n\nOSPF 规定，每两个相邻路由器每隔 10 秒钟要交换一次问候分组。这样就能确知哪些邻站是可达的，若有 40 秒钟没有收到某个相邻路由器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，并重新计算路由表。\n\nOSPF 在多点接入网络中路由器邻居关系的建立\n\n选举指定路由器 DR（designated router）和备用的制定路由器 BDR（backup designated router）\n所有的非 DR/BDR 只与 DR/BDR 建立邻居联系\n非 DR/BDR 之间通过 DR/BDR 交换信息\n\n\n\n4.5.4 外部网关协议BGP\n外部网关协议 EGP（例如边界网关协议 BGP）\n在不同的自治系统内，度量路由的“代价”（距离、带宽、费用等）可能不同，因此对于自治系统之间的路由选择，使用“代价”作为度量来寻找最佳路由是不行的\n自治系统之间的路由选择必须考虑相关的策略（政治、经济、安全等）\nBGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由\n\n\n在配置 BGP 时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人”\n在不同自治系统的 BGP 发言人要交换路由信息，首先必须建立 TCP 连接，端口号为 179\n在此 TCP 连接上交换 BGP 报文以建立 BGP 会话\n利用 BGP 会话交换路由信息，例如增加新的路由，或撤销过时的路由，以及报告出错的情况等\n使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此称为对方的邻站（neighbor）或对等站（peer）\n\n\nBGP 发言人除了运行 BGP 外，还必须运行自己所在自治系统所使用的内部网关协议 IGP，例如 OSPF 或 RIP\n\n\n\n\nBGP 发言人交换网络可达性的信息（要到达某个网络所要经过的一系列自治系统）\n当 BGP 发言人互相交换例网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由，也就是构造出树形结构、不存在回路的自治系统连通图\n\n\n\n\nBGP 适用于多级结构的因特网，以下图为例：\n自治系统  的 BGP 发言人通知主干网的BGP发言人：“要到达网络，， 和可经过。”\n主干网在收到这个通知后，就发出通知：“要到达网络，， 和  可沿路径 。”\n同理，主干网还可发出通知：“要到达网络 ， 和  可沿路径 。”\n\n\n\n\n\n\nBGP 有以下四种报文：\nOPEN（打开）报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化\nUPDATE（更新）报文，用来通告某一路由的信息，以及列出要撤销的多条路由\nKEEPALIVE（保活）报文，用来周期性地证实邻站的连通性\nNOTIFICATION（通知）报文，用来发送检测到的差错\n\n\n\n\n\n4.5.5 路由器的构成1. 路由器的结构\n路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组\n从路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。下一跳路由器也按照这种方法处理分组， 直到该分组到达终点为止\n\n\n\n\n整个的路由器结构可划分为两大部分：路由选择部分和分组转发部分\n\n路由选择部分也叫做控制部分，其核心构件是路由选择处理机\n\n路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信 息而不断地更新和维护路由表\n\n\n分组转发部分由三部分组成：交换结构、一组输入端口和一组输出端口\n\n交换结构（switching fabric）又称为交换组织，它的作用就是根据转发表（forwarding table）对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去\n\n注意，在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，而可以笼统地都使用路由表这一名词\n\n\n输入端口中的查找和转发功能在路由器的交换功能中是最重要的。为了使交换功能分散化，往往把复制的转发表放在每一个输入端口中（如上图中的虚线箭头所示）。路由选择处理机负责对各转发表的副本进行更新。这些副本常称为“影子副本”\n\n分组在路由器的输入端口和输出端口都可能会在队列中排队等候处理\n\n\n\n\n\n\n\n2. 交换结构\n\n\n最早使用的路由器就是利用普通的计算机，用计算机的 CPU 作为路由器的路由选择 理机。路由器的输入和输出端口的功能和传统的操作系统中的 I/O 设备一样\n许多现代的路由器也通过存储器进行交换，上图（a）表示分组通过存储器进行交换。与早期的路由器的区别就是，目的地址的查找和分组在存储器中的缓存都是在输入端口中进行的\n图 （b）是通过总线进行交换的示意图。采用这种方式时，数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。但是，由于总线是共享的，因此在同一时间只能有一个分组在总线上传送。当分组到达输入端口时若发现总线忙，则被阻塞而不能通过交换结构，并在输入端口排队等待。因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的限制\n图（c）是通过纵横交换结构进行交换。这种交换机构常称为互连网络，它有  条总线，可以使  个输入端口和  个输出端口相连接，这取决于相应的交叉结点是使水平总线和垂直总线接通还是断开。当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口 的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。但若该垂直总线已被占用，则后到达的分组就被阻塞，必须在输入端口排队\n\n4.6 虚拟专用网VPN和网络地址转换NAT4.6.1 虚拟专用网VPN\n2013 年，RFC 6890全面地给出了一些专用地址，这些地址只能用于一个机构的内部通信，而不能用于和互联网上的主机通信，采用这样专用 IP 地址的互连网络称为专用网，这些地址为\n\n10.0.0.0 到 10.255.255.255（10.0.0.0/8）\n172.16.0.0 到 172.31.255.255（172.16.0.0/12）\n192.168.0.0 到 192.168.255.255（192.168.0.0/16）\n\n\n利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网（virtual private network）\n\n由于 IPv4 地址的紧缺，一个机构能够申请到的 IPv4 地址数量往往远小于本机构所拥有的主机数量。因此，虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要申请的、在因特网上使用的共有地址\n\n\n\n\n4.6.2 网络地址转换NAT\n虽然因特网采用了无分类编址方式来缓解 IPv4 地址空间耗尽的速度，但由于因特网用户数目的激增，特别是大量小型办公室网络和家庭网络接入因特网的需求不断增加，IPv4 地址空间即将面临耗尽的危险仍然没有被解除\n1994 年提出了一种网络地址转换 NAT 的方法再次缓解了 IPv4 地址空间即将耗尽的问题\nNAT 能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源\n\n\n\n\nNAT 路由器工作原理\n\nNAT 路由器收到从专用网内部的主机 A 发往互联网上主机 B 的 IP 数据报：源 IP 地址是 192.168.0.3，而目的 IP 地址是 213.18.2.4。NAT 路由器把 IP 数据报的源 IP 地址 192.168.0.3，转换为新的源 IP 地址（即 NAT 路由器的全球 IP 地址）172.38.1.5，然后转发出去\n主机 B 收到这个 IP 数据报时，以为 A 的 IP 地址是 172.38.1.5。当 B 给 A 发送应答时，IP 数据报的目的 IP 地址是 NAT 路由器的 IP 地址 172.38.1.5\n当 NAT 路由器收到互联网上的主机 B 发来的 IP 数据报时，还要进行一次 IP 地址的转换。通过 NAT 地址转换表，就可把 IP 数据报上的旧的目的 IP 地址 172.38.1.5，转换为新的目的 IP 地址 192.168.0.3（主机 A 真正的本地 IP 地址）\n该过程的 NAT 地址转换表如下\n\n\n\n\n方向\n字段\n旧的 IP 地址\n新的 IP 地址\n\n\n\n出\n源 IP 地址\n192.168.0.3\n172.38.1.5\n\n\n入\n目的 IP 地址\n172.38.1.5\n192.168.0.3\n\n\n出\n源 IP 地址\n192.168.0.7\n172.38.1.6\n\n\n入\n目的 IP 地址\n172.38.1.6\n192.168.0.7\n\n\n\n由此可见，当 NAT 路由器具有  个全球 IP 地址时，专用网内最多可以同时有  台主机接入到互联网\n\n\n由于绝大多数的网络应用都是使用运输层协议 TCP 或 UDP 来传送数据，因此可以利用运输层端口号和 IP 地址一起进行转换。这样，用一个全球 IP 地址就可以使多个拥有本地地址的主机同时和因特网上的主机通信。这种将端口号和 IP 地址一起进行转换的技术叫作网络地址与端口号转换 NAPT（network address and port translation）\n\nNAPT 地址转换举例\n\n\n\n\n方向\n字段\n旧的 IP 地址和端口号\n新的 IP 地址和端口号\n\n\n\n出\n源 IP 地址\n192.168.0.3:30000\n172.38.1.5:40001\n\n\n入\n目的 IP 地址\n172.38.1.5:30000\n192.168.0.3:40002\n\n\n出\n源 IP 地址\n192.168.0.7:40001\n172.38.1.6:30000\n\n\n入\n目的 IP 地址\n172.38.1.6:40002\n192.168.0.7:30000\n\n\n\n在专用网内主机 192.168.0.3 向互联网发送 IP 数据报，其 TCP 端口号选择为 30000。NAPT 把源 IP 地址和 TCP 端口号都进行转换。另一台主机 192.168.0.4 也选择了同样的 TCP 端口号 30000。这纯属巧合。现在 NAPT 把专用网内不同的源 IP 地址都转换为同样的全球 IP 地址。但对源主机所采用的 TCP 端口号，则转换为不同的新的端口号。因此，当 NAPT 路由器收到从互联网发来的应答时，就可以从 IP 数据报的数据部分找出运输层的端口号，然后根据不同的目的端口号，从 NAPT 转换表中找到正确的目的主机\n\n\n对于一些 P2P 网络应用，需要外网主机与内网主机进行通信，在通过 NAT 时会遇到问题，需要网络应用自己使用一些特殊的 NAT 穿越技术来解决问题\n\n由于 NAT 对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护\n\n\n","categories":["计算机网络"]}]